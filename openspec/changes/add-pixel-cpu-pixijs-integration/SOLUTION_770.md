# Solution for Task: Links work

Section 1: Principles

- **Non-Blocking Execution**: CPU execution must not block the render loop
- **Visual-Fiirsst**: CPU state is visualized as part of the infinite map
- **Memory-Mapped I/O**: Console and framebuffer use memory-mapped I/O for simplicity
- **Incremental Loadings**: Brick files are loaded asyncrhonously
- **Performance First**: Maintaine 60 FPS during CPU execution

Section 2: System Architecture

- Visual Shell (Browsr): This component provides a browser-based environment for the visual shell. It includes an in-memory virtual machine (VM) that executes PixiJS v8 on top of a RISC-V CPU implementation. The VM is responsible for rendering graphics and handling input events, such as keyboard and mouse inputs.
- PixiJS Application: This component runs atop the Virtual Machine, providing a user interface to interact with the system. It includes an infinite scrolling map that displays visual tiles and handles real-time updates generated by the PixiJS v8 VM. The map uses Rust for its rendering capabilities, which provide high performance while keeping the code simple.

Section 3: Solution Design

The goal of this task is to add a feature that allows CPU execution within the PixiJS application. This will allow the system to execute `.brick` files containing transpiled RISC-V instructions on the PixiJS v8 VM, which would enhance real-time visualization and provide an alternative to the current blocking execution mode.

To achieve this, the following design principles must be followed:

1. **Non-Blocking Execution**: CPU execution must not block the render loop. This means that it should not wait for any input events or updates from the PixiJS v8 VM before executing the next instruction.
2. **Visual-Fiirsst**: The PixiJS application should be designed to visualize the CPU state as a part of the infinite map, allowing users to view real-time CPU activity and interact with it directly.
3. **Memory-Mapped I/O**: Consoles and framebuffers use memory-mapped I/O to ensure high performance without blocking the render loop.
4. **Incremental Loadings**: Brick files are loaded asynchronously, ensuring that they are not blocked while rendering or updating the map.
5. **Performance First**: The system should prioritize achieving high performance by minimizing the amount of time taken to execute CPU instructions and minimize the need for input events from the PixiJS v8 VM.

Section 4: System Testing Plan

To test this solution design, a test plan is needed that simulates various use cases and ensures that it performs as expected. The following steps are suggested to ensure success of the test plan:

1. Create a virtual machine (VM) with RISC-V CPU and PixiJS v8 VM installed on it.
2. Install Node.js, Rust, and Python into this VM, ensuring that these tools are available for execution within the VM.
3. Configure the PixiJS application to connect to the virtual machine by setting up a network connection or using a local port forwarding.
4. Create a set of `.brick` files containing transpiled RISC-V instructions, and test them with the PixiJS v8 VM on the VM.
5. Configure the visual shell (browsr) to load these `.brick` files asynchronously and interact with the PixiJS application in real-time.
6. Test different use cases, such as rendering a large number of tiles or updating the map frequently.
7. Monitor system performance metrics to ensure that CPU execution is efficient and no input events are blocked.
8. Analyze any issues or limitations discovered during testing and make necessary adjustments to the solution design.