// VectorOS v2 Memory Manager Header
// Generated by v1 Neural OS Bootstrap System

#pragma once

#include <memory>
#include <vector>
#include <unordered_map>
#include <mutex>
#include <map>
#include <cstdint>

namespace vectoros_v2 {

/**
 * @brief Memory Manager - Unified memory management system
 * 
 * Implements unified tensor memory model with GPU acceleration support.
 * Provides memory pools, GPU-CPU memory transfer, and memory protection.
 */
class MemoryManager {
private:
    struct MemoryBlock {
        void* ptr;
        size_t size;
        bool is_gpu;
        bool is_pinned;
        std::string tag;
    };
    
    std::vector<MemoryBlock> memory_blocks_;
    std::unordered_map<void*, size_t> block_map_;
    mutable std::mutex memory_mutex_;
    
    size_t total_allocated_ = 0;
    size_t peak_allocated_ = 0;
    size_t gpu_memory_used_ = 0;
    
    struct MemoryPool {
        size_t total_size;
        size_t used_size;
        void* base_ptr;
        std::string name;
    };

    std::map<std::string, MemoryPool> pools_;
    bool gpu_available_ = false;
    bool unified_memory_ = false;
    
public:
    MemoryManager() = default;
    ~MemoryManager();
    
    /**
     * @brief Initialize the memory manager
     * @return true if initialization successful, false otherwise
     */
    bool initialize();
    
    /**
     * @brief Allocate memory block
     * @param size Size in bytes
     * @param on_gpu Whether to allocate on GPU
     * @param tag Optional tag for debugging
     * @return Pointer to allocated memory, or nullptr if failed
     */
    void* allocate(size_t size, bool on_gpu = false, const std::string& tag = "");
    
    /**
     * @brief Deallocate memory block
     * @param ptr Pointer to memory to deallocate
     * @return true if deallocation successful, false otherwise
     */
    bool deallocate(void* ptr);
    
    /**
     * @brief Allocate pinned memory for fast GPU transfers
     * @param size Size in bytes
     * @param tag Optional tag for debugging
     * @return Pointer to allocated memory, or nullptr if failed
     */
    void* allocate_pinned(size_t size, const std::string& tag = "");
    
    /**
     * @brief Create a specialized memory pool.
     */
    bool create_pool(const std::string& name, size_t size, bool on_gpu = false);
    
    /**
     * @brief Transfer memory from CPU to GPU
     * @param src Source pointer (CPU)
     * @param dst Destination pointer (GPU)
     * @param size Size to transfer in bytes
     * @return true if transfer successful, false otherwise
     */
    bool transfer_cpu_to_gpu(const void* src, void* dst, size_t size);
    
    /**
     * @brief Transfer memory from GPU to CPU
     * @param src Source pointer (GPU)
     * @param dst Destination pointer (CPU)
     * @param size Size to transfer in bytes
     * @return true if transfer successful, false otherwise
     */
    bool transfer_gpu_to_cpu(const void* src, void* dst, size_t size);
    
    /**
     * @brief Get total allocated memory
     * @return Total allocated memory in bytes
     */
    size_t get_total_allocated() const;
    
    /**
     * @brief Get peak allocated memory
     * @return Peak allocated memory in bytes
     */
    size_t get_peak_allocated() const;
    
    /**
     * @brief Get GPU memory usage
     * @return GPU memory usage in bytes
     */
    size_t get_gpu_memory_used() const;
    
    /**
     * @brief Check if GPU is available
     * @return true if GPU available, false otherwise
     */
    bool is_gpu_available() const { return gpu_available_; }
    
    /**
     * @brief Check if unified memory is available
     * @return true if unified memory available, false otherwise
     */
    bool is_unified_memory() const { return unified_memory_; }
    
    /**
     * @brief Get memory statistics
     * @return Memory statistics string
     */
    std::string get_memory_stats() const;
    
    /**
     * @brief Compact memory (defragmentation)
     */
    void compact();
    
    /**
     * @brief Validate memory block
     * @param ptr Pointer to validate
     * @return true if valid, false otherwise
     */
    bool validate_memory(void* ptr) const;
    
    /**
     * @brief Get memory block information
     * @param ptr Pointer to query
     * @return Information string about the memory block
     */
    std::string get_block_info(void* ptr) const;
};

} // namespace vectoros_v2