// VectorOS v2 Security Manager Header
// Generated by v1 Neural OS Bootstrap System

#pragma once

#include <memory>
#include <string>
#include <vector>
#include <unordered_map>
#include <mutex>

namespace vectoros_v2 {

/**
 * @brief Security Manager - Zero-trust security enforcement
 * 
 * Implements capability-based access control with minimal attack surface.
 * Provides memory isolation and comprehensive security event logging.
 */
class SecurityManager {
private:
    struct Capability {
        std::string id;
        std::string resource;
        std::vector<std::string> permissions;
        uint64_t expiration_time;
    };
    
    struct SecurityEvent {
        uint64_t timestamp;
        std::string event_type;
        std::string source;
        std::string target;
        bool success;
        std::string details;
    };
    
    std::unordered_map<std::string, Capability> capabilities_;
    std::vector<SecurityEvent> security_log_;
    mutable std::mutex security_mutex_;
    
    bool initialized_ = false;
    bool audit_mode_ = false;
    size_t max_log_entries_ = 10000;
    
public:
    SecurityManager() = default;
    ~SecurityManager() = default;
    
    /**
     * @brief Initialize the security manager
     * @return true if initialization successful, false otherwise
     */
    bool initialize();
    
    /**
     * @brief Create a new capability
     * @param capability_id Unique identifier for the capability
     * @param resource Resource this capability applies to
     * @param permissions List of permissions (read, write, execute, etc.)
     * @param expiration_time Expiration time in milliseconds since epoch
     * @return true if capability created, false otherwise
     */
    bool create_capability(const std::string& capability_id,
                          const std::string& resource,
                          const std::vector<std::string>& permissions,
                          uint64_t expiration_time);
    
    /**
     * @brief Check if a capability is valid
     * @param capability_id Capability to check
     * @return true if valid, false otherwise
     */
    bool validate_capability(const std::string& capability_id) const;
    
    /**
     * @brief Check if a capability has specific permission
     * @param capability_id Capability to check
     * @param permission Permission to verify
     * @return true if has permission, false otherwise
     */
    bool has_permission(const std::string& capability_id, const std::string& permission) const;
    
    /**
     * @brief Revoke a capability
     * @param capability_id Capability to revoke
     * @return true if revoked, false otherwise
     */
    bool revoke_capability(const std::string& capability_id);
    
    /**
     * @brief Log a security event
     * @param event_type Type of security event
     * @param source Source of the event
     * @param target Target of the event
     * @param success Whether the event was successful
     * @param details Additional details about the event
     */
    void log_security_event(const std::string& event_type,
                           const std::string& source,
                           const std::string& target,
                           bool success,
                           const std::string& details = "");
    
    /**
     * @brief Get security log
     * @param limit Maximum number of entries to return
     * @return Security log entries
     */
    std::vector<SecurityEvent> get_security_log(size_t limit = 100) const;
    
    /**
     * @brief Enable audit mode
     * @param enable Whether to enable audit mode
     */
    void set_audit_mode(bool enable);
    
    /**
     * @brief Check if audit mode is enabled
     * @return true if audit mode enabled, false otherwise
     */
    bool is_audit_mode() const { return audit_mode_; }
    
    /**
     * @brief Perform security check
     * @param capability_id Capability to use for the check
     * @param resource Resource to access
     * @param operation Operation to perform
     * @return true if access granted, false otherwise
     */
    bool check_access(const std::string& capability_id,
                     const std::string& resource,
                     const std::string& operation);
    
    /**
     * @brief Get security statistics
     * @return Security statistics string
     */
    std::string get_security_stats() const;
    
    /**
     * @brief Clean up expired capabilities
     */
    void cleanup_expired_capabilities();
    
    /**
     * @brief Check if security manager is initialized
     * @return true if initialized, false otherwise
     */
    bool is_initialized() const { return initialized_; }
    
    /**
     * @brief Get number of active capabilities
     * @return Number of active capabilities
     */
    size_t get_active_capabilities_count() const;
};

} // namespace vectoros_v2