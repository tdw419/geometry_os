# WGSL Shader i64 Compatibility Fix Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix WGSL shader i64 compatibility issues to unblock RISC-V GPU VM execution

**Architecture:** WebGPU's WGSL has limited i64 support - we need to detect GPU capabilities, provide fallback implementations for i64 operations using 2x i32 emulation, and ensure graceful degradation on unsupported hardware.

**Tech Stack:** WGSL (WebGPU Shading Language), Rust (wgpu), naga (shader compiler)

**Problem Context:**
- WGSL's i64 support is inconsistent across GPU vendors
- RISC-V VM requires 64-bit integer operations for instruction decoding
- Current shaders fail on hardware without native i64 support
- Need both detection and emulation paths

---

## Task 1: Create GPU Capability Detection Module

**Files:**
- Create: `geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/gpu_capabilities.rs`
- Modify: `geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/main.rs` (add module import)

**Step 1: Write the failing test**

```rust
// gpu_capabilities.rs tests
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_detect_i64_support() {
        let instance = wgpu::Instance::default();
        let adapter = instance
            .request_adapter(&wgpu::RequestAdapterOptions::default())
            .await
            .expect("Failed to find adapter");

        let caps = GpuCapabilities::new(&adapter).await;

        // Should at least detect something without crashing
        assert!(!caps.vendor_name.is_empty());
        println!("i64 supported: {}", caps.supports_i64);
    }

    #[test]
    fn test_i64_emulation_fallback() {
        let caps = GpuCapabilities {
            supports_i64: false,
            vendor_name: "Test GPU".to_string(),
            device_name: "Test Device".to_string(),
        };

        assert_eq!(caps.get_i64_strategy(), I64Strategy::Emulate);
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd geometry_os/geometry-os-phase44/systems/infinite_map_rs && cargo test detect_i64_support -- --nocapture`
Expected: FAIL with "GpuCapabilities not defined"

**Step 3: Write minimal implementation**

```rust
// gpu_capabilities.rs
use wgpu::Adapter;

/// Strategy for handling i64 operations in shaders
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum I64Strategy {
    /// Use native i64 support
    Native,
    /// Emulate i64 using i32 pairs
    Emulate,
}

/// GPU capability detection
#[derive(Debug, Clone)]
pub struct GpuCapabilities {
    pub supports_i64: bool,
    pub vendor_name: String,
    pub device_name: String,
}

impl GpuCapabilities {
    pub async fn new(adapter: &Adapter) -> Self {
        let info = adapter.get_info();

        // Query adapter for i64 support
        let features = adapter.features();

        // WebGPU doesn't expose i64 as a feature directly
        // We need to test by trying to create a shader with i64
        let supports_i64 = Self::test_i64_support(adapter).await;

        Self {
            supports_i64,
            vendor_name: format!("{:?}", info.vendor),
            device_name: info.name.clone(),
        }
    }

    async fn test_i64_support(adapter: &Adapter) -> bool {
        use wgpu::{DeviceDescriptor, ShaderModuleDescriptor};

        let (device, _queue) = adapter
            .request_device(
                &DeviceDescriptor {
                    label: Some("i64_test"),
                    required_features: wgpu::Features::empty(),
                    required_limits: wgpu::Limits::default(),
                },
                None,
            )
            .await;

        if device.is_err() {
            return false;
        }

        let (device, queue) = device.unwrap();

        // Test shader with i64 operations
        let test_shader = device.create_shader_module(ShaderModuleDescriptor {
            label: Some("i64_test_shader"),
            source: wgpu::ShaderSource::Wgsl(
                r#"
                @group(0) @binding(0)
                var<storage, read> input: array<i64>;

                @group(0) @binding(1)
                var<storage, read_write> output: array<i64>;

                @workgroup_size(1)
                @compute @main
                fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                    output[id.x] = input[id.x] + 1i64;
                }
                "#.into(),
            ),
        });

        // Try to create a compute pipeline with i64 operations
        let result = device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
            label: Some("i64_test_pipeline"),
            layout: None,
            module: &test_shader,
            entry_point: Some("main"),
            compilation_options: Default::default(),
        });

        drop(queue);
        drop(device);

        result.is_ok()
    }

    pub fn get_i64_strategy(&self) -> I64Strategy {
        if self.supports_i64 {
            I64Strategy::Native
        } else {
            I64Strategy::Emulate
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `cd geometry_os/geometry-os-phase44/systems/infinite_map_rs && cargo test detect_i64_support -- --nocapture`
Expected: PASS

**Step 5: Add module to main**

```rust
// main.rs - add at top with other modules
pub mod gpu_capabilities;
```

**Step 6: Commit**

```bash
git add geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/gpu_capabilities.rs
git add geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/main.rs
git commit -m "feat: add GPU capability detection for i64 support"
```

---

## Task 2: Create i64 Emulation Utility Functions

**Files:**
- Create: `geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/i64_emulation.rs`
- Modify: `geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/main.rs`

**Step 1: Write the failing test**

```rust
// i64_emulation.rs tests
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_i64_to_u32x2() {
        // Test positive value
        let val: i64 = 0x1234567890ABCDEF;
        let (lo, hi) = i64_to_u32x2(val);
        assert_eq!(lo, 0x90ABCDEF);
        assert_eq!(hi, 0x12345678);
    }

    #[test]
    fn test_u32x2_to_i64() {
        let lo: u32 = 0x90ABCDEF;
        let hi: u32 = 0x12345678;
        let val = u32x2_to_i64(lo, hi);
        assert_eq!(val, 0x1234567890ABCDEF);
    }

    #[test]
    fn test_i64_add_emulation() {
        let a: i64 = 10000000000;
        let b: i64 = 20000000000;
        let result = emulated_i64_add(a, b);
        assert_eq!(result, 30000000000);
    }

    #[test]
    fn test_i64_add_with_overflow() {
        let a: i64 = i64::MAX;
        let b: i64 = 1;
        let (result, overflow) = emulated_i64_add_overflow(a, b);
        assert_eq!(result, i64::MIN); // Wrapped around
        assert!(overflow);
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd geometry_os/geometry-os-phase44/systems/infinite_map_rs && cargo test i64_emulation`
Expected: FAIL with "functions not defined"

**Step 3: Write minimal implementation**

```rust
// i64_emulation.rs
/// Utilities for emulating i64 operations using u32 pairs

/// Split i64 into low and high u32 parts (little-endian)
#[inline]
pub const fn i64_to_u32x2(value: i64) -> (u32, u32) {
    let value = value as u64;
    let lo = (value & 0xFFFFFFFF) as u32;
    let hi = ((value >> 32) & 0xFFFFFFFF) as u32;
    (lo, hi)
}

/// Combine low and high u32 parts into i64 (little-endian)
#[inline]
pub const fn u32x2_to_i64(lo: u32, hi: u32) -> i64 {
    ((hi as u64) << 32) | (lo as u64) as i64
}

/// Emulate i64 addition using u32 arithmetic with carry
pub fn emulated_i64_add(a: i64, b: i64) -> i64 {
    let a_lo = a as u32;
    let a_hi = ((a as u64) >> 32) as u32;
    let b_lo = b as u32;
    let b_hi = ((b as u64) >> 32) as u32;

    // Add low parts with overflow detection
    let (lo, carry1) = a_lo.overflowing_add(b_lo);

    // Add high parts with carry from low addition
    let (hi, carry2) = a_hi.overflowing_add(b_hi);
    let hi = hi.wrapping_add(carry1 as u32);

    // Check for signed overflow
    let result = u32x2_to_i64(lo, hi);

    // Handle signed overflow case
    if carry2 {
        // This is actual overflow - wrap around
        result
    } else {
        result
    }
}

/// Emulate i64 addition with overflow flag
pub fn emulated_i64_add_overflow(a: i64, b: i64) -> (i64, bool) {
    let a_bits = a as u64;
    let b_bits = b as u64;

    let result = a_bits.wrapping_add(b_bits);
    let overflow = (a_bits ^ result) & (b_bits ^ result) & (1 << 63) != 0;

    (result as i64, overflow)
}

/// Emulate i64 subtraction
pub fn emulated_i64_sub(a: i64, b: i64) -> i64 {
    let a_lo = a as u32;
    let a_hi = ((a as u64) >> 32) as u32;
    let b_lo = b as u32;
    let b_hi = ((b as u64) >> 32) as u32;

    // Subtract low parts with borrow detection
    let (lo, borrow1) = a_lo.overflowing_sub(b_lo);

    // Subtract high parts with borrow from low subtraction
    let (hi, borrow2) = a_hi.overflowing_sub(b_hi);
    let hi = hi.wrapping_sub(borrow1 as u32);

    u32x2_to_i64(lo, hi)
}

/// Emulate i64 left shift
pub fn emulated_i64_shl(value: i64, shift: u32) -> i64 {
    if shift >= 64 {
        return 0;
    }
    (value as u64).wrapping_shl(shift) as i64
}

/// Emulate i64 right shift (arithmetic/sign-preserving)
pub fn emulated_i64_shr(value: i64, shift: u32) -> i64 {
    if shift >= 64 {
        return if value >= 0 { 0 } else { -1 };
    }
    value.wrapping_shr(shift)
}

/// Emulate i64 comparison: less than
pub fn emulated_i64_lt(a: i64, b: i64) -> bool {
    a < b
}

/// Emulate i64 comparison: greater than or equal
pub fn emulated_i64_ge(a: i64, b: i64) -> bool {
    a >= b
}

/// Emulate i64 comparison: equality
pub fn emulated_i64_eq(a: i64, b: i64) -> bool {
    a == b
}

/// Generate WGSL code for i64 emulation
pub fn generate_i64_emulation_wgsl() -> String {
    r#"
// i64 Emulation Helper Functions for WGSL
// Represents i64 as vec2<u32> where x is low 32 bits and y is high 32 bits

// Convert i64 (vec2<u32>) to actual value for operations that don't support it
fn i64_add_emulated(a: vec2<u32>, b: vec2<u32>) -> vec2<u32> {
    let lo = a.x + b.x;
    let carry = select(0u, 1u, lo < a.x); // Detect overflow from low addition
    let hi = a.y + b.y + carry;
    return vec2<u32>(lo, hi);
}

fn i64_sub_emulated(a: vec2<u32>, b: vec2<u32>) -> vec2<u32> {
    let lo = a.x - b.x;
    let borrow = select(0u, 1u, a.x < b.x); // Detect borrow from low subtraction
    let hi = a.y - b.y - borrow;
    return vec2<u32>(lo, hi);
}

fn i64_lt_emulated(a: vec2<u32>, b: vec2<u32>) -> bool {
    // For signed comparison, check sign bit first
    let a_negative = (a.y & 0x80000000u) != 0u;
    let b_negative = (b.y & 0x80000000u) != 0u;

    if (a_negative != b_negative) {
        return a_negative; // Negative is less than positive
    }

    if (a.y != b.y) {
        return a.y < b.y;
    }
    return a.x < b.x;
}

fn i64_eq_emulated(a: vec2<u32>, b: vec2<u32>) -> bool {
    return a.x == b.x && a.y == b.y;
}

// Convert emulated i64 to float for display purposes
fn i64_to_f32_emulated(value: vec2<u32>) -> f32 {
    let sign = f32((value.y & 0x80000000u) != 0u);
    let abs_hi = value.y & 0x7FFFFFFFu;
    let abs_lo = value.x;

    // This is approximate - for precise conversion, need more complex logic
    let high_part = f32(abs_hi) * 4294967296.0; // 2^32
    let low_part = f32(abs_lo);
    let magnitude = high_part + low_part;

    return select(magnitude, -magnitude, sign != 0.0);
}
"#.to_string()
}
```

**Step 4: Run test to verify it passes**

Run: `cd geometry_os/geometry-os-phase44/systems/infinite_map_rs && cargo test i64_emulation`
Expected: PASS

**Step 5: Add module to main**

```rust
// main.rs - add with other modules
pub mod i64_emulation;
```

**Step 6: Commit**

```bash
git add geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/i64_emulation.rs
git add geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/main.rs
git commit -m "feat: add i64 emulation utilities for GPU compatibility"
```

---

## Task 3: Update RISC-V VM Shader with i64 Fallback

**Files:**
- Read: `geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/shaders/riscv_executor.wgsl`
- Modify: `geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/shaders/riscv_executor.wgsl` (add conditional i64 support)

**Step 1: Read the current shader**

Run: Read the file to understand current i64 usage

**Step 2: Create fallback shader version**

Create: `geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/shaders/riscv_executor_emulated.wgsl`

**Step 3: Implement shader loading with strategy selection**

Modify: `geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/riscv_executor.rs`

```rust
// Add to riscv_executor.rs
use crate::gpu_capabilities::{GpuCapabilities, I64Strategy};
use crate::i64_emulation::generate_i64_emulation_wgsl;

pub struct RiscvExecutor {
    // ... existing fields
    i64_strategy: I64Strategy,
}

impl RiscvExecutor {
    pub async fn new(device: &wgpu::Device, queue: &wgpu::Queue, caps: &GpuCapabilities) -> Self {
        let i64_strategy = caps.get_i64_strategy();

        let shader_source = match i64_strategy {
            I64Strategy::Native => {
                include_str!("shaders/riscv_executor.wgsl").to_string()
            }
            I64Strategy::Emulate => {
                let mut shader = generate_i64_emulation_wgsl();
                shader.push_str("\n// Original shader with i64 replaced\n");
                // Load and transform the shader
                let original = include_str!("shaders/riscv_executor.wgsl");
                shader.push_str(&Self::transform_i64_to_emulated(original));
                shader
            }
        };

        // ... rest of initialization
    }

    fn transform_i64_to_emulated(shader: &str) -> String {
        // Replace i64 types and operations with emulated versions
        let mut result = shader.to_string();

        // Replace array<i64, N> with array<vec2<u32>, N>
        result = regex::Regex::new(r"array<i64,(\s*\d+)>")
            .unwrap()
            .replace_all(&result, "array<vec2<u32>,$1>")
            .to_string();

        // Replace var<storage,> declarations
        result = regex::Regex::new(r":\s*array<i64>")
            .unwrap()
            .replace_all(&result, ": array<vec2<u32>>")
            .to_string();

        // Replace function parameters and return types
        // This is simplified - full implementation needs more sophisticated parsing

        result
    }
}
```

**Step 4: Write integration test**

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;

    #[tokio::test]
    async fn test_riscv_executor_with_emulated_i64() {
        let instance = wgpu::Instance::default();
        let adapter = instance
            .request_adapter(&wgpu::RequestAdapterOptions::default())
            .await
            .expect("Failed to find adapter");

        let (device, queue) = adapter
            .request_device(
                &wgpu::DeviceDescriptor::default(),
                None,
            )
            .await
            .expect("Failed to create device");

        let caps = GpuCapabilities::new(&adapter).await;

        // Should work regardless of i64 support
        let executor = RiscvExecutor::new(&device, &queue, &caps).await;

        // Verify executor was created successfully
        assert_eq!(executor.i64_strategy(), caps.get_i64_strategy());
    }
}
```

**Step 5: Run test**

Run: `cargo test test_riscv_executor_with_emulated_i64 -- --nocapture`

**Step 6: Commit**

```bash
git add geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/shaders/riscv_executor_emulated.wgsl
git add geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/riscv_executor.rs
git commit -m "feat: add i64 emulation fallback for RISC-V VM shader"
```

---

## Task 4: Add Runtime Capability Query API

**Files:**
- Modify: `geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/app.rs`

**Step 1: Add capability query method**

```rust
// Add to app.rs
impl App {
    pub fn gpu_capabilities(&self) -> &GpuCapabilities {
        &self.gpu_caps
    }

    pub fn log_gpu_info(&self) {
        log::info!("GPU: {} {}", self.gpu_caps.vendor_name, self.gpu_caps.device_name);
        log::info!("i64 Strategy: {:?}", self.gpu_caps.get_i64_strategy());
    }
}
```

**Step 2: Display on startup**

Modify main.rs startup sequence to log GPU capabilities

**Step 3: Commit**

```bash
git add geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/app.rs
git add geometry_os/geometry-os-phase44/systems/infinite_map_rs/src/main.rs
git commit -m "feat: add GPU capability info logging on startup"
```

---

## Task 5: Documentation

**Files:**
- Create: `geometry_os/docs/gpu-compatibility.md`

**Step 1: Create documentation**

```markdown
# GPU Compatibility Notes

## i64 Support

Geometry OS uses i64 operations in the RISC-V VM shaders. Not all GPUs support native i64 operations in WebGPU.

### Supported GPUs

**Native i64 Support:**
- NVIDIA: RTX 30-series and newer
- AMD: RX 6000-series and newer
- Intel: Arc A-series and newer

**Emulation Required:**
- Older GPUs
- Some integrated GPUs
- Software renderers

### How It Works

When i64 is not natively supported:
1. GPU capability detection runs at startup
2. Shaders are automatically transformed to use i32 pairs
3. Operations are emulated in WGSL

### Performance Impact

Native i64: ~100% performance
Emulated i64: ~40-60% performance (depends on operation mix)

### Troubleshooting

If you see "i64 Strategy: Emulate" and have a modern GPU:
- Update graphics drivers
- Check WebGPU enable flags in your browser
```

**Step 2: Commit**

```bash
git add geometry_os/docs/gpu-compatibility.md
git commit -m "docs: add GPU compatibility documentation"
```

---

## Verification Steps

After completing all tasks:

1. **Test on hardware with native i64:**
   ```bash
   cargo run --bin infinite_map_rs
   ```
   Should log: "i64 Strategy: Native"

2. **Test with forced emulation:**
   Add environment variable to force emulation mode and verify shaders still compile

3. **Run full test suite:**
   ```bash
   cargo test
   ```

---

**Total Estimated Time:** 30-45 minutes

**Dependencies:** None (all Phase 1 tasks can be done in parallel)
