---
phase: 19-memory-management-unit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
autonomous: true
user_setup: []

must_haves:
  truths:
    - "TLB caches successful page table translations"
    - "TLB lookup happens before page table walk"
    - "TLB flush clears all cached entries"
    - "Translation performance improves for repeated accesses"
  artifacts:
    - path: "systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl"
      provides: "TLB caching for Sv32 address translation"
      contains: "tlb_lookup"
  key_links:
    - from: "translate_address()"
      to: "TLB arrays"
      via: "tlb_lookup() before walk"
      pattern: "tlb_lookup.*vaddr"
---

<objective>
Add TLB (Translation Lookaside Buffer) caching to the existing Sv32 page table walker to improve memory access performance for repeated virtual address translations.

Purpose: Linux makes many repeated memory accesses to the same pages; TLB caching avoids redundant page table walks.
Output: TLB-enhanced translate_address() function with 16-entry direct-mapped cache.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-memory-management-unit/19-RESEARCH.md
@systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TLB data structures to shader</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
    Add TLB data structures after the existing CSR constants section (around line 100).

    Add these constants and arrays:

    ```wgsl
    // --- TLB (Translation Lookaside Buffer) ---
    const TLB_ENTRIES: u32 = 16u;

    // Per-thread TLB arrays (private to avoid synchronization)
    var<private> tlb_tags: array<u32, TLB_ENTRIES>;    // VPN (virtual page number)
    var<private> tlb_paddrs: array<u32, TLB_ENTRIES>;  // Physical page number
    var<private> tlb_flags: array<u32, TLB_ENTRIES>;   // Bit 0: valid, Bits 1-3: R/W/X perms
    ```

    IMPORTANT: Use `var<private>` for per-thread storage. Do NOT use workgroup-shared storage as it requires synchronization which WGSL compute shaders don't handle well for this use case.
  </action>
  <verify>grep -n "TLB_ENTRIES" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</verify>
  <done>TLB constants and arrays defined in shader</done>
</task>

<task type="auto">
  <name>Task 2: Implement TLB lookup function</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
    Add TLB helper functions BEFORE the existing translate_address() function (around line 365).

    Implement these functions:

    ```wgsl
    // TLB Lookup: Returns translated physical address or 0xFFFFFFFF on miss
    fn tlb_lookup(vaddr: u32, access_type: u32) -> u32 {
        let vpn = vaddr >> 12u;
        let idx = vpn % TLB_ENTRIES;
        let offset = vaddr & 0xFFFu;

        // Check for TLB hit
        if (tlb_tags[idx] == vpn && (tlb_flags[idx] & 1u) != 0u) {
            // Validate permissions
            let perms = (tlb_flags[idx] >> 1u) & 0x7u;
            let pte_r = perms & 1u;
            let pte_w = (perms >> 1u) & 1u;
            let pte_x = (perms >> 2u) & 1u;

            if (access_type == ACCESS_READ && pte_r == 0u) { return 0xFFFFFFFFu; }
            if (access_type == ACCESS_WRITE && pte_w == 0u) { return 0xFFFFFFFFu; }
            if (access_type == ACCESS_EXEC && pte_x == 0u) { return 0xFFFFFFFFu; }

            // TLB hit - return translated address
            return (tlb_paddrs[idx] << 12u) | offset;
        }
        return 0xFFFFFFFFu;  // TLB miss
    }

    // TLB Fill: Cache a successful translation
    fn tlb_fill(vaddr: u32, paddr: u32, pte: u32) {
        let vpn = vaddr >> 12u;
        let idx = vpn % TLB_ENTRIES;

        tlb_tags[idx] = vpn;
        tlb_paddrs[idx] = paddr >> 12u;

        // Extract and store permissions (XWR bits 3:1)
        let perms = (pte >> 1u) & 0x7u;
        tlb_flags[idx] = (perms << 1u) | 1u;  // Set valid bit
    }

    // TLB Flush: Clear all entries
    fn tlb_flush() {
        for (var i = 0u; i < TLB_ENTRIES; i = i + 1u) {
            tlb_flags[i] = 0u;  // Clear valid bit
        }
    }
    ```

    Do NOT change translate_address() yet - that's Task 3.
  </action>
  <verify>grep -n "fn tlb_lookup" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</verify>
  <done>TLB lookup, fill, and flush functions implemented</done>
</task>

<task type="auto">
  <name>Task 3: Integrate TLB with translate_address()</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
    Modify the existing translate_address() function to use TLB caching.

    Replace the current function with this enhanced version:

    ```wgsl
    fn translate_address(vaddr: u32, access_type: u32, base_idx: u32) -> u32 {
        let satp = cpu_states[base_idx + CSR_SATP];
        let satp_mode = (satp >> 31u) & 1u;

        // Bare mode - no translation, no TLB
        if (satp_mode == 0u) {
            return vaddr;
        }

        // Try TLB lookup first
        let tlb_result = tlb_lookup(vaddr, access_type);
        if (tlb_result != 0xFFFFFFFFu) {
            return tlb_result;  // TLB hit
        }

        // TLB miss - perform full page table walk
        let vpn1 = (vaddr >> 22u) & 0x3FFu;
        let vpn0 = (vaddr >> 12u) & 0x3FFu;
        let offset = vaddr & 0xFFFu;

        let ppn_root = satp & 0x3FFFFFu;
        let pte1_addr = (ppn_root * 4096u) + (vpn1 * 4u);
        if (pte1_addr >= 134217728u) { return 0xFFFFFFFFu; }

        var pte1 = system_memory[pte1_addr / 4u];
        let pte1_v = pte1 & 1u;
        if (pte1_v == 0u) { return 0xFFFFFFFFu; }

        let pte1_xwr = (pte1 >> 1u) & 0x7u;
        var paddr: u32 = 0u;

        if (pte1_xwr != 0u) {
            // Leaf PTE at level 1 (MegaPage)
            let ppn1 = (pte1 >> 10u) & 0xFFFFFu;
            paddr = (ppn1 << 22u) | (vpn0 << 12u) | offset;

            // Set A/D bits
            pte1 = pte1 | 0x40u;
            if (access_type == ACCESS_WRITE) { pte1 = pte1 | 0x80u; }
            system_memory[pte1_addr / 4u] = pte1;

            // Cache MegaPage translation (use vpn1 as tag for 4MB pages)
            let mega_vpn = (vaddr >> 22u) << 10u;  // Mask vpn0
            tlb_fill(mega_vpn << 12u, paddr & 0xFFC00000u, pte1);
        } else {
            // Walk to level 0
            let ppn1_from_pte1 = (pte1 >> 10u) & 0x3FFFFFu;
            let pte0_addr = (ppn1_from_pte1 * 4096u) + (vpn0 * 4u);
            if (pte0_addr >= 134217728u) { return 0xFFFFFFFFu; }

            var pte0 = system_memory[pte0_addr / 4u];
            if ((pte0 & 1u) == 0u) { return 0xFFFFFFFFu; }

            // Permission checks
            let pte_r = (pte0 >> 1u) & 1u;
            let pte_w = (pte0 >> 2u) & 1u;
            let pte_x = (pte0 >> 3u) & 1u;

            if (access_type == ACCESS_READ && pte_r == 0u) { return 0xFFFFFFFFu; }
            if (access_type == ACCESS_WRITE && pte_w == 0u) { return 0xFFFFFFFFu; }
            if (access_type == ACCESS_EXEC && pte_x == 0u) { return 0xFFFFFFFFu; }

            let ppn0 = (pte0 >> 10u) & 0xFFFFFu;
            paddr = (ppn0 << 12u) | offset;

            // Set A/D bits
            pte0 = pte0 | 0x40u;
            if (access_type == ACCESS_WRITE) { pte0 = pte0 | 0x80u; }
            system_memory[pte0_addr / 4u] = pte0;

            // Cache 4KB page translation
            tlb_fill(vaddr, paddr, pte0);
        }

        // Tectonic Bounds Check
        let g_base = cpu_states[base_idx + CSR_GUEST_BASE];
        let g_size = cpu_states[base_idx + CSR_GUEST_SIZE];
        if (g_size > 0u) {
            if (paddr < g_base || paddr >= (g_base + g_size)) { return 0xFFFFFFFFu; }
        }

        return paddr;
    }
    ```

    Key changes from original:
    1. Early TLB lookup before page table walk
    2. tlb_fill() call after successful translation
    3. Preserve all existing functionality (MegaPage, A/D bits, bounds check)
  </action>
  <verify>grep -n "tlb_lookup" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl | head -5</verify>
  <done>translate_address() uses TLB for caching translations</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Open systems/visual_shell/web/tests/test_privileged.html in browser
2. Verify existing privileged tests still pass (no regression)
3. Manual check: Shader compiles without errors
</verification>

<success_criteria>
- TLB constants and arrays defined in shader
- tlb_lookup(), tlb_fill(), tlb_flush() functions implemented
- translate_address() uses TLB before page table walk
- Shader compiles successfully
- Existing privileged tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/19-memory-management-unit/19-01-SUMMARY.md`
</output>
