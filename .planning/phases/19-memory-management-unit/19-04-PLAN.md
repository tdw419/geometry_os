---
phase: 19-memory-management-unit
plan: 04
type: execute
wave: 4
depends_on: [19-01, 19-02, 19-03]
files_modified:
  - systems/visual_shell/web/demo_mmu.html
  - systems/visual_shell/web/RiscvExecutionPanel.js
autonomous: false
user_setup: []

must_haves:
  truths:
    - "User can see MMU enable/disable status in visual shell"
    - "User can see page fault count indicator"
    - "User can run a demo that shows MMU in action"
  artifacts:
    - path: "systems/visual_shell/web/demo_mmu.html"
      provides: "Interactive MMU demo page"
    - path: "systems/visual_shell/web/RiscvExecutionPanel.js"
      provides: "MMU status display in execution panel"
  key_links:
    - from: "RiscvExecutionPanel.js"
      to: "CSR_SATP"
      via: "satp read for mode display"
      pattern: "CSR_SATP.*mode"
---

<objective>
Add visual integration for MMU functionality: MMU status indicator in the execution panel and a demo page showing MMU operation.

Purpose: Users need visual feedback to verify MMU is working and see virtual memory status.
Output: MMU status display in RiscvExecutionPanel and demo_mmu.html demo page.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-memory-management-unit/19-RESEARCH.md
@.planning/phases/18-privileged-architecture/18-05-SUMMARY.md
@systems/visual_shell/web/RiscvExecutionPanel.js
@systems/visual_shell/web/demo_privileged.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MMU status display to RiscvExecutionPanel</name>
  <files>systems/visual_shell/web/RiscvExecutionPanel.js</files>
  <action>
    Add MMU status display to the execution panel, showing whether MMU is enabled (Sv32) or disabled (bare mode).

    Find the existing status display section (after privilege mode indicator) and add:

    1. In the HTML template (constructor), add MMU status element:

    ```javascript
    // After privilege mode badge
    this.mmuStatus = document.createElement('span');
    this.mmuStatus.style.cssText = 'padding: 2px 8px; border-radius: 3px; font-size: 12px; margin-left: 8px;';
    this.mmuStatus.textContent = 'MMU: OFF';
    this.mmuStatus.style.background = '#666';
    statusDiv.appendChild(this.mmuStatus);
    ```

    2. In the updateState() method, read satp CSR and update display:

    ```javascript
    // Read satp CSR (index 34) to determine MMU mode
    const satp = this.stateData[34] || 0;
    const satpMode = (satp >> 31) & 1;

    if (satpMode === 1) {
        // Sv32 mode enabled
        const ppn = satp & 0x3FFFFF;
        this.mmuStatus.textContent = `MMU: Sv32 (PT@0x${(ppn << 12).toString(16).toUpperCase()})`;
        this.mmuStatus.style.background = '#00aa44';  // Green
    } else {
        // Bare mode (MMU off)
        this.mmuStatus.textContent = 'MMU: OFF';
        this.mmuStatus.style.background = '#666';  // Gray
    }
    ```

    The CSR_SATP index (34) is already defined in the shader constants.
  </action>
  <verify>grep -n "MMU:\|satpMode\|CSR_SATP" systems/visual_shell/web/RiscvExecutionPanel.js</verify>
  <done>MMU status indicator added to execution panel</done>
</task>

<task type="auto">
  <name>Task 2: Create demo_mmu.html demo page</name>
  <files>systems/visual_shell/web/demo_mmu.html</files>
  <action>
    Create a demo page that shows MMU functionality, following the pattern of demo_privileged.html.

    The demo should:
    1. Show how to enable MMU with satp
    2. Demonstrate identity-mapped memory access
    3. Show page fault on unmapped address
    4. Show TLB flush with SFENCE.VMA

    ```html
    <!DOCTYPE html>
    <html>
    <head>
        <title>Geometry OS - MMU Demo</title>
        <style>
            body { font-family: monospace; padding: 20px; background: #1a1a2e; color: #eee; }
            h1 { color: #00ff88; }
            .panel { background: #16213e; padding: 15px; border-radius: 5px; margin: 10px 0; }
            .code { background: #0f3460; padding: 10px; border-radius: 3px; overflow-x: auto; }
            button { padding: 10px 20px; margin: 5px; cursor: pointer; background: #00ff88; color: #1a1a2e; border: none; border-radius: 5px; }
            button:hover { background: #00cc6a; }
            #output { background: #0a0a15; padding: 10px; min-height: 200px; white-space: pre-wrap; }
            .status { display: inline-block; padding: 2px 8px; border-radius: 3px; margin: 0 5px; }
        </style>
    </head>
    <body>
        <h1>Phase 19: Memory Management Unit Demo</h1>
        <p>Demonstration of Sv32 virtual memory, page table walks, and TLB caching.</p>

        <div class="panel">
            <h3>Demos:</h3>
            <button onclick="runDemo('bare')">1. Bare Mode (MMU Off)</button>
            <button onclick="runDemo('identity')">2. Identity Map</button>
            <button onclick="runDemo('pagefault')">3. Page Fault</button>
            <button onclick="runDemo('sfence')">4. SFENCE.VMA</button>
            <button onclick="runDemo('full')">5. Full MMU Test</button>
        </div>

        <div class="panel">
            <h3>Status:</h3>
            <span id="mode" class="status" style="background:#ff8800">M-Mode</span>
            <span id="mmu" class="status" style="background:#666">MMU: OFF</span>
        </div>

        <div class="panel">
            <h3>Console Output:</h3>
            <div id="output"></div>
        </div>

        <script type="module">
            import { PrivilegedTestEncoder } from './tests/test_privileged.js';
            import { CoreExecutionVerifier } from './CoreExecutionVerifier.js';

            const CSR_SATP = 0x180;
            const CSR_MTVEC = 0x305;
            const CSR_MCAUSE = 0x342;

            let device, queue, verifier;

            async function initGPU() {
                if (!navigator.gpu) throw new Error('WebGPU not supported');
                const adapter = await navigator.gpu.requestAdapter();
                device = await adapter.requestDevice();
                queue = device.queue;
                verifier = new CoreExecutionVerifier(device);
            }

            function log(msg) {
                document.getElementById('output').textContent += msg + '\n';
            }

            function clearLog() {
                document.getElementById('output').textContent = '';
            }

            function updateStatus(mode, mmuOn) {
                const modeEl = document.getElementById('mode');
                const mmuEl = document.getElementById('mmu');

                modeEl.textContent = mode === 3 ? 'M-Mode' : mode === 1 ? 'S-Mode' : 'U-Mode';
                modeEl.style.background = mode === 3 ? '#ff8800' : mode === 1 ? '#4488ff' : '#888';

                mmuEl.textContent = mmuOn ? 'MMU: Sv32' : 'MMU: OFF';
                mmuEl.style.background = mmuOn ? '#00aa44' : '#666';
            }

            async function runDemo(name) {
                clearLog();
                if (!device) await initGPU();

                log(`Running demo: ${name}`);
                log('---');

                switch (name) {
                    case 'bare':
                        await demoBareMode();
                        break;
                    case 'identity':
                        await demoIdentityMap();
                        break;
                    case 'pagefault':
                        await demoPageFault();
                        break;
                    case 'sfence':
                        await demoSFENCE();
                        break;
                    case 'full':
                        await demoFull();
                        break;
                }
            }

            async function demoBareMode() {
                log('Demo: Bare Mode (MMU disabled)');
                log('Virtual addresses = Physical addresses');
                log('');

                const e = new PrivilegedTestEncoder();
                // Don't enable MMU, just access memory directly
                e.addi(1, 0, 0x42);
                e.lui(2, 0x00001);  // x2 = 0x1000
                e.sw(1, 2, 0);      // mem[0x1000] = 0x42
                e.lw(3, 2, 0);      // x3 = mem[0x1000]
                e.jal(0, 0);

                const state = await executeDemo(e.finalize());
                log(`Wrote 0x42 to PA 0x1000`);
                log(`Read back: x3 = 0x${state.registers[3]?.toString(16)}`);
                log(`Result: ${state.registers[3] === 0x42 ? 'PASS' : 'FAIL'}`);
                updateStatus(3, false);
            }

            async function demoIdentityMap() {
                log('Demo: Identity Map with MMU enabled');
                log('VA 0x00000000 -> PA 0x00000000 (identity)');
                log('');

                const e = new PrivilegedTestEncoder();
                const rootPA = 0x03000000;
                const satp = (1 << 31) | (rootPA >> 12);

                e.lui(1, satp >> 12);
                e.csrrw(0, 1, CSR_SATP);  // Enable MMU
                e.addi(2, 0, 0x42);
                e.lui(3, 0x00001);
                e.sw(2, 3, 0);  // VA 0x1000
                e.lw(4, 3, 0);
                e.jal(0, 0);

                const state = await executeDemo(e.finalize(), { identityMap: true });
                log(`Enabled Sv32 MMU with page table at 0x${rootPA.toString(16)}`);
                log(`Wrote 0x42 to VA 0x1000`);
                log(`Read back: x4 = 0x${state.registers[4]?.toString(16)}`);
                log(`Result: ${state.registers[4] === 0x42 ? 'PASS' : 'FAIL'}`);
                updateStatus(3, true);
            }

            async function demoPageFault() {
                log('Demo: Page Fault on unmapped address');
                log('Accessing VA 0x80000000 should fault');
                log('');

                const e = new PrivilegedTestEncoder();
                const rootPA = 0x03000000;
                const satp = (1 << 31) | (rootPA >> 12);

                // Set trap handler
                e.lui(1, 0x200);
                e.csrrw(0, 1, CSR_MTVEC);

                // Enable MMU
                e.lui(1, satp >> 12);
                e.csrrw(0, 1, CSR_SATP);

                // Access unmapped address
                e.lui(2, 0x80000);  // x2 = 0x80000000
                e.lw(3, 2, 0);      // Should fault!
                e.addi(4, 0, 0x99); // Should not execute

                // Handler at 0x200
                while (e.code.length < 0x80) e.code.push(0);
                e.csrrs(5, 0, CSR_MCAUSE);
                e.addi(4, 0, 0x42);
                e.jal(0, 0);

                const state = await executeDemo(e.finalize(), { identityMap: true });
                log(`Trap handler reached!`);
                log(`mcause = ${state.registers[5]} (13 = Load Page Fault)`);
                log(`x4 = ${state.registers[4]} (should be 66 = 0x42)`);
                log(`Result: ${state.registers[5] === 13 && state.registers[4] === 66 ? 'PASS' : 'FAIL'}`);
                updateStatus(3, true);
            }

            async function demoSFENCE() {
                log('Demo: SFENCE.VMA TLB Flush');
                log('');

                const e = new PrivilegedTestEncoder();
                const rootPA = 0x03000000;
                const satp = (1 << 31) | (rootPA >> 12);

                e.lui(1, satp >> 12);
                e.csrrw(0, 1, CSR_SATP);

                e.lui(2, 0x00001);
                e.addi(3, 0, 0x42);
                e.sw(3, 2, 0);

                e.sfence_vma();  // Flush TLB

                e.lw(4, 2, 0);  // Should still work
                e.jal(0, 0);

                const state = await executeDemo(e.finalize(), { identityMap: true });
                log(`Accessed memory, flushed TLB with SFENCE.VMA`);
                log(`Re-accessed: x4 = 0x${state.registers[4]?.toString(16)}`);
                log(`Result: ${state.registers[4] === 0x42 ? 'PASS' : 'FAIL'}`);
                updateStatus(3, true);
            }

            async function demoFull() {
                log('Running all MMU demos...\n');
                await demoBareMode();
                log('\n---\n');
                await demoIdentityMap();
                log('\n---\n');
                await demoPageFault();
                log('\n---\n');
                await demoSFENCE();
                log('\n---\nAll demos complete!');
            }

            async function executeDemo(code, options = {}) {
                const { identityMap = false, memorySize = 4 * 1024 * 1024 } = options;
                const actualSize = Math.max(memorySize, 0x04000000);
                const { codeBuffer, memoryBuffer, stateBuffer } = verifier.createTestBuffers(code, actualSize);

                try {
                    if (identityMap) {
                        const rootPA = 0x03000000;
                        const pteData = new Uint32Array(4);
                        for (let i = 0; i < 4; i++) {
                            pteData[i] = (i << 10) | 0x0F;
                        }
                        device.queue.writeBuffer(memoryBuffer, rootPA / 4, pteData);
                    }

                    const shaderModule = device.createShaderModule({
                        label: 'mmu-demo',
                        code: await fetch('./shaders/visual_cpu_riscv.wgsl').then(r => r.text())
                    });

                    const bindGroupLayout = device.createBindGroupLayout({
                        entries: [
                            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                            { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                            { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }
                        ]
                    });

                    const pipeline = device.createComputePipeline({
                        layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                        compute: { module: shaderModule, entryPoint: 'main' }
                    });

                    const bindGroup = device.createBindGroup({
                        layout: bindGroupLayout,
                        entries: [
                            { binding: 0, resource: { buffer: codeBuffer } },
                            { binding: 1, resource: { buffer: memoryBuffer } },
                            { binding: 2, resource: { buffer: stateBuffer } }
                        ]
                    });

                    const encoder = device.createCommandEncoder();
                    const pass = encoder.beginComputePass();
                    pass.setPipeline(pipeline);
                    pass.setBindGroup(0, bindGroup);
                    pass.dispatchWorkgroups(1);
                    pass.end();
                    queue.submit([encoder.finish()]);

                    return await verifier.readState(stateBuffer);
                } finally {
                    codeBuffer.destroy();
                    memoryBuffer.destroy();
                    stateBuffer.destroy();
                }
            }

            window.runDemo = runDemo;
        </script>
    </body>
    </html>
    ```
  </action>
  <verify>ls -la systems/visual_shell/web/demo_mmu.html</verify>
  <done>demo_mmu.html demo page created</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    MMU visual integration:
    1. MMU status indicator in RiscvExecutionPanel (shows Sv32/OFF)
    2. demo_mmu.html page with 5 interactive demos
  </what-built>
  <how-to-verify>
    1. Open systems/visual_shell/web/demo_mmu.html in browser
    2. Click "1. Bare Mode" - should show PASS
    3. Click "2. Identity Map" - should show PASS and MMU: Sv32 status
    4. Click "3. Page Fault" - should show PASS with trap handler reached
    5. Click "4. SFENCE.VMA" - should show PASS
    6. Click "5. Full MMU Test" - all demos should run
    7. Verify MMU status badge changes color (gray=off, green=Sv32)
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
Visual verification in browser:
1. demo_mmu.html loads without errors
2. All 5 demo buttons work
3. MMU status indicator updates correctly
4. Page fault demo shows trap handler reached
5. Console output shows expected results
</verification>

<success_criteria>
- MMU status indicator visible in RiscvExecutionPanel
- demo_mmu.html with 5 working demos
- Status badge changes based on satp mode
- All demos show PASS when run
</success_criteria>

<output>
After completion, create `.planning/phases/19-memory-management-unit/19-04-SUMMARY.md`
</output>
