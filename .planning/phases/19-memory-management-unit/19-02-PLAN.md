---
phase: 19-memory-management-unit
plan: 02
type: execute
wave: 2
depends_on: [19-01]
files_modified:
  - systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
autonomous: true
user_setup: []

must_haves:
  truths:
    - "SFENCE.VMA instruction flushes TLB"
    - "Linux can invalidate TLB entries after page table changes"
    - "satp write triggers TLB flush for simplicity"
  artifacts:
    - path: "systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl"
      provides: "SFENCE.VMA instruction support"
      contains: "SFENCE.VMA"
  key_links:
    - from: "opcode 0x73 handler"
      to: "tlb_flush()"
      via: "SFENCE.VMA decode"
      pattern: "0x12000073"
---

<objective>
Add SFENCE.VMA instruction support to enable TLB invalidation, which Linux requires after modifying page tables.

Purpose: Linux kernel uses SFENCE.VMA to synchronize TLB after page table updates; without it, Linux may see stale translations.
Output: Working SFENCE.VMA instruction that flushes TLB entries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-memory-management-unit/19-RESEARCH.md
@.planning/phases/19-memory-management-unit/19-01-PLAN.md
@systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SFENCE.VMA instruction handler</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
    Add SFENCE.VMA instruction decoding in the opcode 0x73 (SYSTEM) handler.

    SFENCE.VMA encoding:
    - opcode: 0x73
    - funct3: 0
    - funct12: 0x00000012 (0x12 in bits 31:20)
    - Full encoding: 0x00012073

    Find the opcode 0x73 handler section (around line 700) and add this case after the MRET/SRET handling:

    ```wgsl
    // SFENCE.VMA - TLB flush
    // Encoding: imm[31:20]=0x12, funct3=0, rd=0, opcode=0x73
    // Full: 0x00012073
    if (funct12_sys == 0x12u) {
        tlb_flush();
        // SFENCE.VMA is a fence, no register write needed
        // Just continue to next instruction
    }
    ```

    The funct12_sys variable should already be extracted in the SYSTEM opcode handler:
    ```wgsl
    let funct12_sys = (inst >> 20u) & 0xFFFu;
    ```

    Add this BEFORE the else clause that handles unknown SYSTEM instructions.
  </action>
  <verify>grep -n "SFENCE" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</verify>
  <done>SFENCE.VMA instruction decodes and calls tlb_flush()</done>
</task>

<task type="auto">
  <name>Task 2: Add TLB flush on satp write</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
    Ensure TLB is flushed when satp CSR is written. This is a simplification (full ASID support would be more complex).

    Find the CSR write handling in the CSRRW/CSRRS/CSRRC instruction handlers (around line 750).

    In the CSR write path, add a check for satp writes:

    ```wgsl
    // After CSR value is written via CSRRW/CSRRS/CSRRC
    // Check if this was a satp write and flush TLB
    if (csr_num == 0x180u) {  // satp CSR
        tlb_flush();
    }
    ```

    This should be added after the write to cpu_states[base_idx + csr_idx] but before the instruction completes.

    Alternatively, if the CSR write is centralized in a helper function, add the check there.
  </action>
  <verify>grep -n "0x180u.*tlb_flush\|tlb_flush.*0x180u\|satp.*tlb_flush" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</verify>
  <done>TLB flushed on satp CSR write</done>
</task>

<task type="auto">
  <name>Task 3: Add SFENCE.VMA constant</name>
  <files>systems/visual_shell/web/tests/test_privileged.js</files>
  <action>
    Add SFENCE.VMA encoding constant to the PrivilegedTestEncoder class for testing.

    Add this static method to the PrivilegedTestEncoder class (around line 220):

    ```javascript
    /**
     * SFENCE.VMA - TLB Flush
     * Encoding: 0x00012073
     */
    static SFENCE_VMA() {
        return 0x00012073;
    }

    /**
     * Emit SFENCE.VMA instruction
     */
    sfence_vma() {
        this.code.push(0x00012073 >>> 0);
        this.pc += 4;
    }
    ```

    Also add to the window exports at the bottom of the file if present.
  </action>
  <verify>grep -n "SFENCE_VMA\|sfence_vma" systems/visual_shell/web/tests/test_privileged.js</verify>
  <done>SFENCE.VMA encoder methods added to test utility</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Verify shader compiles without errors
2. Verify existing privileged tests still pass
3. Manual test: Create a simple test that sets satp, writes to memory, then SFENCE.VMA, verify no crash
</verification>

<success_criteria>
- SFENCE.VMA instruction (0x00012073) decodes correctly
- SFENCE.VMA calls tlb_flush()
- TLB flushed on satp write
- PrivilegedTestEncoder has sfence_vma() method
- Shader compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/19-memory-management-unit/19-02-SUMMARY.md`
</output>
