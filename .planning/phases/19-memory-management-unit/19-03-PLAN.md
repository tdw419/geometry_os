---
phase: 19-memory-management-unit
plan: 03
type: tdd
wave: 3
depends_on: [19-01, 19-02]
files_modified:
  - systems/visual_shell/web/tests/test_mmu.js
  - systems/visual_shell/web/tests/test_mmu.html
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can enable MMU via satp and see addresses translated"
    - "Page table walks succeed for valid mappings"
    - "Page faults trigger for unmapped memory"
    - "TLB improves performance for repeated accesses"
  artifacts:
    - path: "systems/visual_shell/web/tests/test_mmu.js"
      provides: "Comprehensive MMU test suite"
      exports: ["testMMUBasicTranslation", "testMMUPageFault", "testTLBFunctionality"]
    - path: "systems/visual_shell/web/tests/test_mmu.html"
      provides: "Test runner for MMU tests"
  key_links:
    - from: "test_mmu.js"
      to: "test_privileged.js"
      via: "PrivilegedTestEncoder import"
      pattern: "PrivilegedTestEncoder"
---

<objective>
Create comprehensive test suite for MMU functionality using TDD approach. Tests verify Sv32 translation, page faults, and TLB caching.

Purpose: Verify MMU implementation is correct before Linux boot attempts.
Output: Working test suite that validates all MMU requirements.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-memory-management-unit/19-RESEARCH.md
@systems/visual_shell/web/tests/test_privileged.js
@systems/visual_shell/web/tests/test_mmu_translation.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_mmu.js with basic translation tests</name>
  <files>systems/visual_shell/web/tests/test_mmu.js</files>
  <action>
    Create a new comprehensive MMU test file that extends the existing test_mmu_translation.js patterns.

    The file should:

    1. Import PrivilegedTestEncoder from test_privileged.js
    2. Import executeProgram from test_riscv_core.js
    3. Implement these test functions:

    ```javascript
    /**
     * Geometry OS: MMU Test Suite
     * Phase 19-03: Comprehensive Sv32 MMU Testing
     */

    import { PrivilegedTestEncoder } from './test_privileged.js';
    import { executeProgram } from './test_riscv_core.js';
    import { CoreExecutionVerifier } from '../CoreExecutionVerifier.js';

    // CSR constants
    const CSR_SATP = 0x180;
    const CSR_MSTATUS = 0x300;
    const CSR_MCAUSE = 0x342;
    const CSR_MTVAL = 0x343;
    const CSR_MTVEC = 0x305;

    // Page fault causes
    const CAUSE_INST_PAGE_FAULT = 12;
    const CAUSE_LOAD_PAGE_FAULT = 13;
    const CAUSE_STORE_PAGE_FAULT = 15;

    /**
     * Helper: Setup identity-mapped page table
     * Maps VA 0x00000000-0x00FFFFFF -> PA 0x00000000-0x00FFFFFF (16MB)
     */
    function setupIdentityMap(memoryBuffer, rootPA) {
        // Create 4 MegaPage entries (4MB each) covering first 16MB
        // PTE format: PPN[21:10] | RSW[9:8] | D | A | G | U | X | W | R | V
        // For identity map: PPN = VA>>22 for MegaPage

        const pteData = new Uint32Array(4);
        for (let i = 0; i < 4; i++) {
            // MegaPage: PPN[21:10] = VPN[1] (bits 21:10 of PTE)
            // V=1, R=1, W=1, X=1 = 0x0F
            // PPN = i (for 4MB chunk i)
            const ppn = i;  // Physical page number for this 4MB region
            pteData[i] = (ppn << 10) | 0x0F;  // V+R+W+X, MegaPage leaf
        }

        // Write to root page table
        device.queue.writeBuffer(memoryBuffer, rootPA, pteData);
    }

    /**
     * Test: MMU disabled (bare mode) - direct physical access
     */
    export async function testMMUBareMode(verifier, device, queue) {
        const e = new PrivilegedTestEncoder();

        // Don't enable MMU (satp = 0)
        // Write and read from physical address
        e.addi(1, 0, 0x42);      // x1 = 0x42
        e.lui(2, 0x10000);       // x2 = 0x10000000 (256MB)
        e.sw(1, 2, 0);           // mem[0x10000000] = 0x42
        e.lw(3, 2, 0);           // x3 = mem[0x10000000]
        e.jal(0, 0);             // halt

        const state = await executePrivilegedTest(verifier, device, queue, e.finalize());

        return {
            name: 'MMU bare mode',
            pass: state.registers[3] === 0x42,
            expected: 'x3=0x42',
            actual: `x3=0x${state.registers[3]?.toString(16)}`
        };
    }

    /**
     * Test: MMU enabled with identity map
     */
    export async function testMMUIdentityMap(verifier, device, queue) {
        const e = new PrivilegedTestEncoder();

        // Set up identity-mapped page table at 0x03000000
        // Enable MMU with Sv32 mode
        const rootPA = 0x03000000;
        const satp = (1 << 31) | (rootPA >> 12);  // Mode=1 (Sv32), PPN=rootPA>>12

        e.lui(1, 0x30000);           // x1 = 0x03000000
        e.csrrw(0, 1, CSR_SATP);     // satp = x1 (enable MMU)

        // Now access memory - should go through MMU
        e.addi(2, 0, 0x42);          // x2 = 0x42
        e.lui(3, 0x00010);           // x3 = 0x00010000 (64KB, in identity-mapped region)
        e.sw(2, 3, 0);               // mem[VA 0x10000] = 0x42
        e.lw(4, 3, 0);               // x4 = mem[VA 0x10000]
        e.jal(0, 0);                 // halt

        const memorySize = 64 * 1024 * 1024;  // 64MB
        const state = await executePrivilegedTestWithMMU(
            verifier, device, queue, e.finalize(),
            { rootPA: 0x03000000, identityMap: true, memorySize }
        );

        return {
            name: 'MMU identity map',
            pass: state.registers[4] === 0x42,
            expected: 'x4=0x42',
            actual: `x4=0x${state.registers[4]?.toString(16)}`
        };
    }

    /**
     * Test: Page fault on unmapped address
     */
    export async function testMMUPageFault(verifier, device, queue) {
        const e = new PrivilegedTestEncoder();

        // Set up trap handler
        e.lui(1, 0x200);             // x1 = 0x200 (trap handler)
        e.csrrw(0, 1, CSR_MTVEC);    // mtvec = 0x200

        // Enable MMU with minimal page table
        const rootPA = 0x03000000;
        const satp = (1 << 31) | (rootPA >> 12);
        e.lui(1, satp >> 12);
        e.csrrw(0, 1, CSR_SATP);

        // Access unmapped address (0x80000000 - outside identity map)
        e.lui(2, 0x80000);           // x2 = 0x80000000
        e.lw(3, 2, 0);               // Should trigger page fault
        e.addi(4, 0, 0x99);          // Should NOT execute

        // Trap handler at 0x200
        while (e.code.length < 0x80) { e.code.push(0); }
        e.csrrs(5, 0, CSR_MCAUSE);   // x5 = mcause
        e.csrrs(6, 0, CSR_MTVAL);    // x6 = mtval
        e.addi(4, 0, 0x42);          // x4 = 42 (trap executed)
        e.jal(0, 0);

        const state = await executePrivilegedTestWithMMU(
            verifier, device, queue, e.finalize(),
            { rootPA: 0x03000000, identityMap: true }
        );

        // Should have trapped with load page fault
        return {
            name: 'MMU page fault',
            pass: state.registers[4] === 0x42 &&
                  state.registers[5] === CAUSE_LOAD_PAGE_FAULT,
            expected: 'x4=0x42, mcause=13 (load page fault)',
            actual: `x4=${state.registers[4]}, mcause=${state.registers[5]}`
        };
    }

    /**
     * Helper: Execute test with MMU configured
     */
    async function executePrivilegedTestWithMMU(verifier, device, queue, code, options = {}) {
        const { rootPA = 0x03000000, identityMap = true, memorySize = 4096 } = options;

        // Create buffers with extra space for page tables
        const actualMemorySize = Math.max(memorySize, rootPA + 0x10000);
        const { codeBuffer, memoryBuffer, stateBuffer } = verifier.createTestBuffers(code, actualMemorySize);

        try {
            // Setup identity map if requested
            if (identityMap) {
                const pteData = new Uint32Array(4);
                for (let i = 0; i < 4; i++) {
                    pteData[i] = (i << 10) | 0x0F;  // MegaPage identity map
                }
                device.queue.writeBuffer(memoryBuffer, rootPA / 4, pteData);
            }

            // Create and run pipeline
            const shaderModule = device.createShaderModule({
                label: 'visual_cpu_riscv_mmu_test',
                code: await fetch('../shaders/visual_cpu_riscv.wgsl').then(r => r.text())
            });

            const bindGroupLayout = device.createBindGroupLayout({
                label: 'mmu-test-bgl',
                entries: [
                    { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                    { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                    { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }
                ]
            });

            const pipeline = device.createComputePipeline({
                label: 'mmu-test-pipeline',
                layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                compute: { module: shaderModule, entryPoint: 'main' }
            });

            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: codeBuffer } },
                    { binding: 1, resource: { buffer: memoryBuffer } },
                    { binding: 2, resource: { buffer: stateBuffer } }
                ]
            });

            const commandEncoder = device.createCommandEncoder();
            const passEncoder = commandEncoder.beginComputePass();
            passEncoder.setPipeline(pipeline);
            passEncoder.setBindGroup(0, bindGroup);
            passEncoder.dispatchWorkgroups(1);
            passEncoder.end();
            queue.submit([commandEncoder.finish()]);

            const state = await verifier.readState(stateBuffer);
            return {
                registers: state.registers,
                pc: state.pc,
                mode: state.mode,
                raw: state.raw
            };
        } finally {
            codeBuffer.destroy();
            memoryBuffer.destroy();
            stateBuffer.destroy();
        }
    }

    /**
     * Run all MMU tests
     */
    export async function runAllMMUTests(verifier, device, queue) {
        const results = {
            basic: [],
            faults: [],
            tlb: []
        };

        try {
            results.basic.push(await testMMUBareMode(verifier, device, queue));
            results.basic.push(await testMMUIdentityMap(verifier, device, queue));
            results.faults.push(await testMMUPageFault(verifier, device, queue));
        } catch (e) {
            console.error('MMU test error:', e);
        }

        let total = 0, passed = 0;
        for (const cat of Object.values(results)) {
            for (const t of cat) {
                total++;
                if (t.pass) passed++;
            }
        }

        return { categories: results, totalTests: total, passedTests: passed, allPassed: passed === total };
    }

    // Browser exports
    if (typeof window !== 'undefined') {
        window.testMMUBareMode = testMMUBareMode;
        window.testMMUIdentityMap = testMMUIdentityMap;
        window.testMMUPageFault = testMMUPageFault;
        window.runAllMMUTests = runAllMMUTests;
    }
    ```

    This creates the foundation. We'll add TLB tests in Task 2.
  </action>
  <verify>ls -la systems/visual_shell/web/tests/test_mmu.js && grep -c "export async function" systems/visual_shell/web/tests/test_mmu.js</verify>
  <done>test_mmu.js created with basic translation and page fault tests</done>
</task>

<task type="auto">
  <name>Task 2: Add TLB-specific tests</name>
  <files>systems/visual_shell/web/tests/test_mmu.js</files>
  <action>
    Add TLB functionality tests to the test_mmu.js file.

    Add these test functions before the runAllMMUTests function:

    ```javascript
    /**
     * Test: TLB caching improves repeated access
     * Note: This is a functional test, not a performance benchmark.
     * We verify that the same address translates correctly multiple times.
     */
    export async function testTLBRepeatedAccess(verifier, device, queue) {
        const e = new PrivilegedTestEncoder();

        // Enable MMU with identity map
        const rootPA = 0x03000000;
        const satp = (1 << 31) | (rootPA >> 12);
        e.lui(1, satp >> 12);
        e.csrrw(0, 1, CSR_SATP);

        // Access same address multiple times (should hit TLB after first)
        e.lui(2, 0x00010);           // x2 = 0x10000
        e.addi(3, 0, 0);             // x3 = 0 (counter)

        // Loop: read, increment, write, repeat 3 times
        e.lw(4, 2, 0);               // x4 = mem[0x10000]
        e.addi(4, 4, 1);             // x4++
        e.sw(4, 2, 0);               // mem[0x10000] = x4

        e.lw(5, 2, 0);               // x5 = mem[0x10000] (TLB hit)
        e.addi(5, 5, 1);             // x5++
        e.sw(5, 2, 0);               // mem[0x10000] = x5

        e.lw(6, 2, 0);               // x6 = mem[0x10000] (TLB hit)
        e.jal(0, 0);                 // halt

        const state = await executePrivilegedTestWithMMU(
            verifier, device, queue, e.finalize(),
            { rootPA: 0x03000000, identityMap: true, memorySize: 128 * 1024 }
        );

        // x6 should be 3 (three increments)
        return {
            name: 'TLB repeated access',
            pass: state.registers[6] === 3,
            expected: 'x6=3',
            actual: `x6=${state.registers[6]}`
        };
    }

    /**
     * Test: SFENCE.VMA flushes TLB
     */
    export async function testSFENCEVMA(verifier, device, queue) {
        const e = new PrivilegedTestEncoder();

        // Enable MMU with identity map
        const rootPA = 0x03000000;
        const satp = (1 << 31) | (rootPA >> 12);
        e.lui(1, satp >> 12);
        e.csrrw(0, 1, CSR_SATP);

        // Access memory
        e.lui(2, 0x00010);
        e.addi(3, 0, 0x42);
        e.sw(3, 2, 0);               // mem[0x10000] = 0x42

        // SFENCE.VMA
        e.sfence_vma();

        // Access again (should still work after flush)
        e.lw(4, 2, 0);               // x4 = mem[0x10000]
        e.jal(0, 0);

        const state = await executePrivilegedTestWithMMU(
            verifier, device, queue, e.finalize(),
            { rootPA: 0x03000000, identityMap: true, memorySize: 128 * 1024 }
        );

        return {
            name: 'SFENCE.VMA flush',
            pass: state.registers[4] === 0x42,
            expected: 'x4=0x42 (access works after flush)',
            actual: `x4=0x${state.registers[4]?.toString(16)}`
        };
    }

    /**
     * Test: satp change flushes TLB
     */
    export async function testSATPFlushesTLB(verifier, device, queue) {
        const e = new PrivilegedTestEncoder();

        // Enable MMU with identity map
        const rootPA = 0x03000000;
        const satp = (1 << 31) | (rootPA >> 12);
        e.lui(1, satp >> 12);
        e.csrrw(0, 1, CSR_SATP);

        // Access memory
        e.lui(2, 0x00010);
        e.addi(3, 0, 0x42);
        e.sw(3, 2, 0);

        // Rewrite satp (should flush TLB)
        e.csrrw(0, 1, CSR_SATP);

        // Access again (should work)
        e.lw(4, 2, 0);
        e.jal(0, 0);

        const state = await executePrivilegedTestWithMMU(
            verifier, device, queue, e.finalize(),
            { rootPA: 0x03000000, identityMap: true, memorySize: 128 * 1024 }
        );

        return {
            name: 'satp flushes TLB',
            pass: state.registers[4] === 0x42,
            expected: 'x4=0x42',
            actual: `x4=0x${state.registers[4]?.toString(16)}`
        };
    }
    ```

    Also update the runAllMMUTests function to include these tests:

    ```javascript
    export async function runAllMMUTests(verifier, device, queue) {
        const results = {
            basic: [],
            faults: [],
            tlb: []
        };

        try {
            // Basic translation
            results.basic.push(await testMMUBareMode(verifier, device, queue));
            results.basic.push(await testMMUIdentityMap(verifier, device, queue));

            // Page faults
            results.faults.push(await testMMUPageFault(verifier, device, queue));

            // TLB functionality
            results.tlb.push(await testTLBRepeatedAccess(verifier, device, queue));
            results.tlb.push(await testSFENCEVMA(verifier, device, queue));
            results.tlb.push(await testSATPFlushesTLB(verifier, device, queue));
        } catch (e) {
            console.error('MMU test error:', e);
        }

        let total = 0, passed = 0;
        for (const cat of Object.values(results)) {
            for (const t of cat) {
                total++;
                if (t.pass) passed++;
            }
        }

        return { categories: results, totalTests: total, passedTests: passed, allPassed: passed === total };
    }
    ```

    And add browser exports:

    ```javascript
    window.testTLBRepeatedAccess = testTLBRepeatedAccess;
    window.testSFENCEVMA = testSFENCEVMA;
    window.testSATPFlushesTLB = testSATPFlushesTLB;
    ```
  </action>
  <verify>grep -c "testTLB\|testSFENCE" systems/visual_shell/web/tests/test_mmu.js</verify>
  <done>TLB and SFENCE.VMA tests added to test_mmu.js</done>
</task>

<task type="auto">
  <name>Task 3: Create test_mmu.html test runner</name>
  <files>systems/visual_shell/web/tests/test_mmu.html</files>
  <action>
    Create an HTML test runner for the MMU tests, following the pattern of test_privileged.html.

    ```html
    <!DOCTYPE html>
    <html>
    <head>
        <title>Geometry OS - MMU Test Suite</title>
        <style>
            body { font-family: monospace; padding: 20px; background: #1a1a2e; color: #eee; }
            h1 { color: #00ff88; }
            .pass { color: #00ff88; }
            .fail { color: #ff4444; }
            .category { margin: 20px 0; padding: 10px; background: #16213e; border-radius: 5px; }
            .test { padding: 5px 0; border-bottom: 1px solid #333; }
            .test:last-child { border-bottom: none; }
            #summary { font-size: 1.2em; padding: 10px; background: #0f3460; margin-top: 20px; }
            button { padding: 10px 20px; font-size: 1em; cursor: pointer; background: #00ff88; color: #1a1a2e; border: none; border-radius: 5px; }
            button:hover { background: #00cc6a; }
        </style>
    </head>
    <body>
        <h1>Phase 19: MMU Test Suite</h1>
        <p>Tests for Sv32 virtual memory, page table walks, TLB caching, and page faults.</p>

        <button id="runTests">Run Tests</button>

        <div id="results"></div>
        <div id="summary"></div>

        <script type="module">
            import { runAllMMUTests } from './test_mmu.js';
            import { CoreExecutionVerifier } from '../CoreExecutionVerifier.js';

            let device, queue, verifier;

            async function initGPU() {
                if (!navigator.gpu) {
                    throw new Error('WebGPU not supported');
                }
                const adapter = await navigator.gpu.requestAdapter();
                device = await adapter.requestDevice();
                queue = device.queue;
                verifier = new CoreExecutionVerifier(device);
            }

            function renderResults(results) {
                const container = document.getElementById('results');
                container.innerHTML = '';

                for (const [category, tests] of Object.entries(results.categories)) {
                    const catDiv = document.createElement('div');
                    catDiv.className = 'category';
                    catDiv.innerHTML = `<h2>${category.toUpperCase()}</h2>`;

                    for (const test of tests) {
                        const testDiv = document.createElement('div');
                        testDiv.className = 'test';
                        testDiv.innerHTML = `
                            <span class="${test.pass ? 'pass' : 'fail'}">${test.pass ? 'PASS' : 'FAIL'}</span>
                            ${test.name}<br>
                            <small>Expected: ${test.expected} | Actual: ${test.actual}</small>
                        `;
                        catDiv.appendChild(testDiv);
                    }

                    container.appendChild(catDiv);
                }

                const summary = document.getElementById('summary');
                summary.className = results.allPassed ? 'pass' : 'fail';
                summary.textContent = `Summary: ${results.passedTests}/${results.totalTests} tests passed`;
            }

            document.getElementById('runTests').addEventListener('click', async () => {
                const btn = document.getElementById('runTests');
                btn.disabled = true;
                btn.textContent = 'Running...';

                try {
                    await initGPU();
                    const results = await runAllMMUTests(verifier, device, queue);
                    renderResults(results);
                } catch (e) {
                    document.getElementById('results').innerHTML = `<div class="fail">Error: ${e.message}</div>`;
                    console.error(e);
                }

                btn.disabled = false;
                btn.textContent = 'Run Tests';
            });
        </script>
    </body>
    </html>
    ```
  </action>
  <verify>ls -la systems/visual_shell/web/tests/test_mmu.html</verify>
  <done>test_mmu.html test runner created</done>
</task>

</tasks>

<verification>
TDD Cycle:
1. RED: Run tests - they may fail initially due to missing implementation details
2. GREEN: Fix any issues in shader code to make tests pass
3. REFACTOR: Clean up test code if needed

Verification:
1. Open test_mmu.html in browser
2. Click "Run Tests"
3. Verify all tests pass (at least basic and faults categories)
</verification>

<success_criteria>
- test_mmu.js created with at least 6 test functions
- test_mmu.html created as test runner
- Tests cover: bare mode, identity map, page fault, TLB access, SFENCE.VMA, satp flush
- All tests pass when run in browser
</success_criteria>

<output>
After completion, create `.planning/phases/19-memory-management-unit/19-03-SUMMARY.md`
</output>
