---
phase: 08-remote-client
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - systems/visual_shell/web/RemoteCatalogClient.js
  - systems/visual_shell/web/ServerRegistry.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can fetch catalog entries from a remote server URL"
    - "User sees cached data immediately while fresh data loads in background"
    - "User sees error status when a remote server is unreachable"
    - "Remote entries are tagged with their source server ID"
  artifacts:
    - path: "systems/visual_shell/web/RemoteCatalogClient.js"
      provides: "Multi-server catalog aggregation with stale-while-revalidate"
      exports: ["RemoteCatalogClient"]
      min_lines: 200
    - path: "systems/visual_shell/web/ServerRegistry.js"
      provides: "Server configuration persistence in localStorage"
      exports: ["ServerRegistry"]
      min_lines: 100
  key_links:
    - from: "RemoteCatalogClient"
      to: "ServerRegistry"
      via: "getEnabledServers() for server list"
      pattern: "this\\.registry\\.getEnabledServers"
    - from: "RemoteCatalogClient.fetchAllCatalogs"
      to: "each server URL"
      via: "fetch with 10s timeout"
      pattern: "fetch.*timeout.*10000"
---

<objective>
Implement RemoteCatalogClient that aggregates container catalogs from multiple remote servers with stale-while-revalidate pattern.

Purpose: Enable users to browse containers from remote catalog servers alongside local containers.
Output: RemoteCatalogClient.js and ServerRegistry.js modules ready for UI integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns to follow
@systems/visual_shell/web/CatalogBridge.js - API client pattern with timeout and error handling
@systems/visual_shell/web/CatalogCacheManager.js - Stale-while-revalidate pattern

# Phase context
@.planning/phases/08-remote-client/08-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ServerRegistry for server configuration persistence</name>
  <files>systems/visual_shell/web/ServerRegistry.js</files>
  <action>
Create a new ServerRegistry class in `systems/visual_shell/web/ServerRegistry.js` that manages remote server configurations.

**Server metadata schema (stored in localStorage key 'remote-catalog-servers'):**
```javascript
{
  servers: [
    {
      id: 'uuid-v4-string',
      url: 'https://catalog.example.com',
      name: 'Company Catalog',  // Display name
      color: '#00aaff',         // Hex color for badges
      enabled: true,
      addedAt: 1234567890000,   // Timestamp
      lastStatus: 'ok' | 'error' | 'unknown',
      lastError: null | 'error message string'
    }
  ]
}
```

**Required methods:**
- `constructor()` - Load servers from localStorage, initialize with empty array if none exist
- `getServers()` - Return all servers array
- `getEnabledServers()` - Return only servers where enabled=true
- `addServer(url, name, color)` - Add new server with generated UUID, persist to localStorage
- `updateServer(id, updates)` - Update server fields, persist to localStorage
- `removeServer(id)` - Remove server by ID, persist to localStorage
- `setServerStatus(id, status, error)` - Update lastStatus and lastError fields
- `generateId()` - Return crypto.randomUUID() or fallback UUID

**Use localStorage directly (no IndexedDB needed for this config data).**

Follow ES6 export + window attachment pattern from CatalogBridge.js:
```javascript
export { ServerRegistry };
if (typeof window !== 'undefined') {
    window.ServerRegistry = ServerRegistry;
}
```
  </action>
  <verify>
- File exists at systems/visual_shell/web/ServerRegistry.js
- ServerRegistry class is exportable
- localStorage operations work (add/get/remove servers)
- `node -e "const {ServerRegistry} = require('./systems/visual_shell/web/ServerRegistry.js'); const r = new ServerRegistry(); console.log(r.getServers());"` runs without error (or verify in browser console)
  </verify>
  <done>
ServerRegistry class persists server configurations to localStorage with add/remove/update/status methods.
</done>
</task>

<task type="auto">
  <name>Task 2: Create RemoteCatalogClient with multi-server aggregation</name>
  <files>systems/visual_shell/web/RemoteCatalogClient.js</files>
  <action>
Create RemoteCatalogClient class in `systems/visual_shell/web/RemoteCatalogClient.js` that fetches and aggregates catalogs from multiple remote servers.

**Constructor:**
```javascript
constructor(options = {})
```
- Accept `options.timeout` (default: 10000ms = 10 seconds)
- Create internal ServerRegistry instance
- Initialize catalog cache Map (serverId -> {entries, fetchedAt, etag})

**Core methods:**

1. `async fetchServerCatalog(server)` - Fetch catalog from single server
   - Use fetch with AbortController timeout (10s default)
   - GET request to `${server.url}/api/v1/catalog`
   - On success: Tag each entry with `sourceServerId: server.id` and `sourceServerName: server.name`
   - On error: Call `registry.setServerStatus(server.id, 'error', error.message)`
   - Return `{ success: boolean, entries: [], error: string|null }`

2. `async fetchAllCatalogs(options = {})` - Aggregate from all enabled servers
   - Get enabled servers from registry
   - Fetch all in parallel using Promise.allSettled
   - Return flattened array of all entries with source metadata
   - Structure: `{ entries: [], errors: [{serverId, serverName, error}] }`

3. `getAggregatedCatalog()` - Get cached catalog (no network)
   - Return all cached entries from previous fetchAllCatalogs call
   - Used for stale-while-revalidate (return stale immediately)

4. `async fetchWithStaleWhileRevalidate(callback)` - SWR pattern
   - Immediately invoke callback with cached data (if any)
   - Then fetch fresh data in background
   - Invoke callback again with fresh data when complete
   - Pattern: `client.fetchWithStaleWhileRevalidate((data, isStale) => { ... })`

**Error handling:**
- Network errors: Set server status to 'error' with message
- Timeout errors: AbortController abort after 10s
- 4xx/5xx responses: Treat as error, capture status code

**Follow ES6 export + window attachment pattern.**
  </action>
  <verify>
- File exists at systems/visual_shell/web/RemoteCatalogClient.js
- RemoteCatalogClient class is exportable
- fetchServerCatalog handles timeout correctly
- fetchAllCatalogs aggregates entries from multiple servers
- Each entry has sourceServerId and sourceServerName fields
- fetchWithStaleWhileRevalidate calls callback with cached then fresh data
  </verify>
  <done>
RemoteCatalogClient aggregates catalogs from multiple remote servers with 10s timeout, error tracking, and stale-while-revalidate pattern.
</done>
</task>

</tasks>

<verification>
- ServerRegistry persists server configurations to localStorage
- RemoteCatalogClient fetches from multiple servers in parallel
- Entries are tagged with sourceServerId for identification
- Stale-while-revalidate pattern works (cached data returned immediately)
- 10 second timeout prevents hanging on unreachable servers
- Error status is persisted to ServerRegistry for UI display
</verification>

<success_criteria>
1. ServerRegistry can add/remove/update server configurations
2. RemoteCatalogClient.fetchAllCatalogs returns entries from all enabled servers
3. Each remote entry has sourceServerId and sourceServerName metadata
4. Fetch errors are captured and server status is updated
5. Stale-while-revalidate pattern allows immediate cached response
</success_criteria>

<output>
After completion, create `.planning/phases/08-remote-client/08-01-SUMMARY.md`
</output>
