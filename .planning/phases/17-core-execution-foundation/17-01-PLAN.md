---
phase: 17-core-execution-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - systems/visual_shell/web/CoreExecutionVerifier.js
  - systems/visual_shell/web/tests/test_verification_harness.html
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can read GPU register state after execution completes"
    - "User can read GPU memory contents after execution completes"
    - "State readback is consistent (same values on repeated reads)"
    - "State readback reflects actual GPU execution (not stale cached data)"
  artifacts:
    - path: "systems/visual_shell/web/CoreExecutionVerifier.js"
      provides: "Async state readback harness"
      exports: ["CoreExecutionVerifier"]
      min_lines: 100
    - path: "systems/visual_shell/web/tests/test_verification_harness.html"
      provides: "Visual test page for state readback"
  key_links:
    - from: "CoreExecutionVerifier.readState()"
      to: "WebGPU stagingBuffer.mapAsync()"
      via: "GPUBufferUsage.MAP_READ | COPY_DST"
      pattern: "mapAsync.*GPUMapMode.READ"
---

<objective>
Create a verification harness that provides reliable async state readback from GPU execution.

Purpose: Enable users and tests to verify GPU execution results. This is the foundation for all Phase 17 verification - without reliable state readback, we cannot prove any instruction works correctly.

Output: CoreExecutionVerifier.js with staging buffer pattern and visual test page.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-core-execution-foundation/17-RESEARCH.md

# Existing code to reference
@systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
@systems/infinite_map_rs/src/riscv_native/executor.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CoreExecutionVerifier.js with async state readback</name>
  <files>systems/visual_shell/web/CoreExecutionVerifier.js</files>
  <action>
Create a new JavaScript module that implements the async staging buffer pattern for GPU state readback.

The class MUST follow this pattern from executor.rs:208-242:

```javascript
class CoreExecutionVerifier {
    constructor(device, queue) {
        this.device = device;
        this.queue = queue;
    }

    async readState(stateBuffer, size) {
        // CRITICAL: Use staging buffer pattern
        const stagingBuffer = this.device.createBuffer({
            size: size,
            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
            mapped_at_creation: false
        });

        const encoder = this.device.createCommandEncoder();
        encoder.copyBufferToBuffer(stateBuffer, 0, stagingBuffer, 0, size);
        this.device.queue.submit([encoder.finish()]);

        // MUST await mapAsync before reading
        await stagingBuffer.mapAsync(GPUMapMode.READ);
        const data = new Uint32Array(stagingBuffer.getMappedRange());

        // Return a COPY of the data (buffer will be unmapped)
        const result = {
            registers: Array.from(data.slice(0, 32)),
            pc: data[32],
            halted: data[38]
        };

        stagingBuffer.unmap();
        stagingBuffer.destroy();

        return result;
    }
}
```

The class MUST also include:
- `readMemory(memoryBuffer, offset, size)` - Read arbitrary GPU memory region
- `writeMemory(memoryBuffer, offset, data)` - Write to GPU memory (for test setup)
- `createTestBuffers(code)` - Create state/code/memory buffers from instruction array

DO NOT skip the mapAsync await - this is the critical pitfall that causes stale data reads.
DO NOT read from the staging buffer before mapAsync completes.
DO use buffer.destroy() to prevent GPU memory leaks.
  </action>
  <verify>
node -e "const m = require('./systems/visual_shell/web/CoreExecutionVerifier.js'); console.log('Exports:', Object.keys(m));" 2>&1 || echo "Module check failed"
  </verify>
  <done>
CoreExecutionVerifier.js exists with readState(), readMemory(), writeMemory(), and createTestBuffers() methods. The class properly awaits mapAsync before reading buffer contents.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create visual test page for verification harness</name>
  <files>systems/visual_shell/web/tests/test_verification_harness.html</files>
  <action>
Create an HTML test page that validates the state readback works correctly.

The page MUST:
1. Initialize WebGPU and create a minimal compute pipeline
2. Create a test buffer with known values
3. Use CoreExecutionVerifier to read back the values
4. Display pass/fail based on whether values match

Include this test case:
- Write known pattern to GPU buffer: [1, 2, 3, ..., 32] for registers, 100 for PC
- Read back via CoreExecutionVerifier
- Assert registers[0] === 1, registers[31] === 32, pc === 100

The page MUST display:
- "PASS" in green if readback values match expected
- "FAIL" in red with details if values don't match
- The actual vs expected values for debugging

DO NOT run any RISC-V code yet - this just tests the readback mechanism.
DO use async/await correctly for WebGPU operations.
  </action>
  <verify>
ls -la systems/visual_shell/web/tests/test_verification_harness.html
  </verify>
  <done>
test_verification_harness.html exists and can be opened in a browser. The test shows PASS when state readback works correctly.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Open test_verification_harness.html in a WebGPU-capable browser
2. Verify the page shows "PASS" with green background
3. Verify the console shows "Readback verified: registers[0]=1, pc=100" or similar
</verification>

<success_criteria>
1. CoreExecutionVerifier.js exports a class with async readState() method
2. readState() uses staging buffer with awaited mapAsync (no stale data)
3. Test page demonstrates reliable state readback (PASS result)
4. No GPU memory leaks (buffers properly destroyed)
</success_criteria>

<output>
After completion, create `.planning/phases/17-core-execution-foundation/17-01-SUMMARY.md`
</output>
