---
phase: 17-core-execution-foundation
plan: 02
type: execute
wave: 2
depends_on: [17-01]
files_modified:
  - systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can execute ADD, SUB, SLL, SLT, SLTU, XOR, SRL, SRA, OR, AND instructions"
    - "User can execute ADDI, SLTI, SLTIU, XORI, ORI, ANDI, SLLI, SRLI, SRAI instructions"
    - "User can execute LB, LH, LW, LBU, LHU load instructions"
    - "User can execute SB, SH, SW store instructions"
    - "User can execute BEQ, BNE, BLT, BGE, BLTU, BGEU branch instructions"
    - "User can execute LUI, AUIPC upper immediate instructions"
    - "User can execute EBREAK instruction"
  artifacts:
    - path: "systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl"
      provides: "Complete RV32I instruction implementation"
      contains: ["funct3 == 0x1u", "funct3 == 0x2u", "funct3 == 0x3u", "funct3 == 0x4u", "funct3 == 0x5u", "funct3 == 0x6u", "funct3 == 0x7u"]
  key_links:
    - from: "opcode 0x33u case"
      to: "R-type ALU operations"
      via: "funct3 + funct7 dispatch"
      pattern: "funct3 == 0x[1-7]u"
    - from: "opcode 0x13u case"
      to: "I-type immediate operations"
      via: "funct3 dispatch"
      pattern: "funct3 == 0x[1-7]u"
---

<objective>
Complete the RV32I instruction implementation in the WGSL shader to support all 40 base instructions.

Purpose: Enable full RV32I program execution. The existing shader has partial implementation - this plan adds the missing instructions identified in the research.

Output: Updated visual_cpu_riscv.wgsl with complete RV32I support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-core-execution-foundation/17-RESEARCH.md
@.planning/phases/17-core-execution-foundation/17-01-SUMMARY.md

# Existing shader to extend
@systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl

# Reference for instruction encoding
@systems/infinite_map_rs/src/tests/riscv_test_programs.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add missing R-type instructions (SLL, SLT, SLTU, XOR, SRL, SRA, OR, AND)</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
Extend the opcode 0x33u (OP) case in the shader to support all R-type instructions.

Current implementation only has ADD, SUB, and MUL. Add the following to the funct7 == 0x00u block:

```wgsl
case 0x33u: { // OP (ADD, SUB, SLL, SLT, SLTU, XOR, SRL, SRA, OR, AND)
    let val1 = i32(cpu_states[base_idx + rs1]);
    let val2 = i32(cpu_states[base_idx + rs2]);
    let uval1 = cpu_states[base_idx + rs1];
    let uval2 = cpu_states[base_idx + rs2];
    let funct7 = (inst >> 25u) & 0x7Fu;

    if (funct7 == 0x01u) {
        // M extension (already implemented)
        if (funct3 == 0u) { if (rd != 0u) { cpu_states[base_idx + rd] = u32(val1 * val2); } }
        else if (funct3 == 4u) { if (val2 != 0 && rd != 0u) { cpu_states[base_idx + rd] = u32(val1 / val2); } }
    } else if (funct7 == 0x00u || funct7 == 0x20u) {
        // Standard R-type operations
        if (funct3 == 0u) { // ADD
            if (rd != 0u) { cpu_states[base_idx + rd] = u32(val1 + val2); }
        } else if (funct3 == 1u) { // SLL (shift left logical)
            if (rd != 0u) { cpu_states[base_idx + rd] = uval1 << (uval2 & 0x1Fu); }
        } else if (funct3 == 2u) { // SLT (set less than, signed)
            if (rd != 0u) { cpu_states[base_idx + rd] = select(0u, 1u, val1 < val2); }
        } else if (funct3 == 3u) { // SLTU (set less than, unsigned)
            if (rd != 0u) { cpu_states[base_idx + rd] = select(0u, 1u, uval1 < uval2); }
        } else if (funct3 == 4u) { // XOR
            if (rd != 0u) { cpu_states[base_idx + rd] = uval1 ^ uval2; }
        } else if (funct3 == 5u) { // SRL/SRA
            if (funct7 == 0x00u) { // SRL (shift right logical)
                if (rd != 0u) { cpu_states[base_idx + rd] = uval1 >> (uval2 & 0x1Fu); }
            } else { // SRA (shift right arithmetic)
                if (rd != 0u) { cpu_states[base_idx + rd] = u32(val1 >> (uval2 & 0x1Fu)); }
            }
        } else if (funct3 == 6u) { // OR
            if (rd != 0u) { cpu_states[base_idx + rd] = uval1 | uval2; }
        } else if (funct3 == 7u) { // AND
            if (rd != 0u) { cpu_states[base_idx + rd] = uval1 & uval2; }
        }
    }
}
```

DO NOT modify the existing ADD/SUB implementation - extend it.
DO use uval1/uval2 for unsigned comparisons (SLTU, shifts).
DO use val1/val2 for signed comparisons (SLT, SRA).
  </action>
  <verify>
grep -c "funct3 == 0x7u" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
  </verify>
  <done>
Shader contains all 10 R-type operations: ADD, SUB, SLL, SLT, SLTU, XOR, SRL, SRA, OR, AND (funct3 0x0 through 0x7 covered).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add missing I-type instructions (SLTI, SLTIU, XORI, ORI, ANDI, SLLI, SRLI, SRAI)</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
Extend the opcode 0x13u (OP-IMM) case to support all I-type instructions.

Current implementation only has ADDI. Add the following:

```wgsl
case 0x13u: { // OP-IMM (ADDI, SLTI, SLTIU, XORI, ORI, ANDI, SLLI, SRLI, SRAI)
    let imm = i32(inst) >> 20u;  // Sign-extended 12-bit immediate
    let uimm = (inst >> 20u) & 0xFFFu;  // Unsigned immediate for shifts
    let val1 = i32(cpu_states[base_idx + rs1]);
    let uval1 = cpu_states[base_idx + rs1];
    let shamt = uimm & 0x1Fu;  // Shift amount (bits 24:20)

    if (funct3 == 0u) { // ADDI
        if (rd != 0u) { cpu_states[base_idx + rd] = u32(val1 + imm); }
    } else if (funct3 == 2u) { // SLTI (set less than immediate, signed)
        if (rd != 0u) { cpu_states[base_idx + rd] = select(0u, 1u, val1 < imm); }
    } else if (funct3 == 3u) { // SLTIU (set less than immediate, unsigned)
        // Note: immediate is still sign-extended, then treated as unsigned
        if (rd != 0u) { cpu_states[base_idx + rd] = select(0u, 1u, uval1 < u32(imm)); }
    } else if (funct3 == 4u) { // XORI
        if (rd != 0u) { cpu_states[base_idx + rd] = uval1 ^ u32(imm); }
    } else if (funct3 == 6u) { // ORI
        if (rd != 0u) { cpu_states[base_idx + rd] = uval1 | u32(imm); }
    } else if (funct3 == 7u) { // ANDI
        if (rd != 0u) { cpu_states[base_idx + rd] = uval1 & u32(imm); }
    } else if (funct3 == 1u) { // SLLI (shift left logical immediate)
        if (rd != 0u) { cpu_states[base_idx + rd] = uval1 << shamt; }
    } else if (funct3 == 5u) { // SRLI/SRAI
        let funct7bit = (inst >> 30u) & 1u;
        if (funct7bit == 0u) { // SRLI (shift right logical immediate)
            if (rd != 0u) { cpu_states[base_idx + rd] = uval1 >> shamt; }
        } else { // SRAI (shift right arithmetic immediate)
            if (rd != 0u) { cpu_states[base_idx + rd] = u32(val1 >> shamt); }
        }
    }
}
```

DO use shamt = uimm & 0x1Fu for shift amount (only lower 5 bits matter).
DO check bit 30 for SRLI vs SRAI distinction (not full funct7).
  </action>
  <verify>
grep -c "SLTI\|SLTIU\|XORI\|ORI\|ANDI\|SLLI\|SRLI\|SRAI" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl || grep -E "funct3 == 0x[1-7]u" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl | wc -l
  </verify>
  <done>
Shader contains all 9 I-type operations in opcode 0x13u case with funct3 dispatch for all values 0-7.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add byte/half load/store instructions (LB, LH, LBU, LHU, SB, SH)</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
Extend opcode 0x03u (LOAD) and 0x23u (STORE) cases to support byte and halfword operations.

For LOAD (opcode 0x03u), add cases for funct3 0, 1, 4, 5:

```wgsl
case 0x03u: { // LOAD (LB, LH, LW, LBU, LHU)
    let offset = i32(inst) >> 20u;
    let val1 = i32(cpu_states[base_idx + rs1]);
    let vaddr = u32(val1 + offset);
    let paddr = translate_address(vaddr, ACCESS_READ, base_idx);

    if (paddr == 0xFFFFFFFFu) {
        pc = trap_enter(base_idx, CAUSE_LOAD_PAGE_FAULT, vaddr, pc);
        trap_triggered = true;
    } else if (paddr < 134217728u) {
        let word_addr = paddr / 4u;
        let byte_offset = paddr % 4u;
        let word_val = system_memory[word_addr];

        if (funct3 == 0x0u) { // LB (load byte, sign-extend)
            let byte_val = (word_val >> (byte_offset * 8u)) & 0xFFu;
            let sign_ext = select(0u, 0xFFFFFF00u, (byte_val & 0x80u) != 0u);
            if (rd != 0u) { cpu_states[base_idx + rd] = byte_val | sign_ext; }
        } else if (funct3 == 0x1u) { // LH (load half, sign-extend)
            let half_offset = (paddr / 2u) % 2u;
            let half_val = (word_val >> (half_offset * 16u)) & 0xFFFFu;
            let sign_ext = select(0u, 0xFFFF0000u, (half_val & 0x8000u) != 0u);
            if (rd != 0u) { cpu_states[base_idx + rd] = half_val | sign_ext; }
        } else if (funct3 == 0x2u) { // LW (already implemented)
            if (rd != 0u) { cpu_states[base_idx + rd] = word_val; }
        } else if (funct3 == 0x4u) { // LBU (load byte, zero-extend)
            let byte_val = (word_val >> (byte_offset * 8u)) & 0xFFu;
            if (rd != 0u) { cpu_states[base_idx + rd] = byte_val; }
        } else if (funct3 == 0x5u) { // LHU (load half, zero-extend)
            let half_offset = (paddr / 2u) % 2u;
            let half_val = (word_val >> (half_offset * 16u)) & 0xFFFFu;
            if (rd != 0u) { cpu_states[base_idx + rd] = half_val; }
        }
    }
}
```

For STORE (opcode 0x23u), add cases for funct3 0, 1:

```wgsl
case 0x23u: { // STORE (SB, SH, SW)
    let imm_s = ((inst >> 25u) & 0x7Fu) << 5u | ((inst >> 7u) & 0x1Fu);
    let offset_s = (i32(imm_s) << 20u) >> 20u;
    let val1 = i32(cpu_states[base_idx + rs1]);
    let val2 = i32(cpu_states[base_idx + rs2]);
    let vaddr = u32(val1 + offset_s);
    let paddr = translate_address(vaddr, ACCESS_WRITE, base_idx);

    if (paddr == 0xFFFFFFFFu) {
        pc = trap_enter(base_idx, CAUSE_STORE_PAGE_FAULT, vaddr, pc);
        trap_triggered = true;
    } else if (paddr < 134217728u) {
        if (funct3 == 0x0u) { // SB (store byte)
            let byte_offset = paddr % 4u;
            let mask = ~(0xFFu << (byte_offset * 8u));
            let existing = system_memory[paddr / 4u] & mask;
            let new_byte = (val2 & 0xFFu) << (byte_offset * 8u);
            system_memory[paddr / 4u] = existing | new_byte;
        } else if (funct3 == 0x1u) { // SH (store half)
            let half_offset = (paddr / 2u) % 2u;
            let mask = ~(0xFFFFu << (half_offset * 16u));
            let existing = system_memory[paddr / 4u] & mask;
            let new_half = (val2 & 0xFFFFu) << (half_offset * 16u);
            system_memory[paddr / 4u] = existing | new_half;
        } else if (funct3 == 0x2u) { // SW (already implemented)
            system_memory[paddr / 4u] = val2;
        }
        // UART handling (keep existing)
        if (paddr == UART_BASE) { ... }
    }
}
```

DO handle byte alignment correctly (byte_offset = paddr % 4).
DO preserve existing bytes when doing partial writes (read-modify-write).
  </action>
  <verify>
grep -c "funct3 == 0x0u\|funct3 == 0x1u\|funct3 == 0x4u\|funct3 == 0x5u" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
  </verify>
  <done>
Shader supports LB, LH, LW, LBU, LHU loads and SB, SH, SW stores with correct byte alignment handling.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add missing branch instructions (BLT, BGE, BLTU, BGEU)</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
Extend the opcode 0x63u (BRANCH) case to support all six branch types.

Current implementation only has BEQ (funct3=0) and BNE (funct3=1). Add:

```wgsl
case 0x63u: { // BRANCH (BEQ, BNE, BLT, BGE, BLTU, BGEU)
    let val1 = cpu_states[base_idx + rs1];
    let val2 = cpu_states[base_idx + rs2];
    let sval1 = i32(val1);
    let sval2 = i32(val2);
    var branch = false;

    if (funct3 == 0u) { branch = (val1 == val2); }          // BEQ
    else if (funct3 == 1u) { branch = (val1 != val2); }     // BNE
    else if (funct3 == 4u) { branch = (sval1 < sval2); }    // BLT (signed)
    else if (funct3 == 5u) { branch = (sval1 >= sval2); }   // BGE (signed)
    else if (funct3 == 6u) { branch = (val1 < val2); }      // BLTU (unsigned)
    else if (funct3 == 7u) { branch = (val1 >= val2); }     // BGEU (unsigned)

    if (branch) {
        let imm = ( (inst >> 31u) << 12u ) | ( ((inst >> 7u) & 1u) << 11u ) | ( ((inst >> 25u) & 0x3Fu) << 5u ) | ( ((inst >> 8u) & 0xFu) << 1u );
        let offset = (i32(imm) << 19u) >> 19u;
        pc = u32(i32(pc) + (offset / 4));
        pc_changed = true;
    }
}
```

DO use signed comparison (sval1, sval2) for BLT/BGE.
DO use unsigned comparison (val1, val2) for BLTU/BGEU.
DO NOT add funct3 2 or 3 - those are reserved in RV32I.
  </action>
  <verify>
grep -E "funct3 == [4-7]u" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl | wc -l
  </verify>
  <done>
Shader supports all 6 branch instructions: BEQ, BNE, BLT, BGE, BLTU, BGEU (funct3 0, 1, 4, 5, 6, 7).
  </done>
</task>

<task type="auto">
  <name>Task 5: Add AUIPC and EBREAK instructions</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
Add two missing instructions:

1. AUIPC (opcode 0x17u) - Add Upper Immediate to PC:
```wgsl
case 0x17u: { // AUIPC
    let imm = inst & 0xFFFFF000u;  // Upper 20 bits, shifted left 12
    if (rd != 0u) {
        // PC is instruction index, byte address is pc * 4
        cpu_states[base_idx + rd] = u32(i32(pc * 4u) + i32(imm));
    }
}
```

2. EBREAK (in opcode 0x73u SYSTEM case) - Breakpoint:
```wgsl
// In the opcode 0x73u case, after ECALL handling:
else if (funct3_sys == 0u && ((inst >> 20u) & 0xFFFu) == 0x001u) {
    // EBREAK - trigger breakpoint trap
    pc = trap_enter(base_idx, CAUSE_BREAKPOINT, pc * 4u, pc);
    trap_triggered = true;
}
```

Add the AUIPC opcode case after the LUI case (0x37u) in the switch statement.

DO ensure AUIPC adds to byte address (pc * 4), not instruction index.
DO trigger CAUSE_BREAKPOINT (3) for EBREAK, not CAUSE_ILLEGAL_INST.
  </action>
  <verify>
grep -c "case 0x17u\|AUIPC" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
  </verify>
  <done>
Shader supports AUIPC (opcode 0x17) and EBREAK (funct12=0x001 in SYSTEM opcode).
  </done>
</task>

</tasks>

<verification>
After completing all tasks, verify the shader compiles:
1. Check WGSL syntax by loading in a WebGPU context
2. Run simple instruction tests for each new instruction type
3. Verify no regression in existing instructions
</verification>

<success_criteria>
1. All 10 R-type instructions implemented (CORE-02)
2. All 9 I-type instructions implemented (CORE-03)
3. All 6 load instructions implemented (CORE-04)
4. All 3 store instructions implemented (CORE-05)
5. All 6 branch instructions implemented (CORE-06)
6. JAL, JALR work correctly (CORE-07) - already implemented
7. LUI, AUIPC work correctly (CORE-08)
8. ECALL, EBREAK work correctly (CORE-09)
</success_criteria>

<output>
After completion, create `.planning/phases/17-core-execution-foundation/17-02-SUMMARY.md`
</output>
