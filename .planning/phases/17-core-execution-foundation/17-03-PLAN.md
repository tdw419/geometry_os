---
phase: 17-core-execution-foundation
plan: 03
type: tdd
wave: 3
depends_on: [17-01, 17-02]
files_modified:
  - systems/visual_shell/web/tests/test_riscv_core.js
  - systems/visual_shell/web/tests/test_riscv_core.html
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can run a test suite that verifies all RV32I instructions"
    - "User can see test results for arithmetic operations"
    - "User can see test results for memory operations"
    - "User can see test results for branch/jump operations"
    - "User can see test results for upper immediate operations"
  artifacts:
    - path: "systems/visual_shell/web/tests/test_riscv_core.js"
      provides: "Complete RV32I test suite"
      exports: ["RiscvTestEncoder", "runAllTests"]
      min_lines: 300
    - path: "systems/visual_shell/web/tests/test_riscv_core.html"
      provides: "Visual test runner"
  key_links:
    - from: "RiscvTestEncoder"
      to: "GPU instruction buffer"
      via: "CoreExecutionVerifier.createTestBuffers()"
      pattern: "new RiscvTestEncoder"
    - from: "test_riscv_core.js"
      to: "visual_cpu_riscv.wgsl"
      via: "GPU execution and state readback"
      pattern: "verifier.readState"
---

<objective>
Create a comprehensive test suite that validates all RV32I instructions execute correctly on the GPU.

Purpose: Provide automated verification that the WGSL shader implementation is correct. Tests use the RiscvEncoder pattern from the Rust codebase adapted to JavaScript.

Output: test_riscv_core.js with RiscvTestEncoder class and test runner, plus HTML test page.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-core-execution-foundation/17-RESEARCH.md
@.planning/phases/17-core-execution-foundation/17-01-SUMMARY.md
@.planning/phases/17-core-execution-foundation/17-02-SUMMARY.md

# Reference implementations
@systems/infinite_map_rs/src/tests/riscv_test_programs.rs
@systems/visual_shell/web/CoreExecutionVerifier.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RiscvTestEncoder class in JavaScript</name>
  <files>systems/visual_shell/web/tests/test_riscv_core.js</files>
  <action>
Create a JavaScript port of the RiscvTestEncoder pattern from riscv_test_programs.rs.

The class MUST provide these encoding methods:

```javascript
class RiscvTestEncoder {
    constructor() {
        this.code = [];
        this.pc = 0;
    }

    // R-type: funct7 << 25 | rs2 << 20 | rs1 << 15 | funct3 << 12 | rd << 7 | opcode
    _emitR(opcode, rd, rs1, rs2, funct3, funct7) {
        const inst = (funct7 << 25) | (rs2 << 20) | (rs1 << 15) | (funct3 << 12) | (rd << 7) | opcode;
        this.code.push(inst);
        this.pc += 4;
    }

    // I-type: imm << 20 | rs1 << 15 | funct3 << 12 | rd << 7 | opcode
    _emitI(opcode, rd, rs1, funct3, imm) {
        const inst = ((imm & 0xFFF) << 20) | (rs1 << 15) | (funct3 << 12) | (rd << 7) | opcode;
        this.code.push(inst);
        this.pc += 4;
    }

    // U-type: imm & 0xFFFFF000 | rd << 7 | opcode
    _emitU(opcode, rd, imm) {
        const inst = (imm & 0xFFFFF000) | (rd << 7) | opcode;
        this.code.push(inst);
        this.pc += 4;
    }

    // B-type: complex encoding with imm distributed
    _emitB(opcode, rs1, rs2, funct3, imm) {
        const imm12 = ((imm >> 12) & 1) << 31;
        const imm10_5 = ((imm >> 5) & 0x3F) << 25;
        const imm4_1 = ((imm >> 1) & 0xF) << 8;
        const imm11 = ((imm >> 11) & 1) << 7;
        const inst = imm12 | imm10_5 | (rs2 << 20) | (rs1 << 15) | (funct3 << 12) | imm4_1 | imm11 | opcode;
        this.code.push(inst);
        this.pc += 4;
    }

    // J-type: complex encoding for jumps
    _emitJ(opcode, rd, imm) {
        const imm20 = ((imm >> 20) & 1) << 31;
        const imm10_1 = ((imm >> 1) & 0x3FF) << 21;
        const imm11 = ((imm >> 11) & 1) << 20;
        const imm19_12 = ((imm >> 12) & 0xFF) << 12;
        const inst = imm20 | imm10_1 | imm11 | imm19_12 | (rd << 7) | opcode;
        this.code.push(inst);
        this.pc += 4;
    }

    // Instruction helpers
    add(rd, rs1, rs2) { this._emitR(0x33, rd, rs1, rs2, 0x0, 0x00); }
    sub(rd, rs1, rs2) { this._emitR(0x33, rd, rs1, rs2, 0x0, 0x20); }
    sll(rd, rs1, rs2) { this._emitR(0x33, rd, rs1, rs2, 0x1, 0x00); }
    slt(rd, rs1, rs2) { this._emitR(0x33, rd, rs1, rs2, 0x2, 0x00); }
    sltu(rd, rs1, rs2) { this._emitR(0x33, rd, rs1, rs2, 0x3, 0x00); }
    xor(rd, rs1, rs2) { this._emitR(0x33, rd, rs1, rs2, 0x4, 0x00); }
    srl(rd, rs1, rs2) { this._emitR(0x33, rd, rs1, rs2, 0x5, 0x00); }
    sra(rd, rs1, rs2) { this._emitR(0x33, rd, rs1, rs2, 0x5, 0x20); }
    or(rd, rs1, rs2) { this._emitR(0x33, rd, rs1, rs2, 0x6, 0x00); }
    and(rd, rs1, rs2) { this._emitR(0x33, rd, rs1, rs2, 0x7, 0x00); }

    addi(rd, rs1, imm) { this._emitI(0x13, rd, rs1, 0x0, imm); }
    slti(rd, rs1, imm) { this._emitI(0x13, rd, rs1, 0x2, imm); }
    sltiu(rd, rs1, imm) { this._emitI(0x13, rd, rs1, 0x3, imm); }
    xori(rd, rs1, imm) { this._emitI(0x13, rd, rs1, 0x4, imm); }
    ori(rd, rs1, imm) { this._emitI(0x13, rd, rs1, 0x6, imm); }
    andi(rd, rs1, imm) { this._emitI(0x13, rd, rs1, 0x7, imm); }
    slli(rd, rs1, shamt) { this._emitI(0x13, rd, rs1, 0x1, shamt); }
    srli(rd, rs1, shamt) { this._emitI(0x13, rd, rs1, 0x5, shamt); }
    srai(rd, rs1, shamt) { this._emitI(0x13, rd, rs1, 0x5, shamt | 0x400); }

    lb(rd, rs1, offset) { this._emitI(0x03, rd, rs1, 0x0, offset); }
    lh(rd, rs1, offset) { this._emitI(0x03, rd, rs1, 0x1, offset); }
    lw(rd, rs1, offset) { this._emitI(0x03, rd, rs1, 0x2, offset); }
    lbu(rd, rs1, offset) { this._emitI(0x03, rd, rs1, 0x4, offset); }
    lhu(rd, rs1, offset) { this._emitI(0x03, rd, rs1, 0x5, offset); }

    sb(rs2, rs1, offset) { /* S-type encoding */ }
    sh(rs2, rs1, offset) { /* S-type encoding */ }
    sw(rs2, rs1, offset) { /* S-type encoding */ }

    beq(rs1, rs2, offset) { this._emitB(0x63, rs1, rs2, 0x0, offset); }
    bne(rs1, rs2, offset) { this._emitB(0x63, rs1, rs2, 0x1, offset); }
    blt(rs1, rs2, offset) { this._emitB(0x63, rs1, rs2, 0x4, offset); }
    bge(rs1, rs2, offset) { this._emitB(0x63, rs1, rs2, 0x5, offset); }
    bltu(rs1, rs2, offset) { this._emitB(0x63, rs1, rs2, 0x6, offset); }
    bgeu(rs1, rs2, offset) { this._emitB(0x63, rs1, rs2, 0x7, offset); }

    jal(rd, offset) { this._emitJ(0x6F, rd, offset); }
    jalr(rd, rs1, offset) { this._emitI(0x67, rd, rs1, 0x0, offset); }

    lui(rd, imm) { this._emitU(0x37, rd, imm); }
    auipc(rd, imm) { this._emitU(0x17, rd, imm); }

    ecall() { this.code.push(0x00000073); this.pc += 4; }
    ebreak() { this.code.push(0x00100073); this.pc += 4; }

    nop() { this.addi(0, 0, 0); }

    finalize() {
        return new Uint32Array(this.code);
    }
}
```

DO NOT use any external RISC-V libraries - implement encoding from scratch.
DO ensure immediate sign-extension is handled correctly.
  </action>
  <verify>
node -e "const m = require('./systems/visual_shell/web/tests/test_riscv_core.js'); const e = new m.RiscvTestEncoder(); e.addi(1, 0, 42); console.log('ADDI encoded:', e.code[0].toString(16));"
  </verify>
  <done>
RiscvTestEncoder class exists with all 40 RV32I instruction encoders. ADDI x1, x0, 42 encodes to 0x02a00093.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test functions for each instruction category</name>
  <files>systems/visual_shell/web/tests/test_riscv_core.js</files>
  <action>
Add test functions to test_riscv_core.js that verify each instruction category:

```javascript
// Test R-type arithmetic
async function testArithmetic(verifier, device, queue) {
    const tests = [];

    // Test ADD
    {
        const e = new RiscvTestEncoder();
        e.addi(1, 0, 10);    // x1 = 10
        e.addi(2, 0, 32);    // x2 = 32
        e.add(3, 1, 2);      // x3 = x1 + x2 = 42
        e.ecall();
        const result = await executeProgram(verifier, device, queue, e.finalize());
        tests.push({ name: 'ADD', pass: result.registers[3] === 42, expected: 42, actual: result.registers[3] });
    }

    // Test SUB
    {
        const e = new RiscvTestEncoder();
        e.addi(1, 0, 100);
        e.addi(2, 0, 58);
        e.sub(3, 1, 2);      // x3 = 100 - 58 = 42
        e.ecall();
        const result = await executeProgram(verifier, device, queue, e.finalize());
        tests.push({ name: 'SUB', pass: result.registers[3] === 42, expected: 42, actual: result.registers[3] });
    }

    // Test SLL, SLT, SLTU, XOR, SRL, SRA, OR, AND
    // ... similar patterns ...

    return tests;
}

// Test I-type immediate operations
async function testImmediate(verifier, device, queue) {
    // Test ADDI, SLTI, SLTIU, XORI, ORI, ANDI, SLLI, SRLI, SRAI
    // ...
}

// Test Load/Store
async function testMemory(verifier, device, queue) {
    // Test LB, LH, LW, LBU, LHU, SB, SH, SW
    // ...
}

// Test Branch
async function testBranch(verifier, device, queue) {
    // Test BEQ, BNE, BLT, BGE, BLTU, BGEU
    // ...
}

// Test Jump
async function testJump(verifier, device, queue) {
    // Test JAL, JALR
    // ...
}

// Test Upper Immediate
async function testUpperImmediate(verifier, device, queue) {
    // Test LUI, AUIPC
    // ...
}

// Helper to execute a program and return state
async function executeProgram(verifier, device, queue, code) {
    // Create buffers, dispatch shader, read state
    // Uses CoreExecutionVerifier pattern
}

// Main test runner
async function runAllTests(verifier, device, queue) {
    const results = {
        arithmetic: await testArithmetic(verifier, device, queue),
        immediate: await testImmediate(verifier, device, queue),
        memory: await testMemory(verifier, device, queue),
        branch: await testBranch(verifier, device, queue),
        jump: await testJump(verifier, device, queue),
        upperImmediate: await testUpperImmediate(verifier, device, queue)
    };

    const total = Object.values(results).flat().length;
    const passed = Object.values(results).flat().filter(t => t.pass).length;

    return { results, total, passed, failed: total - passed };
}
```

Each test MUST:
1. Create a program with RiscvTestEncoder
2. Execute on GPU via CoreExecutionVerifier
3. Assert the result matches expected value
4. Return pass/fail with actual vs expected

DO create at least 2 tests per instruction (basic case + edge case).
DO test signed/unsigned distinctions (SLT vs SLTU, etc.).
  </action>
  <verify>
grep -c "async function test" systems/visual_shell/web/tests/test_riscv_core.js
  </verify>
  <done>
test_riscv_core.js contains 6 test category functions (arithmetic, immediate, memory, branch, jump, upperImmediate) plus runAllTests.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create HTML test runner page</name>
  <files>systems/visual_shell/web/tests/test_riscv_core.html</files>
  <action>
Create an HTML page that runs all tests and displays results.

```html
<!DOCTYPE html>
<html>
<head>
    <title>RISC-V Core Tests - Phase 17</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a2e; color: #eee; }
        .summary { font-size: 24px; margin-bottom: 20px; }
        .pass { color: #4ade80; }
        .fail { color: #f87171; }
        .category { margin: 20px 0; padding: 10px; background: #16213e; border-radius: 8px; }
        .test { padding: 5px 10px; margin: 2px 0; }
        .test.pass { background: #064e3b; }
        .test.fail { background: #7f1d1d; }
        #running { color: #fbbf24; }
    </style>
</head>
<body>
    <h1>RISC-V RV32I Core Tests</h1>
    <div id="status">Initializing WebGPU...</div>
    <div id="summary" class="summary"></div>
    <div id="results"></div>

    <script type="module">
        import { CoreExecutionVerifier } from '../CoreExecutionVerifier.js';
        import { RiscvTestEncoder, runAllTests } from './test_riscv_core.js';

        async function main() {
            const status = document.getElementById('status');
            const summary = document.getElementById('summary');
            const results = document.getElementById('results');

            try {
                // Initialize WebGPU
                if (!navigator.gpu) {
                    throw new Error('WebGPU not supported');
                }
                const adapter = await navigator.gpu.requestAdapter();
                const device = await adapter.requestDevice();
                const queue = device.queue;

                status.textContent = 'Running tests...';
                status.id = 'running';

                // Run all tests
                const testResults = await runAllTests(
                    new CoreExecutionVerifier(device, queue),
                    device,
                    queue
                );

                // Display summary
                summary.innerHTML = `<span class="${testResults.failed === 0 ? 'pass' : 'fail'}">
                    ${testResults.passed}/${testResults.total} tests passed
                </span>`;

                // Display detailed results
                for (const [category, tests] of Object.entries(testResults.results)) {
                    const catDiv = document.createElement('div');
                    catDiv.className = 'category';
                    catDiv.innerHTML = `<h3>${category}</h3>`;

                    for (const test of tests) {
                        const testDiv = document.createElement('div');
                        testDiv.className = `test ${test.pass ? 'pass' : 'fail'}`;
                        testDiv.textContent = `${test.pass ? 'PASS' : 'FAIL'}: ${test.name}`;
                        if (!test.pass) {
                            testDiv.textContent += ` (expected ${test.expected}, got ${test.actual})`;
                        }
                        catDiv.appendChild(testDiv);
                    }

                    results.appendChild(catDiv);
                }

                status.textContent = 'Tests complete';
                status.id = 'status';
            } catch (error) {
                status.textContent = `Error: ${error.message}`;
                status.className = 'fail';
                console.error(error);
            }
        }

        main();
    </script>
</body>
</html>
```

The page MUST display:
- Total pass/fail count prominently
- Each test category with individual test results
- Expected vs actual values for failures
- Color coding (green for pass, red for fail)

DO use ES modules for clean imports.
DO handle WebGPU initialization errors gracefully.
  </action>
  <verify>
ls -la systems/visual_shell/web/tests/test_riscv_core.html
  </verify>
  <done>
test_riscv_core.html exists with visual test runner. When opened in WebGPU browser, shows pass/fail for all RV32I tests.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Open test_riscv_core.html in a WebGPU-capable browser
2. Verify all tests pass (or document any failures)
3. Test at least one instruction from each category manually
</verification>

<success_criteria>
1. RiscvTestEncoder encodes all 40 RV32I instructions correctly
2. Test suite runs at least 40 tests (minimum 1 per instruction)
3. All tests pass when shader implementation is correct
4. HTML test runner displays clear pass/fail results
5. Failed tests show expected vs actual values
</success_criteria>

<output>
After completion, create `.planning/phases/17-core-execution-foundation/17-03-SUMMARY.md`
</output>
