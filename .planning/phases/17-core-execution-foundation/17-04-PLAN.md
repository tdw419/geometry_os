---
phase: 17-core-execution-foundation
plan: 04
type: execute
wave: 4
depends_on: [17-03]
files_modified:
  - systems/visual_shell/web/RiscvExecutionPanel.js
  - systems/visual_shell/web/demo_riscv_execution.html
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can load a RISC-V program from a text input field"
    - "User can click 'Execute' to run the program on GPU"
    - "User can see register values update after execution"
    - "User can see memory contents after execution"
    - "User can see the program counter value"
  artifacts:
    - path: "systems/visual_shell/web/RiscvExecutionPanel.js"
      provides: "UI panel for RISC-V execution"
      exports: ["RiscvExecutionPanel"]
      min_lines: 150
    - path: "systems/visual_shell/web/demo_riscv_execution.html"
      provides: "Demo page with execution panel"
  key_links:
    - from: "RiscvExecutionPanel.loadProgram()"
      to: "CoreExecutionVerifier.createTestBuffers()"
      via: "Uint32Array instruction encoding"
      pattern: "createTestBuffers"
    - from: "RiscvExecutionPanel.execute()"
      to: "GPU compute dispatch"
      via: "device.queue.submit"
      pattern: "dispatchWorkgroups"
---

<objective>
Create a visual execution panel that lets users interact with the RISC-V GPU executor.

Purpose: Provide a user-facing interface for Phase 17 verification. Users can load programs, execute them, and inspect results without writing code.

Output: RiscvExecutionPanel.js UI component and demo page.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-core-execution-foundation/17-RESEARCH.md
@.planning/phases/17-core-execution-foundation/17-01-SUMMARY.md
@.planning/phases/17-core-execution-foundation/17-02-SUMMARY.md
@.planning/phases/17-core-execution-foundation/17-03-SUMMARY.md

# Existing infrastructure
@systems/visual_shell/web/CoreExecutionVerifier.js
@systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
@systems/visual_shell/web/tests/test_riscv_core.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RiscvExecutionPanel.js UI component</name>
  <files>systems/visual_shell/web/RiscvExecutionPanel.js</files>
  <action>
Create a JavaScript class that provides a visual interface for RISC-V execution.

```javascript
export class RiscvExecutionPanel {
    constructor(container, device, queue) {
        this.container = container;
        this.device = device;
        this.queue = queue;
        this.verifier = new CoreExecutionVerifier(device, queue);
        this.currentProgram = null;
        this.state = null;

        this.render();
    }

    render() {
        this.container.innerHTML = `
            <div class="riscv-panel">
                <h2>RISC-V GPU Executor</h2>

                <div class="section">
                    <h3>Program Input</h3>
                    <textarea id="program-input" rows="8" placeholder="Enter instructions (hex, one per line)&#10;Example:&#10;0x02a00093  // addi x1, x0, 42&#10;0x00100073  // ecall"></textarea>
                    <div class="buttons">
                        <button id="btn-load">Load Program</button>
                        <button id="btn-example">Load Example</button>
                    </div>
                </div>

                <div class="section">
                    <h3>Execution Control</h3>
                    <div class="buttons">
                        <button id="btn-execute" disabled>Execute</button>
                        <button id="btn-step" disabled>Step (1 instruction)</button>
                        <button id="btn-reset" disabled>Reset</button>
                    </div>
                    <div id="status">No program loaded</div>
                </div>

                <div class="section registers">
                    <h3>Registers</h3>
                    <div id="register-grid"></div>
                </div>

                <div class="section">
                    <h3>Memory Inspector</h3>
                    <input id="mem-address" type="text" placeholder="Address (hex, e.g., 0x1000)">
                    <button id="btn-read-mem">Read</button>
                    <div id="memory-output"></div>
                </div>

                <div class="section">
                    <h3>Execution Log</h3>
                    <div id="log"></div>
                </div>
            </div>
        `;

        this.setupEventListeners();
        this.renderRegisterGrid();
    }

    setupEventListeners() {
        document.getElementById('btn-load').onclick = () => this.loadProgram();
        document.getElementById('btn-example').onclick = () => this.loadExample();
        document.getElementById('btn-execute').onclick = () => this.execute();
        document.getElementById('btn-step').onclick = () => this.step();
        document.getElementById('btn-reset').onclick = () => this.reset();
        document.getElementById('btn-read-mem').onclick = () => this.readMemory();
    }

    renderRegisterGrid() {
        const grid = document.getElementById('register-grid');
        const regNames = ['zero', 'ra', 'sp', 'gp', 'tp', 't0', 't1', 't2',
                          's0', 's1', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5',
                          'a6', 'a7', 's2', 's3', 's4', 's5', 's6', 's7',
                          's8', 's9', 's10', 's11', 't3', 't4', 't5', 't6'];

        let html = '';
        for (let i = 0; i < 32; i++) {
            html += `<div class="reg">
                <span class="reg-name">x${i} (${regNames[i]})</span>
                <span class="reg-value" id="reg-${i}">0x00000000</span>
            </div>`;
        }
        html += `<div class="reg special">
            <span class="reg-name">PC</span>
            <span class="reg-value" id="reg-pc">0x00000000</span>
        </div>`;
        grid.innerHTML = html;
    }

    loadProgram() {
        const input = document.getElementById('program-input').value;
        const lines = input.split('\n').filter(l => l.trim());
        const instructions = [];

        for (const line of lines) {
            const hex = line.split('//')[0].trim(); // Remove comments
            if (hex) {
                const value = parseInt(hex, 16);
                if (!isNaN(value)) {
                    instructions.push(value);
                }
            }
        }

        if (instructions.length === 0) {
            this.log('Error: No valid instructions found');
            return;
        }

        this.currentProgram = new Uint32Array(instructions);
        this.log(`Loaded ${instructions.length} instructions`);

        document.getElementById('btn-execute').disabled = false;
        document.getElementById('btn-step').disabled = false;
        document.getElementById('btn-reset').disabled = false;
        document.getElementById('status').textContent = 'Program loaded, ready to execute';
    }

    loadExample() {
        // Example: compute 10 + 32 = 42
        const example = `// Example: ADD x3 = x1 + x2
0x00a00093  // addi x1, x0, 10
0x02000113  // addi x2, x0, 32
0x002081b3  // add x3, x1, x2
0x00000073  // ecall`;
        document.getElementById('program-input').value = example;
    }

    async execute() {
        if (!this.currentProgram) return;

        document.getElementById('status').textContent = 'Executing...';
        this.log('Starting execution...');

        try {
            // Create buffers and dispatch
            const buffers = await this.verifier.createTestBuffers(this.currentProgram);

            // Execute 100 instructions per dispatch
            // (shader has built-in loop of 100)
            for (let i = 0; i < 10; i++) {  // Max 1000 instructions
                await this.dispatchExecute(buffers);
                this.state = await this.verifier.readState(buffers.stateBuffer, 256);

                this.updateRegisterDisplay();

                if (this.state.halted) {
                    this.log('Execution halted (ECALL/EBREAK)');
                    break;
                }
            }

            document.getElementById('status').textContent = 'Execution complete';
        } catch (error) {
            this.log(`Error: ${error.message}`);
            document.getElementById('status').textContent = 'Execution failed';
        }
    }

    async step() {
        // Execute single instruction (need shader modification or workaround)
        this.log('Step mode not yet implemented - use Execute');
    }

    reset() {
        this.currentProgram = null;
        this.state = null;
        document.getElementById('btn-execute').disabled = true;
        document.getElementById('btn-step').disabled = true;
        document.getElementById('btn-reset').disabled = true;
        document.getElementById('status').textContent = 'Reset - no program loaded';
        this.renderRegisterGrid(); // Reset display
        this.log('Reset complete');
    }

    updateRegisterDisplay() {
        if (!this.state) return;

        for (let i = 0; i < 32; i++) {
            const el = document.getElementById(`reg-${i}`);
            if (el) {
                el.textContent = `0x${this.state.registers[i].toString(16).padStart(8, '0')}`;
            }
        }

        const pcEl = document.getElementById('reg-pc');
        if (pcEl) {
            pcEl.textContent = `0x${(this.state.pc * 4).toString(16).padStart(8, '0')}`;
        }
    }

    async readMemory() {
        const addrInput = document.getElementById('mem-address').value;
        const addr = parseInt(addrInput, 16);

        if (isNaN(addr)) {
            document.getElementById('memory-output').textContent = 'Invalid address';
            return;
        }

        // Read 16 words starting at address
        const output = document.getElementById('memory-output');
        output.textContent = 'Reading...';

        try {
            // Use verifier to read memory
            const data = await this.verifier.readMemory(/* buffer */, addr, 64);
            let text = '';
            for (let i = 0; i < 16; i++) {
                text += `0x${(addr + i * 4).toString(16)}: 0x${data[i].toString(16).padStart(8, '0')}\n`;
            }
            output.textContent = text;
        } catch (error) {
            output.textContent = `Error: ${error.message}`;
        }
    }

    log(message) {
        const logEl = document.getElementById('log');
        const time = new Date().toLocaleTimeString();
        logEl.innerHTML += `<div>[${time}] ${message}</div>`;
        logEl.scrollTop = logEl.scrollHeight;
    }

    async dispatchExecute(buffers) {
        // Create compute pass and dispatch
        // Uses the shader pipeline from visual_cpu_riscv.wgsl
        // ... WebGPU dispatch code ...
    }
}
```

The panel MUST include:
- Program input (hex instructions with comments)
- Load/Execute/Reset buttons
- Register display (x0-x31 + PC)
- Memory inspector
- Execution log

DO use CoreExecutionVerifier for state readback.
DO show byte addresses for PC (multiply by 4).
  </action>
  <verify>
grep -c "class RiscvExecutionPanel\|loadProgram\|execute\|updateRegisterDisplay" systems/visual_shell/web/RiscvExecutionPanel.js
  </verify>
  <done>
RiscvExecutionPanel.js exists with program loading, execution, register display, and memory inspector functionality.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create demo page with execution panel</name>
  <files>systems/visual_shell/web/demo_riscv_execution.html</files>
  <action>
Create a demo HTML page that hosts the RiscvExecutionPanel.

```html
<!DOCTYPE html>
<html>
<head>
    <title>RISC-V GPU Execution Demo - Phase 17</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #0f0f1a;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
        }
        .riscv-panel {
            max-width: 1000px;
            margin: 0 auto;
        }
        h2 { color: #60a5fa; border-bottom: 1px solid #334155; padding-bottom: 10px; }
        h3 { color: #94a3b8; margin-top: 20px; }
        .section {
            background: #1e1e2e;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        textarea {
            width: 100%;
            background: #0f0f1a;
            color: #4ade80;
            border: 1px solid #334155;
            border-radius: 4px;
            padding: 10px;
            font-family: inherit;
            font-size: 14px;
        }
        button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
        }
        button:hover { background: #2563eb; }
        button:disabled { background: #475569; cursor: not-allowed; }
        .registers .reg {
            display: inline-block;
            width: 220px;
            margin: 4px;
            padding: 4px 8px;
            background: #16213e;
            border-radius: 4px;
        }
        .reg-name { color: #94a3b8; font-size: 12px; }
        .reg-value { color: #4ade80; float: right; font-size: 12px; }
        .reg.special { background: #1e3a5f; }
        .reg.special .reg-value { color: #f59e0b; }
        #status { padding: 10px; color: #fbbf24; }
        #log {
            background: #0f0f1a;
            border: 1px solid #334155;
            border-radius: 4px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
        }
        #memory-output {
            background: #0f0f1a;
            border: 1px solid #334155;
            border-radius: 4px;
            padding: 10px;
            font-size: 12px;
            white-space: pre;
            max-height: 300px;
            overflow-y: auto;
        }
        input[type="text"] {
            background: #0f0f1a;
            color: #e0e0e0;
            border: 1px solid #334155;
            border-radius: 4px;
            padding: 8px;
            font-family: inherit;
        }
        .note {
            background: #1e3a5f;
            border-left: 3px solid #3b82f6;
            padding: 10px;
            margin: 10px 0;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div id="panel-container"></div>

    <div class="note">
        <strong>Phase 17 Demo:</strong> This panel demonstrates GPU-based RISC-V RV32I execution.
        Enter hex instructions, load, and execute to see register state changes.
        <br><br>
        <strong>Success Criteria:</strong>
        <ol>
            <li>Load example program and click Execute</li>
            <li>Verify x1 = 0x0000000a (10)</li>
            <li>Verify x2 = 0x00000020 (32)</li>
            <li>Verify x3 = 0x0000002a (42) - the sum!</li>
        </ol>
    </div>

    <script type="module">
        import { RiscvExecutionPanel } from './RiscvExecutionPanel.js';

        async function init() {
            if (!navigator.gpu) {
                document.getElementById('panel-container').innerHTML =
                    '<div class="section" style="color: #f87171;">WebGPU not supported in this browser. Try Chrome 113+ or Edge 113+.</div>';
                return;
            }

            try {
                const adapter = await navigator.gpu.requestAdapter();
                const device = await adapter.requestDevice();
                const queue = device.queue;

                const container = document.getElementById('panel-container');
                new RiscvExecutionPanel(container, device, queue);
            } catch (error) {
                document.getElementById('panel-container').innerHTML =
                    `<div class="section" style="color: #f87171;">WebGPU initialization failed: ${error.message}</div>`;
            }
        }

        init();
    </script>
</body>
</html>
```

The page MUST:
- Initialize WebGPU and create the execution panel
- Display clear success criteria for Phase 17 verification
- Handle WebGPU errors gracefully

DO include visual styling consistent with the Geometry OS dark theme.
DO show the example program pre-loaded or one click away.
  </action>
  <verify>
ls -la systems/visual_shell/web/demo_riscv_execution.html
  </verify>
  <done>
demo_riscv_execution.html exists and displays RiscvExecutionPanel with example program and success criteria.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Phase 17 visual execution system:
- CoreExecutionVerifier.js (async state readback)
- visual_cpu_riscv.wgsl (complete RV32I instructions)
- test_riscv_core.js (test suite)
- RiscvExecutionPanel.js (UI)
- demo_riscv_execution.html (demo page)</what-built>
  <how-to-verify>
1. Open systems/visual_shell/web/demo_riscv_execution.html in Chrome 113+ or Edge 113+
2. Click "Load Example" to load the ADD program
3. Click "Execute" to run on GPU
4. Verify the following register values:
   - x1 (t0) = 0x0000000a (10)
   - x2 (t1) = 0x00000020 (32)
   - x3 (t2) = 0x0000002a (42) - This proves ADD worked!
5. Optionally: Open test_riscv_core.html and verify all tests pass
  </how-to-verify>
  <resume-signal>Type "approved" if x3=42, or describe what failed</resume-signal>
</task>

</tasks>

<verification>
After completing all tasks:
1. Open demo_riscv_execution.html in WebGPU browser
2. Load example program
3. Execute and verify x3 = 42
4. Optionally run full test suite in test_riscv_core.html
</verification>

<success_criteria>
1. User can load RISC-V program via hex input
2. User can execute program on GPU
3. User can see registers update after execution
4. Example program (10 + 32) produces x3 = 42
5. Memory inspector can read GPU memory
6. Execution log shows status messages
</success_criteria>

<output>
After completion, create `.planning/phases/17-core-execution-foundation/17-04-SUMMARY.md`
</output>
