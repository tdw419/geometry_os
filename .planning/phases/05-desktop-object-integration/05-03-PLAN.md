---
phase: 05-desktop-object-integration
plan: 03
type: execute
wave: 3
depends_on:
  - 05-01
  - 05-02
files_modified:
  - systems/visual_shell/web/CatalogBridge.js
  - systems/visual_shell/web/RTSDesktopObject.js
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Layout persistence works - drag saves position to server"
    - "Catalog entries appear at correct positions after refresh"
    - "Boot sends correct options to server"
  artifacts:
    - path: "systems/visual_shell/web/CatalogBridge.js"
      provides: "Correct API endpoint calls with proper body formats"
      contains: ["new_position", "position.x"]
    - path: "systems/visual_shell/web/RTSDesktopObject.js"
      provides: "Correct field access for position data"
      contains: ["entry.position"]
  key_links:
    - from: "CatalogBridge.updateLayout()"
      to: "/api/v1/catalog/layout"
      via: "POST with {entry_id, new_position}"
      pattern: "entry_id.*new_position"
    - from: "CatalogBridge.getCatalog()"
      to: "RTSDesktopObject"
      via: "maps position.x/y to layout.gridX/gridY"
      pattern: "position\\.x|gridX"
    - from: "CatalogBridge.bootEntry()"
      to: "/api/v1/catalog/{id}/boot"
      via: "POST with {memory, cpus, cmdline}"
      pattern: "memory.*cpus"
---

<objective>
Fix API wiring mismatches between client and server. The components exist but the API calls use wrong endpoints, wrong field names, and wrong body formats. This plan aligns CatalogBridge to match the server's actual API contract.

Purpose: Enable drag persistence and boot functionality by fixing the API wiring.
Output: Updated CatalogBridge.js with correct endpoints and body formats, updated RTSDesktopObject.js with correct field access
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing implementations to fix
@systems/visual_shell/web/CatalogBridge.js
@systems/visual_shell/web/RTSDesktopObject.js

# Server API contract (source of truth)
@systems/pixel_compiler/catalog/catalog_server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix CatalogBridge.updateLayout() endpoint and body format</name>
  <files>systems/visual_shell/web/CatalogBridge.js</files>
  <action>
Fix the updateLayout method to use the correct server endpoint and body format.

**Current (wrong):**
```javascript
async updateLayout(entryId, position) {
    const data = await this._fetch(`/api/v1/catalog/${encodeURIComponent(entryId)}/layout`, {
        method: 'POST',
        body: JSON.stringify(position)  // Sends {gridX, gridY}
    });
    return data;
}
```

**Correct (matches server):**
```javascript
async updateLayout(entryId, position) {
    // Server expects: POST /api/v1/catalog/layout
    // Body: { entry_id: string, new_position: { x: number, y: number } }
    const data = await this._fetch('/api/v1/catalog/layout', {
        method: 'POST',
        body: JSON.stringify({
            entry_id: entryId,
            new_position: {
                x: position.gridX,
                y: position.gridY
            }
        })
    });
    return data;
}
```

Key changes:
1. Endpoint: `/api/v1/catalog/{entryId}/layout` -> `/api/v1/catalog/layout`
2. Body: `{gridX, gridY}` -> `{entry_id, new_position: {x, y}}`
3. Field mapping: gridX -> x, gridY -> y (inside new_position object)

Reference: catalog_server.py line 49-52 (LayoutUpdate model) and line 419-455 (endpoint)
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/CatalogBridge.js', 'utf8'); console.log(code.includes('new_position') && code.includes(\"'/api/v1/catalog/layout'\") ? 'OK' : 'FAIL')"</verify>
  <done>updateLayout() sends correct endpoint and body format to server</done>
</task>

<task type="auto">
  <name>Task 2: Fix CatalogBridge.getCatalog() to map position fields</name>
  <files>systems/visual_shell/web/CatalogBridge.js</files>
  <action>
Add field mapping in getCatalog() to transform server response format to client format.

Server returns:
```json
{
  "entries": [
    {
      "id": "ubuntu-22.04",
      "name": "Ubuntu 22.04",
      "position": {"x": 0, "y": 0},
      ...
    }
  ]
}
```

Client expects (in RTSDesktopObject):
```javascript
entry.layout = { gridX: 0, gridY: 0 }
```

Add mapping in getCatalog():
```javascript
async getCatalog() {
    const data = await this._fetch('/api/v1/catalog');

    if (data && data.entries) {
        this.lastFetchTime = Date.now();

        // Map server position format to client layout format
        data.entries = data.entries.map(entry => ({
            ...entry,
            layout: {
                gridX: entry.position?.x || 0,
                gridY: entry.position?.y || 0
            }
        }));

        this.cachedCatalog = data;
    }

    return data;
}
```

This ensures RTSDesktopObject can read `entry.layout.gridX` and `entry.layout.gridY` which it expects in the constructor (lines 78-84).
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/CatalogBridge.js', 'utf8'); console.log(code.includes('entry.position') && code.includes('gridX') && code.includes('gridY') ? 'OK' : 'FAIL')"</verify>
  <done>getCatalog() maps server position.x/y to client layout.gridX/gridY</done>
</task>

<task type="auto">
  <name>Task 3: Fix CatalogBridge.bootEntry() options format</name>
  <files>systems/visual_shell/web/CatalogBridge.js</files>
  <action>
Fix bootEntry() to send correct options format expected by server.

**Current (wrong):**
```javascript
async bootEntry(entryId, options = {}) {
    // Currently sends whatever is passed: {mode, headless}
    const data = await this._fetch(`/api/v1/catalog/${encodeURIComponent(entryId)}/boot`, {
        method: 'POST',
        body: JSON.stringify(options)
    });
    return data;
}
```

**Server expects (catalog_server.py line 42-46):**
```python
class BootOptions(BaseModel):
    memory: str = "2G"
    cpus: int = 2
    cmdline: Optional[str] = None
```

**Fix:**
```javascript
async bootEntry(entryId, options = {}) {
    // Server expects: { memory: string, cpus: number, cmdline?: string }
    // Transform generic options to server format
    const bootOptions = {
        memory: options.memory || '2G',
        cpus: options.cpus || 2,
        cmdline: options.cmdline || null
    };

    const data = await this._fetch(`/api/v1/catalog/${encodeURIComponent(entryId)}/boot`, {
        method: 'POST',
        body: JSON.stringify(bootOptions)
    });

    return data;
}
```

Also update the JSDoc to reflect correct options:
```javascript
/**
 * Boot a catalog entry (start the container)
 * @param {string} entryId - The entry ID to boot
 * @param {Object} options - Boot options
 * @param {string} options.memory - Memory allocation (default: '2G')
 * @param {number} options.cpus - CPU count (default: 2)
 * @param {string} options.cmdline - Kernel command line (optional)
 * @returns {Promise<Object|null>} Boot result with status and VM info, or null on failure
 */
```
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/CatalogBridge.js', 'utf8'); console.log(code.includes(\"memory: options.memory\") && code.includes(\"cpus: options.cpus\") ? 'OK' : 'FAIL')"</verify>
  <done>bootEntry() sends correct {memory, cpus, cmdline} format to server</done>
</task>

<task type="auto">
  <name>Task 4: Update RTSDesktopObject to use entry.position as fallback</name>
  <files>systems/visual_shell/web/RTSDesktopObject.js</files>
  <action>
Update RTSDesktopObject constructor to handle both `entry.layout` (mapped by CatalogBridge) and `entry.position` (direct from server) for robustness.

Current constructor (lines 77-84):
```javascript
if (entry.layout) {
    this.gridX = entry.layout.gridX || 0;
    this.gridY = entry.layout.gridY || 0;
} else {
    this.gridX = 0;
    this.gridY = 0;
}
```

Update to handle both formats:
```javascript
// Calculate position from grid - support both layout (mapped) and position (direct)
if (entry.layout) {
    this.gridX = entry.layout.gridX || 0;
    this.gridY = entry.layout.gridY || 0;
} else if (entry.position) {
    // Fallback: direct server format
    this.gridX = entry.position.x || 0;
    this.gridY = entry.position.y || 0;
} else {
    this.gridX = 0;
    this.gridY = 0;
}
```

Also update updateEntry() method (lines 584-586):
```javascript
if (entry.layout) {
    this.setGridPosition(entry.layout.gridX || 0, entry.layout.gridY || 0);
} else if (entry.position) {
    // Fallback: direct server format
    this.setGridPosition(entry.position.x || 0, entry.position.y || 0);
}
```

This provides defense-in-depth: CatalogBridge maps the fields, but RTSDesktopObject can also handle raw server data.
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/RTSDesktopObject.js', 'utf8'); console.log(code.includes('entry.position') ? 'OK' : 'FAIL')"</verify>
  <done>RTSDesktopObject handles both entry.layout and entry.position formats</done>
</task>

</tasks>

<verification>
- [ ] CatalogBridge.updateLayout() POSTs to /api/v1/catalog/layout (not /{id}/layout)
- [ ] CatalogBridge.updateLayout() sends {entry_id, new_position: {x, y}} body
- [ ] CatalogBridge.getCatalog() maps position.x/y to layout.gridX/gridY
- [ ] CatalogBridge.bootEntry() sends {memory, cpus, cmdline} body
- [ ] RTSDesktopObject handles entry.position as fallback
</verification>

<success_criteria>
- Drag persistence works: position saved to server on drag end
- Page refresh shows objects at saved positions
- Boot sends correct options format (no more 400 errors from server)
- Components work with both mapped (layout) and direct (position) formats
</success_criteria>

<output>
After completion, create `.planning/phases/05-desktop-object-integration/05-03-SUMMARY.md`
</output>
