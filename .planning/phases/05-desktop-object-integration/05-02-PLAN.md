---
phase: 05-desktop-object-integration
plan: 02
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - systems/visual_shell/web/RTSDesktopObject.js
  - systems/visual_shell/web/DesktopObjectManager.js
autonomous: true

must_haves:
  truths:
    - "User can drag desktop objects to new positions on the canvas"
    - "Object positions persist after page refresh"
    - "User can double-click an object to boot the container"
    - "Boot status is visually indicated (idle -> booting -> running/error)"
  artifacts:
    - path: "systems/visual_shell/web/RTSDesktopObject.js"
      provides: "Drag-and-drop and click-to-boot interaction"
      contains: ["onpointerdown", "onpointermove", "onpointerup", "ondblclick"]
    - path: "systems/visual_shell/web/DesktopObjectManager.js"
      provides: "Drag event coordination and boot orchestration"
      contains: ["_handleDragStart", "_handleBoot"]
  key_links:
    - from: "RTSDesktopObject.js"
      to: "CatalogBridge.updateLayout()"
      via: "position save on drag end"
      pattern: "updateLayout"
    - from: "RTSDesktopObject.js"
      to: "CatalogBridge.bootEntry()"
      via: "double-click handler"
      pattern: "bootEntry"
---

<objective>
Add interactive behaviors to desktop objects: drag-and-drop for repositioning and double-click to boot. This plan extends the visual foundation from 05-01 with user interaction handlers.

Purpose: Enable users to organize their container desktop spatially and boot containers with a simple gesture.
Output: Updated RTSDesktopObject.js with drag/boot handlers, updated DesktopObjectManager.js with event coordination
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Foundation from 05-01
@systems/visual_shell/web/RTSDesktopObject.js
@systems/visual_shell/web/CatalogBridge.js
@systems/visual_shell/web/DesktopObjectManager.js

# Reference patterns
@systems/visual_shell/web/WindowParticle.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement drag-and-drop for RTSDesktopObject</name>
  <files>systems/visual_shell/web/RTSDesktopObject.js</files>
  <action>
Add PIXI drag interaction to RTSDesktopObject class. Implement pointer events for drag-and-drop with visual feedback.

Add to constructor:
```javascript
// Drag state
this.dragging = false;
this.dragData = null;
this.dragOffset = { x: 0, y: 0 };

// Setup drag events
this.on('pointerdown', this._onDragStart, this);
this.on('pointermove', this._onDragMove, this);
this.on('pointerup', this._onDragEnd, this);
this.on('pointerupoutside', this._onDragEnd, this);
```

Add methods:
```javascript
_onDragStart(event) {
    // Only respond to left-click (button 0)
    if (event.data.button !== 0) return;

    this.dragging = true;
    this.dragData = event.data;
    this.dragOffset = {
        x: this.dragData.global.x - this.x,
        y: this.dragData.global.y - this.y
    };

    // Visual feedback
    this.alpha = 0.7;
    this.cursor = 'grabbing';

    // Bring to front
    if (this.parent) {
        this.parent.sortableChildren = true;
        this.zIndex = 1000;
    }

    // Emit event for manager
    this.emit('drag-start', { entryId: this.entryId });
}

_onDragMove(event) {
    if (!this.dragging) return;

    const newPosition = this.dragData.global;
    this.x = newPosition.x - this.dragOffset.x;
    this.y = newPosition.y - this.dragOffset.y;

    this.emit('drag-move', { entryId: this.entryId, x: this.x, y: this.y });
}

_onDragEnd(event) {
    if (!this.dragging) return;

    this.dragging = false;
    this.dragData = null;
    this.alpha = 1.0;
    this.cursor = 'pointer';
    this.zIndex = 0;

    this.emit('drag-end', { entryId: this.entryId, x: this.x, y: this.y });
}
```

Important:
- Use `event.data.global` for world coordinates (not local)
- Emit events for DesktopObjectManager to handle persistence
- Restore visual state after drag ends
- Handle pointerupoutside for when drag ends outside object bounds
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/RTSDesktopObject.js', 'utf8'); console.log(code.includes('_onDragStart') && code.includes('_onDragEnd') && code.includes('dragging = false') ? 'OK' : 'FAIL')"</verify>
  <done>RTSDesktopObject responds to pointer drag events with visual feedback and position updates</done>
</task>

<task type="auto">
  <name>Task 2: Wire drag events to position persistence via CatalogBridge</name>
  <files>systems/visual_shell/web/DesktopObjectManager.js</files>
  <action>
Update DesktopObjectManager to listen for drag-end events and persist positions via CatalogBridge.

Add to createObject():
```javascript
// Listen for drag events
obj.on('drag-start', (e) => this._handleDragStart(e));
obj.on('drag-move', (e) => this._handleDragMove(e));
obj.on('drag-end', (e) => this._handleDragEnd(e));
```

Add methods:
```javascript
_handleDragStart(event) {
    // Optional: Show grid snap guides or highlight drop zones
    this.emit('object-drag-start', event);
}

_handleDragMove(event) {
    // Update spatial index during drag
    this._updateSpatialIndex(event.entryId, event.x, event.y);
}

async _handleDragEnd(event) {
    const { entryId, x, y } = event;

    // Convert world coords back to grid coords
    const gridX = Math.round(x / 160);
    const gridY = Math.round(y / 200);

    // Persist via CatalogBridge
    try {
        await this.bridge.updateLayout(entryId, { x: gridX, y: gridY });
        console.log(`[DesktopObjectManager] Saved position for ${entryId}: (${gridX}, ${gridY})`);
    } catch (err) {
        console.error('[DesktopObjectManager] Failed to save position:', err);
        // Optionally: revert object position on failure
    }

    this.emit('object-moved', { entryId, gridX, gridY });
}

_updateSpatialIndex(entryId, x, y) {
    // Update the spatial index for fast lookup
    this.spatialIndex.set(entryId, { x, y });
}
```

Coordinate conversion notes:
- World to grid: gridX = round(x / 160), gridY = round(y / 200)
- Grid to world (existing): x = gridX * 160, y = gridY * 200
- Round to nearest grid cell for snap-to-grid behavior
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/DesktopObjectManager.js', 'utf8'); console.log(code.includes('_handleDragEnd') && code.includes('updateLayout') ? 'OK' : 'FAIL')"</verify>
  <done>Object positions are persisted to catalog server when drag ends</done>
</task>

<task type="auto">
  <name>Task 3: Implement click-to-boot with status updates</name>
  <files>systems/visual_shell/web/RTSDesktopObject.js, systems/visual_shell/web/DesktopObjectManager.js</files>
  <action>
Add double-click handler to RTSDesktopObject to trigger boot, with visual status updates.

**In RTSDesktopObject.js:**

Add to constructor:
```javascript
// Boot status: 'idle' | 'booting' | 'running' | 'error'
this.bootStatus = 'idle';

// Double-click to boot
this.on('dblclick', this._onDoubleClick, this);

// Click to select (single click)
this.on('click', this._onClick, this);
```

Add methods:
```javascript
_onClick(event) {
    // Select this object
    this.emit('selected', { entryId: this.entryId, entry: this.entryData });
}

_onDoubleClick(event) {
    // Request boot
    this.emit('boot-requested', { entryId: this.entryId, entry: this.entryData });
}

setStatus(status) {
    this.bootStatus = status;

    // Update status indicator color
    const colors = {
        'idle': 0x888888,      // Gray
        'booting': 0xffcc00,   // Yellow (animated pulse)
        'running': 0x00ff00,   // Green
        'error': 0xff0000      // Red
    };

    const color = colors[status] || colors['idle'];
    this.statusIndicator.clear();
    this.statusIndicator.circle(6, 6, 6);
    this.statusIndicator.fill({ color });

    // Add pulse animation for booting
    if (status === 'booting') {
        this._startPulse();
    } else {
        this._stopPulse();
    }
}

_startPulse() {
    // Simple alpha pulse using PIXI ticker
    this._pulsePhase = 0;
    this._pulseCallback = () => {
        this._pulsePhase += 0.1;
        this.statusIndicator.alpha = 0.5 + 0.5 * Math.sin(this._pulsePhase);
    };
    PIXI.Ticker.shared.add(this._pulseCallback);
}

_stopPulse() {
    if (this._pulseCallback) {
        PIXI.Ticker.shared.remove(this._pulseCallback);
        this._pulseCallback = null;
    }
    this.statusIndicator.alpha = 1;
}
```

**In DesktopObjectManager.js:**

Add to createObject():
```javascript
// Listen for boot request
obj.on('boot-requested', (e) => this._handleBootRequest(e));
```

Add method:
```javascript
async _handleBootRequest(event) {
    const { entryId, entry } = event;
    const obj = this.objects.get(entryId);

    if (!obj) return;

    // Update status to booting
    obj.setStatus('booting');

    try {
        const result = await this.bridge.bootEntry(entryId, {
            memory: entry.metadata?.memory || 512,
            cpus: entry.metadata?.cpus || 1
        });

        console.log(`[DesktopObjectManager] Boot started for ${entryId}:`, result);

        // Poll for status or wait for WebSocket update
        // For now, assume success after boot call
        obj.setStatus('running');

        this.emit('object-booted', { entryId, result });
    } catch (err) {
        console.error(`[DesktopObjectManager] Boot failed for ${entryId}:`, err);
        obj.setStatus('error');

        this.emit('boot-error', { entryId, error: err.message });
    }
}
```

Status lifecycle:
1. idle -> booting (on double-click)
2. booting -> running (on success)
3. booting -> error (on failure)
4. error -> idle (user retries)
</action>
  <verify>node -e "const fs = require('fs'); const code1 = fs.readFileSync('systems/visual_shell/web/RTSDesktopObject.js', 'utf8'); const code2 = fs.readFileSync('systems/visual_shell/web/DesktopObjectManager.js', 'utf8'); console.log(code1.includes('boot-requested') && code1.includes('setStatus') && code2.includes('_handleBootRequest') ? 'OK' : 'FAIL')"</verify>
  <done>Double-click triggers boot with visual status indicator (idle -> booting -> running/error)</done>
</task>

</tasks>

<verification>
- [ ] RTSDesktopObject has drag event handlers (pointerdown, pointermove, pointerup)
- [ ] Drag changes object position with visual feedback (alpha change)
- [ ] DesktopObjectManager persists position via CatalogBridge.updateLayout()
- [ ] RTSDesktopObject has double-click handler for boot
- [ ] Status indicator changes color based on boot state
- [ ] Booting state shows animated pulse
</verification>

<success_criteria>
- User can drag objects to new positions on canvas
- Object positions persist after page refresh (via updateLayout API call)
- User can double-click object to initiate boot
- Status indicator shows boot progress (idle -> booting -> running/error)
- Boot errors are logged and shown with red status
</success_criteria>

<output>
After completion, create `.planning/phases/05-desktop-object-integration/05-02-SUMMARY.md`
</output>
