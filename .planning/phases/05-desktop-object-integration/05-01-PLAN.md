---
phase: 05-desktop-object-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - systems/visual_shell/web/RTSDesktopObject.js
  - systems/visual_shell/web/CatalogBridge.js
  - systems/visual_shell/web/DesktopObjectManager.js
autonomous: true

must_haves:
  truths:
    - "RTSDesktopObject displays .rts.png containers as sprites on infinite canvas"
    - "CatalogBridge fetches catalog entries from /api/v1/catalog endpoint"
    - "DesktopObjectManager creates and tracks RTSDesktopObject instances"
    - "Objects appear at their saved positions from SpatialLayoutManager"
    - "Objects are clickable and show hover state"
  artifacts:
    - path: "systems/visual_shell/web/RTSDesktopObject.js"
      provides: "Desktop object sprite with metadata display"
      exports: ["RTSDesktopObject"]
      min_lines: 100
    - path: "systems/visual_shell/web/CatalogBridge.js"
      provides: "API client for catalog server"
      exports: ["CatalogBridge"]
      min_lines: 60
    - path: "systems/visual_shell/web/DesktopObjectManager.js"
      provides: "Lifecycle management for desktop objects"
      exports: ["DesktopObjectManager"]
      min_lines: 80
  key_links:
    - from: "RTSDesktopObject.js"
      to: "WindowParticle.js"
      via: "extends PIXI.Container pattern"
      pattern: "extends PIXI.Container|PIXI.Sprite"
    - from: "CatalogBridge.js"
      to: "catalog_server.py"
      via: "fetch /api/v1/catalog"
      pattern: "fetch.*api/v1/catalog"
    - from: "DesktopObjectManager.js"
      to: "ParticleManager.js"
      via: "pattern reuse for particle tracking"
      pattern: "particles\\.set|spatialIndex"
---

<objective>
Create the foundation components for displaying .rts.png containers as interactive desktop objects on the infinite canvas. This plan creates RTSDesktopObject (the visual sprite), CatalogBridge (API client), and DesktopObjectManager (lifecycle manager).

Purpose: Enable users to see their OS containers directly on the visual shell desktop, not in a separate catalog tab. This bridges the existing Catalog Server (v1.0) with the existing PixiJS infinite desktop.
Output: RTSDesktopObject.js, CatalogBridge.js, DesktopObjectManager.js
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md

# Reference patterns
@systems/visual_shell/web/WindowParticle.js
@systems/visual_shell/web/ParticleManager.js
@systems/pixel_compiler/catalog/catalog_server.py
@systems/pixel_compiler/catalog/spatial_layout.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CatalogBridge API client</name>
  <files>systems/visual_shell/web/CatalogBridge.js</files>
  <action>
Create a vanilla JS class that communicates with the catalog server.

```javascript
class CatalogBridge {
    constructor(baseUrl = 'http://localhost:8080') {
        this.baseUrl = baseUrl;
    }

    async getCatalog() {
        // GET /api/v1/catalog
        // Returns { entries: [...], grid_dimensions: {...} }
    }

    async bootEntry(entryId, options = {}) {
        // POST /api/v1/catalog/{entryId}/boot
        // Body: { memory, cpus, cmdline }
    }

    async updateLayout(entryId, position) {
        // POST /api/v1/catalog/layout
        // Body: { entry_id, new_position: {x, y} }
    }

    async refresh() {
        // GET /api/v1/catalog/refresh
    }
}
```

Implementation details:
- Use native `fetch()` API (no dependencies)
- Handle network errors gracefully with try/catch
- Return `null` on failure, log errors to console
- Add 5-second timeout for requests
- Export as ES6 module and attach to window for legacy use
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/CatalogBridge.js', 'utf8'); console.log(code.includes('class CatalogBridge') && code.includes('getCatalog') ? 'OK' : 'FAIL')"</verify>
  <done>CatalogBridge fetches catalog data from API with error handling</done>
</task>

<task type="auto">
  <name>Task 2: Create RTSDesktopObject component</name>
  <files>systems/visual_shell/web/RTSDesktopObject.js</files>
  <action>
Create a PIXI.Container-based component that displays a .rts.png container as a desktop object.

```javascript
class RTSDesktopObject extends PIXI.Container {
    constructor(entry, options = {}) {
        // entry: CatalogEntry from API (id, name, path, thumbnail, position, metadata)
        super();

        this.entryId = entry.id;
        this.entryData = entry;

        // Visual elements:
        // 1. Thumbnail sprite (from base64 thumbnail)
        // 2. Name label (PIXI.Text)
        // 3. Status indicator (PIXI.Graphics circle)
        // 4. Hover highlight (PIXI.Graphics rectangle)

        // Make interactive
        this.eventMode = 'static';
        this.cursor = 'pointer';

        // Events: pointerover, pointerout, pointerdown, dblclick
    }

    // Methods:
    // - _loadThumbnail(base64) - create sprite from base64
    // - setHighlighted(bool) - show/hide hover state
    // - setStatus(status) - 'idle'|'booting'|'running'|'error'
    // - getPosition() - return {x, y}
    // - serialize() - return state for persistence
}
```

Visual design:
- Thumbnail: 128x128 pixels (scaled from 256x256 API thumbnail)
- Name label: below thumbnail, max 2 lines, centered, white text
- Status indicator: 12px circle in top-right corner (gray=idle, yellow=booting, green=running, red=error)
- Background: dark semi-transparent (0x1a1a1a, 0.9 alpha)
- Hover: add cyan border (0x00ffff, 2px)
- Total size: approximately 140x180 pixels

Follow WindowParticle.js pattern for PIXI.Container structure.
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/RTSDesktopObject.js', 'utf8'); console.log(code.includes('extends PIXI.Container') && code.includes('setStatus') ? 'OK' : 'FAIL')"</verify>
  <done>RTSDesktopObject displays thumbnail, name, status as interactive sprite</done>
</task>

<task type="auto">
  <name>Task 3: Create DesktopObjectManager for lifecycle management</name>
  <files>systems/visual_shell/web/DesktopObjectManager.js</files>
  <action>
Create a manager class that creates, tracks, and destroys RTSDesktopObject instances.

```javascript
class DesktopObjectManager {
    constructor(worldContainer, catalogBridge, options = {}) {
        this.worldContainer = worldContainer;
        this.bridge = catalogBridge;
        this.objects = new Map(); // entryId -> RTSDesktopObject

        // Dedicated layer for desktop objects
        this.objectLayer = new PIXI.Container();
        this.objectLayer.label = 'desktopObjectLayer';
        this.objectLayer.sortableChildren = true;
        this.worldContainer.addChild(this.objectLayer);

        // Spatial index (reuse ParticleManager pattern)
        this.spatialIndex = new Map();
    }

    async loadCatalog() {
        // Fetch catalog from bridge
        // Create RTSDesktopObject for each entry
        // Position based on entry.position (convert grid to world coords)
    }

    createObject(entry) {
        // Create RTSDesktopObject
        // Add to objectLayer
        // Track in objects Map
        // Setup event listeners
    }

    removeObject(entryId) {
        // Destroy and remove from tracking
    }

    getObjectAtPosition(x, y) {
        // Find object at world coordinates
    }

    serialize() {
        // Return all object states
    }
}
```

Grid-to-world coordinate conversion:
- Grid position (x, y) from API maps to world coords
- Use 160px spacing (140px object + 20px gap)
- World X = grid.x * 160
- World Y = grid.y * 200 (extra vertical space for labels)

Event handling:
- Listen to RTSDesktopObject events
- Emit 'object-selected', 'object-booted', 'object-moved'
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/DesktopObjectManager.js', 'utf8'); console.log(code.includes('class DesktopObjectManager') && code.includes('loadCatalog') ? 'OK' : 'FAIL')"</verify>
  <done>DesktopObjectManager creates and manages desktop objects from catalog</done>
</task>

</tasks>

<verification>
- [ ] CatalogBridge fetches from /api/v1/catalog endpoint
- [ ] RTSDesktopObject extends PIXI.Container with thumbnail sprite
- [ ] RTSDesktopObject shows hover state on pointerover
- [ ] DesktopObjectManager creates objects from catalog entries
- [ ] Objects positioned at grid-based world coordinates
</verification>

<success_criteria>
- CatalogBridge successfully fetches catalog data from running catalog server
- RTSDesktopObject displays thumbnail, name label, and status indicator
- DesktopObjectManager loads all catalog entries as desktop objects
- Objects appear on infinite canvas at correct positions
- Hover interaction shows visual feedback
</success_criteria>

<output>
After completion, create `.planning/phases/05-desktop-object-integration/05-01-SUMMARY.md`
</output>
