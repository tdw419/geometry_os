---
phase: 18-privileged-architecture
plan: 03
type: execute
wave: 3
depends_on: [18-02]
files_modified:
  - systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can see traps route to M-mode handler when appropriate"
    - "User can see traps delegated to S-mode when medeleg/mideleg configured"
    - "User can see M-mode trap state saved correctly (mepc, mcause, mtval)"
    - "User can execute code that transitions M-mode to S-mode"
  artifacts:
    - path: "systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl"
      provides: "M-mode trap handling and delegation"
      contains: "trap_enter_mmode"
      contains: "should_delegate_to_smode"
  key_links:
    - from: "trap conditions"
      to: "medeleg/mideleg"
      via: "delegation check"
      pattern: "CSR_MEDELEG"
---

<objective>
Implement M-mode trap handling and trap delegation

Purpose: Linux kernel requires traps to be handled at appropriate privilege levels. M-mode traps are needed for firmware/opensbi, and delegation allows S-mode to handle its own exceptions.
Output: M-mode trap enter function, delegation logic
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-privileged-architecture/18-RESEARCH.md
@.planning/phases/18-privileged-architecture/18-02-SUMMARY.md

# Reference the existing shader for patterns
@systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement trap_enter_mmode function</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
Add a new trap_enter_mmode function after the existing trap_enter function (around line 170).
This mirrors trap_enter but uses M-mode CSRs instead of S-mode CSRs:

```wgsl
// Enter M-mode trap handler
// Saves PC to MEPC, sets MCAUSE/MTVAL, updates MSTATUS, jumps to MTVEC
fn trap_enter_mmode(base_idx: u32, cause: u32, tval: u32, pc: u32) -> u32 {
    // 1. Save exception PC to MEPC
    cpu_states[base_idx + CSR_MEPC] = pc;

    // 2. Set exception cause
    cpu_states[base_idx + CSR_MCAUSE] = cause;

    // 3. Set trap value (faulting address)
    cpu_states[base_idx + CSR_MTVAL] = tval;

    // 4. Update MSTATUS
    let current_mode = cpu_states[base_idx + CSR_MODE];
    let current_mstatus = cpu_states[base_idx + CSR_MSTATUS];

    var new_mstatus = current_mstatus;

    // Copy MIE to MPIE
    if ((current_mstatus & MSTATUS_MIE) != 0u) {
        new_mstatus = new_mstatus | MSTATUS_MPIE;
    } else {
        new_mstatus = new_mstatus & ~MSTATUS_MPIE;
    }

    // Clear MIE (disable interrupts)
    new_mstatus = new_mstatus & ~MSTATUS_MIE;

    // Save current mode to MPP (bits 12:11)
    new_mstatus = new_mstatus & ~MSTATUS_MPP_MASK;
    new_mstatus = new_mstatus | (current_mode << 11u);

    cpu_states[base_idx + CSR_MSTATUS] = new_mstatus;

    // 5. Set MODE to M-mode (3)
    cpu_states[base_idx + CSR_MODE] = 3u;

    // 6. Return MTVEC as new PC
    return cpu_states[base_idx + CSR_MTVEC];
}
```
  </action>
  <verify>grep -c "trap_enter_mmode" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</verify>
  <done>trap_enter_mmode function exists, saves state to M-mode CSRs</done>
</task>

<task type="auto">
  <name>Task 2: Implement trap delegation helper</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
Add a helper function to determine if a trap should be delegated to S-mode.
Place this after trap_enter_mmode:

```wgsl
// Check if trap should be delegated to S-mode based on medeleg/mideleg
// Returns true if delegation should occur
fn should_delegate_to_smode(base_idx: u32, cause: u32) -> bool {
    // Only delegate if currently in S-mode or U-mode
    let current_mode = cpu_states[base_idx + CSR_MODE];
    if (current_mode == 3u) {
        // Already in M-mode, don't delegate downward
        return false;
    }

    // Check if cause is an interrupt (bit 31 set)
    let is_interrupt = (cause & 0x80000000u) != 0u;

    if (is_interrupt) {
        // Check mideleg for interrupt delegation
        let mideleg = cpu_states[base_idx + CSR_MIDELEG];
        let cause_bit = cause & 0x1Fu;  // Lower 5 bits for interrupt type
        return (mideleg & (1u << cause_bit)) != 0u;
    } else {
        // Check medeleg for exception delegation
        let medeleg = cpu_states[base_idx + CSR_MEDELEG];
        return (medeleg & (1u << cause)) != 0u;
    }
}
```
  </action>
  <verify>grep -c "should_delegate_to_smode" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</verify>
  <done>should_delegate_to_smode function exists, checks medeleg/mideleg</done>
</task>

<task type="auto">
  <name>Task 3: Create unified trap dispatcher</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
Create a unified trap_enter_dispatch function that chooses M vs S mode.
Place this after should_delegate_to_smode:

```wgsl
// Unified trap entry - dispatches to M-mode or S-mode based on delegation
fn trap_enter_dispatch(base_idx: u32, cause: u32, tval: u32, pc: u32) -> u32 {
    if (should_delegate_to_smode(base_idx, cause)) {
        return trap_enter(base_idx, cause, tval, pc);  // S-mode handler
    } else {
        return trap_enter_mmode(base_idx, cause, tval, pc);  // M-mode handler
    }
}
```

DO NOT update the existing trap_enter calls yet - that will be done in testing.
The existing trap_enter calls should remain for now to avoid breaking the shader.
  </action>
  <verify>grep -c "trap_enter_dispatch" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</verify>
  <done>trap_enter_dispatch function exists, routes to correct handler</done>
</task>

<task type="auto">
  <name>Task 4: Initialize M-mode CSRs at boot</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
The system should boot in M-mode per RISC-V specification.
Add initialization logic at the start of the compute kernel main function.
Around line 343, after the halted check, add:

```wgsl
// Initialize M-mode state if this is first execution (CSR_MODE unset)
let current_mode = cpu_states[base_idx + CSR_MODE];
if (current_mode == 0u && cpu_states[base_idx + CSR_MTVEC] == 0u) {
    // First boot - initialize M-mode CSRs
    cpu_states[base_idx + CSR_MODE] = 3u;  // Start in M-mode
    cpu_states[base_idx + CSR_MSTATUS] = MSTATUS_MPIE;  // MPIE=1 for first MRET
    // MTVEC should be set by firmware/bootloader via CSR write
}
```

This ensures:
- System boots in M-mode (mode=3)
- MSTATUS has MPIE set so first MRET works correctly
- Firmware can set MTVEC before enabling traps
  </action>
  <verify>grep -c "CSR_MODE] = 3u" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</verify>
  <done>Boot initializes mode to M-mode (3), MSTATUS has MPIE set</done>
</task>

</tasks>

<verification>
1. Shader compiles with new functions
2. trap_enter_mmode uses correct M-mode CSRs
3. should_delegate_to_smode checks both medeleg and mideleg
4. trap_enter_dispatch routes based on delegation
5. Boot initialization sets M-mode
</verification>

<success_criteria>
- trap_enter_mmode function implemented
- should_delegate_to_smode function implemented
- trap_enter_dispatch function implemented
- M-mode boot initialization added
- No syntax errors in shader
</success_criteria>

<output>
After completion, create `.planning/phases/18-privileged-architecture/18-03-SUMMARY.md`
</output>
