---
phase: 18-privileged-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
  - systems/visual_shell/web/SbiBridge.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can read/write M-mode CSRs (mstatus, mtvec, mepc, etc.) from shader"
    - "User can see SBI console output reach JavaScript"
    - "User can see SBI system reset calls logged to console"
  artifacts:
    - path: "systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl"
      provides: "M-mode CSR definitions and index mapping"
      contains: "CSR_MSTATUS"
    - path: "systems/visual_shell/web/SbiBridge.js"
      provides: "JavaScript handler for SBI calls"
      exports: ["SbiBridge", "handleSBICall"]
  key_links:
    - from: "visual_cpu_riscv.wgsl"
      to: "SBI_BRIDGE memory region"
      via: "ECALL writes to bridge, JS reads"
      pattern: "SBI_BRIDGE_FLAG"
---

<objective>
Add M-mode CSR definitions and create JavaScript SBI bridge handler

Purpose: Foundation for privileged mode support - M-mode CSRs are required for trap handling, and the SBI bridge enables kernel-to-JavaScript communication for console output.
Output: M-mode CSR constants in shader, JavaScript SBI handler class
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-privileged-architecture/18-RESEARCH.md

# Reference the existing shader for patterns
@systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add M-mode CSR constants to shader</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
Add M-mode CSR constants after the existing S-mode CSRs (around line 41).
Following the RISC-V Privileged Specification v1.12 exactly:

```wgsl
// --- M-MODE CSRs (Indices 50-59) ---
const CSR_MSTATUS: u32 = 50u;   // 0x300 - Machine status
const CSR_MTVEC: u32 = 51u;     // 0x305 - Machine trap handler
const CSR_MEPC: u32 = 52u;      // 0x341 - Machine exception PC
const CSR_MCAUSE: u32 = 53u;    // 0x342 - Machine exception cause
const CSR_MTVAL: u32 = 54u;     // 0x343 - Machine trap value
const CSR_MSCRATCH: u32 = 55u;  // 0x340 - Machine scratch
const CSR_MIDELEG: u32 = 56u;   // 0x303 - Interrupt delegation
const CSR_MEDELEG: u32 = 57u;   // 0x302 - Exception delegation
const CSR_MIE: u32 = 58u;       // 0x304 - Machine interrupt enable
const CSR_MIP: u32 = 59u;       // 0x344 - Machine interrupt pending
```

Also add MSTATUS bit definitions:
```wgsl
// MSTATUS bit positions (RV32)
const MSTATUS_MIE: u32 = 0x8u;      // Bit 3: Machine Interrupt Enable
const MSTATUS_MPIE: u32 = 0x80u;    // Bit 7: Machine Previous IE
const MSTATUS_MPP_MASK: u32 = 0x1800u; // Bits 12:11: Previous privilege
```

DO NOT modify _get_csr_index yet - that's in the next plan.
  </action>
  <verify>grep -c "CSR_MSTATUS" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</verify>
  <done>10 M-mode CSR constants defined (CSR_MSTATUS through CSR_MIP), MSTATUS bit constants added</done>
</task>

<task type="auto">
  <name>Task 2: Create SbiBridge.js handler class</name>
  <files>systems/visual_shell/web/SbiBridge.js</files>
  <action>
Create a new JavaScript module for handling SBI calls from the GPU shader.
The SBI bridge reads from the SBI_BRIDGE memory region (0x05010000) after ECALL.

Following the SBI specification register conventions:
- a7 (x17) = EID (Extension ID)
- a6 (x16) = FID (Function ID)
- a0-a5 (x10-x15) = Arguments
- a0 = Return error code
- a1 = Return value

Implement these SBI extensions:
1. Console (EID 0x01): putchar (FID 0) - write char to console.log
2. System Reset (EID 0x08): system_reset (FID 0) - log reset request
3. Base (EID 0x10): get spec version, impl ID, impl version

The class should:
- Take WebGPU device and memory buffer in constructor
- Have async poll() method that checks SBI_BRIDGE_FLAG
- Have async handleCall() that processes and writes results
- Use staging buffer pattern from CoreExecutionVerifier.js

DO NOT connect to visual shell yet - just create the standalone handler class.
  </action>
  <verify>node -e "const m = require('./systems/visual_shell/web/SbiBridge.js'); console.log(typeof m.SbiBridge)"</verify>
  <done>SbiBridge class exists with handleCall method, supports EID 0x01/0x08/0x10</done>
</task>

</tasks>

<verification>
1. Shader compiles with new CSR constants
2. SbiBridge.js exports a valid class
3. M-mode CSR indices are 50-59 (sequential)
</verification>

<success_criteria>
- 10 M-mode CSR constants added to shader
- MSTATUS bit constants added
- SbiBridge.js created with console/reset/base extension support
- No syntax errors in either file
</success_criteria>

<output>
After completion, create `.planning/phases/18-privileged-architecture/18-01-SUMMARY.md`
</output>
