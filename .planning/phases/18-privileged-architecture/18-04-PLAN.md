---
phase: 18-privileged-architecture
plan: 04
type: tdd
wave: 4
depends_on: [18-03]
files_modified:
  - systems/visual_shell/web/tests/test_privileged.js
  - systems/visual_shell/web/tests/test_privileged.html
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can verify CSR instructions work correctly via test output"
    - "User can verify M-mode trap handling works via test output"
    - "User can verify MRET/SRET return correctly via test output"
  artifacts:
    - path: "systems/visual_shell/web/tests/test_privileged.js"
      provides: "Test suite for privileged instructions"
      exports: ["testCSRInstructions", "testTrapHandling", "testMRET"]
      min_lines: 400
    - path: "systems/visual_shell/web/tests/test_privileged.html"
      provides: "Visual test runner"
      contains: "test_privileged.js"
  key_links:
    - from: "test_privileged.js"
      to: "CoreExecutionVerifier"
      via: "import and instantiation"
      pattern: "CoreExecutionVerifier"
---

<objective>
Create comprehensive test suite for privileged architecture

Purpose: TDD approach to verify all privileged instructions and trap handling work correctly before integration.
Output: Test suite covering CSR instructions, MRET/SRET, trap handling, and delegation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-privileged-architecture/18-RESEARCH.md
@.planning/phases/18-privileged-architecture/18-03-SUMMARY.md

# Reference existing test patterns
@systems/visual_shell/web/tests/test_riscv_core.js
@systems/visual_shell/web/CoreExecutionVerifier.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create privileged test encoder class</name>
  <files>systems/visual_shell/web/tests/test_privileged.js</files>
  <action>
Create a new test file following the pattern from test_riscv_core.js.
Add privileged instruction encoders to the RiscvTestEncoder class:

```javascript
// CSR Instructions (opcode 0x73)
static CSRRW(rd, rs1, csr) {
    return this._emitI(0x73, rd, 1, rs1, csr);
}
static CSRRS(rd, rs1, csr) {
    return this._emitI(0x73, rd, 2, rs1, csr);
}
static CSRRC(rd, rs1, csr) {
    return this._emitI(0x73, rd, 3, rs1, csr);
}
static CSRRWI(rd, zimm, csr) {
    return this._emitI(0x73, rd, 5, zimm, csr);
}
static CSRRSI(rd, zimm, csr) {
    return this._emitI(0x73, rd, 6, zimm, csr);
}
static CSRRCI(rd, zimm, csr) {
    return this._emitI(0x73, rd, 7, zimm, csr);
}

// MRET (0x30200073)
static MRET() {
    return 0x30200073;
}

// SRET (0x10200073)
static SRET() {
    return 0x10200073;
}

// ECALL
static ECALL() {
    return 0x00000073;
}
```

Also add CSR address constants:
```javascript
const CSR_SSTATUS = 0x100;
const CSR_SIE = 0x104;
const CSR_STVEC = 0x105;
const CSR_SSCRATCH = 0x140;
const CSR_SEPC = 0x141;
const CSR_SCAUSE = 0x142;
const CSR_STVAL = 0x143;
const CSR_SIP = 0x144;
const CSR_SATP = 0x180;

const CSR_MSTATUS = 0x300;
const CSR_MISA = 0x301;
const CSR_MEDELEG = 0x302;
const CSR_MIDELEG = 0x303;
const CSR_MIE = 0x304;
const CSR_MTVEC = 0x305;
const CSR_MSCRATCH = 0x340;
const CSR_MEPC = 0x341;
const CSR_MCAUSE = 0x342;
const CSR_MTVAL = 0x343;
const CSR_MIP = 0x344;
```
  </action>
  <verify>grep -c "static CSRRS" systems/visual_shell/web/tests/test_privileged.js</verify>
  <done>RiscvTestEncoder has all CSR instruction encoders and MRET/SRET</done>
</task>

<task type="auto">
  <name>Task 2: Create CSR instruction tests</name>
  <files>systems/visual_shell/web/tests/test_privileged.js</files>
  <action>
Add test functions for CSR instructions:

```javascript
async function testCSRRW(device, queue) {
    // Test CSRRW: read old value, write new value
    const program = [
        RiscvTestEncoder.ADDI(1, 0, 0x1234),  // x1 = 0x1234
        RiscvTestEncoder.CSRRW(2, 1, CSR_MSCRATCH),  // x2 = old mscratch, mscratch = x1
        RiscvTestEncoder.JAL(0, 0),  // halt
    ];
    const state = await executeProgram(device, queue, program);
    // x2 should be 0 (initial mscratch)
    // mscratch (index 55) should be 0x1234
    return state[2] === 0 && state[55] === 0x1234;
}

async function testCSRRS(device, queue) {
    // Test CSRRS: read and set bits
    const program = [
        RiscvTestEncoder.ADDI(1, 0, 0x5),   // x1 = 0x5 (bits 0 and 2)
        RiscvTestEncoder.CSRRW(0, 1, CSR_MSTATUS),  // mstatus = 0x5
        RiscvTestEncoder.ADDI(1, 0, 0x10),  // x1 = 0x10 (bit 4)
        RiscvTestEncoder.CSRRS(2, 1, CSR_MSTATUS),  // x2 = mstatus, mstatus |= 0x10
        RiscvTestEncoder.JAL(0, 0),
    ];
    const state = await executeProgram(device, queue, program);
    // x2 should be 0x5, mstatus should be 0x15
    return state[2] === 0x5 && state[50] === 0x15;
}

async function testCSRRC(device, queue) {
    // Test CSRRC: read and clear bits
    const program = [
        RiscvTestEncoder.ADDI(1, 0, 0x15),  // x1 = 0x15
        RiscvTestEncoder.CSRRW(0, 1, CSR_MSTATUS),  // mstatus = 0x15
        RiscvTestEncoder.ADDI(1, 0, 0x5),   // x1 = 0x5 (bits to clear)
        RiscvTestEncoder.CSRRC(2, 1, CSR_MSTATUS),  // x2 = mstatus, mstatus &= ~0x5
        RiscvTestEncoder.JAL(0, 0),
    ];
    const state = await executeProgram(device, queue, program);
    // x2 should be 0x15, mstatus should be 0x10
    return state[2] === 0x15 && state[50] === 0x10;
}

async function testCSRReadonlyWithX0(device, queue) {
    // CSRRS with rs1=x0 should only read, not modify
    const program = [
        RiscvTestEncoder.ADDI(1, 0, 0x1234),
        RiscvTestEncoder.CSRRW(0, 1, CSR_MSCRATCH),  // mscratch = 0x1234
        RiscvTestEncoder.CSRRS(2, 0, CSR_MSCRATCH),  // x2 = mscratch (no write)
        RiscvTestEncoder.JAL(0, 0),
    ];
    const state = await executeProgram(device, queue, program);
    // x2 should be 0x1234, mscratch should still be 0x1234
    return state[2] === 0x1234 && state[55] === 0x1234;
}

async function testCSRImmediateVariants(device, queue) {
    // Test CSRRWI, CSRRSI, CSRRCI
    const program = [
        RiscvTestEncoder.CSRRWI(1, 0x1F, CSR_MSCRATCH),  // x1 = old, mscratch = 0x1F
        RiscvTestEncoder.CSRRSI(2, 0x8, CSR_MSTATUS),    // x2 = mstatus, mstatus |= 0x8
        RiscvTestEncoder.JAL(0, 0),
    ];
    const state = await executeProgram(device, queue, program);
    // x1 should be 0 (initial), mscratch should be 0x1F
    return state[1] === 0 && state[55] === 0x1F;
}
```
  </action>
  <verify>grep -c "async function testCSR" systems/visual_shell/web/tests/test_privileged.js</verify>
  <done>5+ CSR test functions exist covering all instruction variants</done>
</task>

<task type="auto">
  <name>Task 3: Create trap handling tests</name>
  <files>systems/visual_shell/web/tests/test_privileged.js</files>
  <action>
Add test functions for trap handling:

```javascript
async function testMRET(device, queue) {
    // Test MRET returns to MEPC and restores mode
    const program = [
        // Set up for MRET
        RiscvTestEncoder.ADDI(1, 0, 0x100),   // x1 = 0x100 (return address)
        RiscvTestEncoder.CSRRW(0, 1, CSR_MEPC),  // mepc = 0x100
        RiscvTestEncoder.ADDI(1, 0, 0x88),    // x1 = MPIE set, MPP=0
        RiscvTestEncoder.CSRRW(0, 1, CSR_MSTATUS),  // mstatus = 0x88
        RiscvTestEncoder.MRET(),              // Should jump to 0x100, restore mode
        // This should not execute if MRET works
        RiscvTestEncoder.ADDI(3, 0, 0x999),
        // At address 0x100 (instruction index 0x40):
        // Pad with zeros, then at 0x40:
    ];
    // Extend program to index 0x40
    while (program.length < 0x40) program.push(0);
    program[0x40] = RiscvTestEncoder.ADDI(3, 0, 0x42);  // x3 = 42 at return target
    program[0x41] = RiscvTestEncoder.JAL(0, 0);

    const state = await executeProgram(device, queue, program);
    // x3 should be 42 (executed return target), not 999
    return state[3] === 42;
}

async function testTrapEnterMmode(device, queue) {
    // Test that EBREAK causes M-mode trap
    const program = [
        RiscvTestEncoder.ADDI(1, 0, 0x200),   // x1 = trap handler address
        RiscvTestEncoder.CSRRW(0, 1, CSR_MTVEC),  // mtvec = 0x200
        RiscvTestEncoder.EBREAK(),            // Should trap to MTVEC
        RiscvTestEncoder.ADDI(2, 0, 0x999),   // Should not execute
    ];
    // Pad and add handler
    while (program.length < 0x80) program.push(0);
    program[0x80] = RiscvTestEncoder.ADDI(2, 0, 0x42);  // x2 = 42 in handler
    program[0x81] = RiscvTestEncoder.JAL(0, 0);

    const state = await executeProgram(device, queue, program);
    // x2 should be 42 (handler executed), not 999
    // mcause should be 3 (breakpoint)
    return state[2] === 42 && state[53] === 3;
}

async function testSRET(device, queue) {
    // Test SRET returns to SEPC and restores mode
    const program = [
        RiscvTestEncoder.ADDI(1, 0, 0x100),   // x1 = return address
        RiscvTestEncoder.CSRRW(0, 1, CSR_SEPC),  // sepc = 0x100
        RiscvTestEncoder.ADDI(1, 0, 0x20),    // x1 = SPP=1, SPIE=0
        RiscvTestEncoder.CSRRW(0, 1, CSR_SSTATUS),  // sstatus
        RiscvTestEncoder.SRET(),              // Should jump to 0x100
        RiscvTestEncoder.ADDI(3, 0, 0x999),
    ];
    while (program.length < 0x40) program.push(0);
    program[0x40] = RiscvTestEncoder.ADDI(3, 0, 0x42);
    program[0x41] = RiscvTestEncoder.JAL(0, 0);

    const state = await executeProgram(device, queue, program);
    return state[3] === 42;
}
```
  </action>
  <verify>grep -c "async function test.*RET" systems/visual_shell/web/tests/test_privileged.js</verify>
  <done>3+ trap/return test functions exist (testMRET, testTrapEnterMmode, testSRET)</done>
</task>

<task type="auto">
  <name>Task 4: Create HTML test runner</name>
  <files>systems/visual_shell/web/tests/test_privileged.html</files>
  <action>
Create a visual HTML test runner following the pattern from test_riscv_core.html.
Include:
- WebGPU initialization status
- Shader compilation status
- Progress bar for test execution
- Collapsible test categories (CSR Instructions, Trap Handling, Return Instructions)
- Pass/fail indicators with expected vs actual values

The page should:
1. Import test_privileged.js as ES module
2. Create CoreExecutionVerifier with WebGPU device
3. Run all tests and display results
4. Show summary statistics

Follow the dark theme styling from test_riscv_core.html.
  </action>
  <verify>grep -c "test_privileged.js" systems/visual_shell/web/tests/test_privileged.html</verify>
  <done>HTML test runner exists, imports test_privileged.js, displays test results</done>
</task>

</tasks>

<verification>
1. test_privileged.js compiles without syntax errors
2. All CSR instruction encoders produce correct encodings
3. HTML test runner loads and initializes WebGPU
4. Tests can execute (may fail until shader changes are verified)
</verification>

<success_criteria>
- test_privileged.js with 8+ test functions created
- All CSR instruction encoders implemented
- test_privileged.html visual runner created
- Tests follow TDD pattern (define behavior, then verify)
</success_criteria>

<output>
After completion, create `.planning/phases/18-privileged-architecture/18-04-SUMMARY.md`
</output>
