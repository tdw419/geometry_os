---
phase: 18-privileged-architecture
plan: 02
type: execute
wave: 2
depends_on: [18-01]
files_modified:
  - systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can execute CSRRS to read and set CSR bits"
    - "User can execute CSRRC to read and clear CSR bits"
    - "User can execute CSRRWI/CSRRSI/CSRRCI with immediate values"
    - "User can execute MRET to return from M-mode trap"
  artifacts:
    - path: "systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl"
      provides: "Complete CSR instruction set and MRET"
      contains: "funct3_sys == 2u"
      contains: "funct3_sys == 3u"
      contains: "funct3_sys == 5u"
      contains: "trap_ret_mmode"
  key_links:
    - from: "opcode 0x73u"
      to: "CSR instructions"
      via: "funct3 dispatch"
      pattern: "funct3_sys =="
---

<objective>
Implement complete CSR instruction variants and MRET instruction

Purpose: Full CSR instruction support is required for Linux kernel to manipulate control registers. MRET is needed to return from M-mode traps.
Output: CSRRS, CSRRC, CSRRWI, CSRRSI, CSRRCI, and MRET in shader
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-privileged-architecture/18-RESEARCH.md
@.planning/phases/18-privileged-architecture/18-01-SUMMARY.md

# Reference the existing shader for patterns
@systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend _get_csr_index for M-mode CSRs</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
Extend the existing _get_csr_index function (around line 96-109) to map M-mode CSR addresses:

```wgsl
fn _get_csr_index(csr_num: u32) -> u32 {
    switch (csr_num) {
        // S-mode CSRs (existing)
        case 0x180u: { return CSR_SATP; }
        case 0x105u: { return CSR_STVEC; }
        case 0x140u: { return CSR_SSCRATCH; }
        case 0x100u: { return CSR_SSTATUS; }
        case 0x141u: { return CSR_SEPC; }
        case 0x142u: { return CSR_SCAUSE; }
        case 0x143u: { return CSR_STVAL; }
        case 0x104u: { return CSR_SIE; }
        case 0x144u: { return CSR_SIP; }

        // M-mode CSRs (NEW)
        case 0x300u: { return CSR_MSTATUS; }
        case 0x305u: { return CSR_MTVEC; }
        case 0x341u: { return CSR_MEPC; }
        case 0x342u: { return CSR_MCAUSE; }
        case 0x343u: { return CSR_MTVAL; }
        case 0x340u: { return CSR_MSCRATCH; }
        case 0x303u: { return CSR_MIDELEG; }
        case 0x302u: { return CSR_MEDELEG; }
        case 0x304u: { return CSR_MIE; }
        case 0x344u: { return CSR_MIP; }

        default: { return 255u; }
    }
}
```
  </action>
  <verify>grep -c "case 0x300u" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</verify>
  <done>10 M-mode CSR address cases added to _get_csr_index</done>
</task>

<task type="auto">
  <name>Task 2: Add complete CSR instruction variants</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
In the opcode 0x73u case (around line 567-601), extend the funct3 dispatch.
Currently only funct3_sys == 1u (CSRRW) exists. Add all other variants:

**CSRRS (funct3=010)** - Read and Set bits:
```wgsl
else if (funct3_sys == 2u) {
    let csr_idx = _get_csr_index(inst >> 20u);
    if (csr_idx < 255u) {
        let old = cpu_states[base_idx + csr_idx];
        if (rd != 0u) { cpu_states[base_idx + rd] = old; }
        if (rs1 != 0u) {  // rs1=x0 means read-only per spec
            cpu_states[base_idx + csr_idx] = old | cpu_states[base_idx + rs1];
        }
    }
}
```

**CSRRC (funct3=011)** - Read and Clear bits:
```wgsl
else if (funct3_sys == 3u) {
    let csr_idx = _get_csr_index(inst >> 20u);
    if (csr_idx < 255u) {
        let old = cpu_states[base_idx + csr_idx];
        if (rd != 0u) { cpu_states[base_idx + rd] = old; }
        if (rs1 != 0u) {
            cpu_states[base_idx + csr_idx] = old & ~cpu_states[base_idx + rs1];
        }
    }
}
```

**CSRRWI (funct3=101)** - Read and Write Immediate:
```wgsl
else if (funct3_sys == 5u) {
    let csr_idx = _get_csr_index(inst >> 20u);
    let zimm = (inst >> 15u) & 0x1Fu;  // 5-bit zero-extended immediate
    if (csr_idx < 255u) {
        let old = cpu_states[base_idx + csr_idx];
        if (rd != 0u) { cpu_states[base_idx + rd] = old; }
        cpu_states[base_idx + csr_idx] = zimm;
    }
}
```

**CSRRSI (funct3=110)** - Read and Set Immediate:
```wgsl
else if (funct3_sys == 6u) {
    let csr_idx = _get_csr_index(inst >> 20u);
    let zimm = (inst >> 15u) & 0x1Fu;
    if (csr_idx < 255u) {
        let old = cpu_states[base_idx + csr_idx];
        if (rd != 0u) { cpu_states[base_idx + rd] = old; }
        if (zimm != 0u) {
            cpu_states[base_idx + csr_idx] = old | zimm;
        }
    }
}
```

**CSRRCI (funct3=111)** - Read and Clear Immediate:
```wgsl
else if (funct3_sys == 7u) {
    let csr_idx = _get_csr_index(inst >> 20u);
    let zimm = (inst >> 15u) & 0x1Fu;
    if (csr_idx < 255u) {
        let old = cpu_states[base_idx + csr_idx];
        if (rd != 0u) { cpu_states[base_idx + rd] = old; }
        if (zimm != 0u) {
            cpu_states[base_idx + csr_idx] = old & ~zimm;
        }
    }
}
```

IMPORTANT: Add these AFTER the existing CSRRW (funct3_sys == 1u) block.
  </action>
  <verify>grep -c "funct3_sys == 2u" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</verify>
  <done>5 new CSR instruction variants (CSRRS, CSRRC, CSRRWI, CSRRSI, CSRRCI) implemented</done>
</task>

<task type="auto">
  <name>Task 3: Implement MRET instruction</name>
  <files>systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</files>
  <action>
Add MRET instruction support in two places:

1. **Add trap_ret_mmode function** (after trap_ret function, around line 190):
```wgsl
// Return from M-mode trap (MRET instruction)
fn trap_ret_mmode(base_idx: u32) -> u32 {
    let epc = cpu_states[base_idx + CSR_MEPC];
    let mstatus = cpu_states[base_idx + CSR_MSTATUS];

    let mpie = (mstatus >> 7u) & 1u;
    let mpp = (mstatus >> 11u) & 0x3u;

    var new_mstatus = mstatus;
    // Restore MIE from MPIE
    if (mpie == 1u) {
        new_mstatus = new_mstatus | MSTATUS_MIE;
    } else {
        new_mstatus = new_mstatus & ~MSTATUS_MIE;
    }
    // Set MPIE to 1
    new_mstatus = new_mstatus | MSTATUS_MPIE;
    // Clear MPP (set to U-mode for safety)
    new_mstatus = new_mstatus & ~MSTATUS_MPP_MASK;

    cpu_states[base_idx + CSR_MSTATUS] = new_mstatus;

    // Restore privilege mode from MPP
    cpu_states[base_idx + CSR_MODE] = mpp;

    return epc;
}
```

2. **Add MRET detection in opcode 0x73u case** (BEFORE SRET check):
MRET encoding is 0x30200073 (funct7=0x18, funct3=0, funct12=0x302)

```wgsl
// MRET: encoding 0x30200073
if (funct7_sys == 0x18u && funct3_sys == 0u && funct12_sys == 0x302u) {
    pc = trap_ret_mmode(base_idx);
    pc_changed = true;
}
// SRET: encoding 0x10200073 (existing)
else if (funct7_sys == 0x30u) {
    pc = trap_ret(base_idx);
    pc_changed = true;
}
```

Replace the existing SRET check with this if-else chain.
  </action>
  <verify>grep -c "trap_ret_mmode" systems/visual_shell/web/shaders/visual_cpu_riscv.wgsl</verify>
  <done>trap_ret_mmode function exists, MRET instruction detected and dispatched</done>
</task>

</tasks>

<verification>
1. Shader compiles with all new CSR variants
2. _get_csr_index returns correct indices for all M-mode CSRs
3. MRET encoding 0x30200073 is correctly detected
4. CSRRS with rs1=x0 performs read-only (no write)
</verification>

<success_criteria>
- 10 M-mode CSR mappings in _get_csr_index
- 5 new CSR instruction variants (funct3 2,3,5,6,7)
- trap_ret_mmode function implemented
- MRET instruction handling added
- No syntax errors in shader
</success_criteria>

<output>
After completion, create `.planning/phases/18-privileged-architecture/18-02-SUMMARY.md`
</output>
