---
phase: 07-cache-infrastructure
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified: [systems/visual_shell/web/CatalogCacheManager.js]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User sees hash verification pass/fail status for each cached container"
    - "Corrupted cache entries are detected and rejected"
    - "Hash is computed on write and verified on read"
  artifacts:
    - path: "systems/visual_shell/web/CatalogCacheManager.js"
      provides: "SHA256 hash verification for cache integrity"
      contains: "computeHash"
  key_links:
    - from: "CatalogCacheManager.set"
      to: "crypto.subtle.digest"
      via: "SHA-256 computation"
      pattern: "crypto\\.subtle\\.digest.*SHA-256"
    - from: "CatalogCacheManager.get"
      to: "verifyHash"
      via: "hash comparison on read"
      pattern: "verifyHash"
---

<objective>
Add SHA256 hash verification to CatalogCacheManager for integrity validation on cache write and read operations.

Purpose: Ensure cached container data has not been corrupted, providing trust in offline-accessed containers.
Output: Enhanced CatalogCacheManager.js with hash computation and verification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan context
@.planning/phases/07-cache-infrastructure/07-01-SUMMARY.md

# File being modified
@systems/visual_shell/web/CatalogCacheManager.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SHA256 hash computation using Web Crypto API</name>
  <files>systems/visual_shell/web/CatalogCacheManager.js</files>
  <action>
Add hash computation methods to CatalogCacheManager:

1. `async computeHash(data)` - Compute SHA256 hash of data
   - Accept ArrayBuffer or Blob as input
   - Convert Blob to ArrayBuffer if needed using blob.arrayBuffer()
   - Use crypto.subtle.digest('SHA-256', buffer) - native Web Crypto API
   - Return hex string (64 characters)
   - Handle errors gracefully, return null on failure

Implementation pattern:
```javascript
async computeHash(data) {
    try {
        const buffer = data instanceof Blob ? await data.arrayBuffer() : data;
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    } catch (error) {
        console.error('[CatalogCacheManager] Hash computation failed:', error);
        return null;
    }
}
```

Do NOT use external libraries - use native crypto.subtle API per project constraint "no new dependencies".
  </action>
  <verify>File contains computeHash method using crypto.subtle.digest</verify>
  <done>Hash computation returns correct SHA256 hex string for test data</done>
</task>

<task type="auto">
  <name>Task 2: Add hash verification on cache write</name>
  <files>systems/visual_shell/web/CatalogCacheManager.js</files>
  <action>
Modify the `set(entryId, data, metadata)` method to compute and store hash:

1. Compute hash before storing:
   - Call this.computeHash(data) to get SHA256
   - Compare with metadata.hash if provided (validation)
   - Store computed hash in cache entry

2. Enhanced metadata handling:
   - Accept metadata.etag (from server response)
   - Accept metadata.hash (expected hash, optional)
   - Accept metadata.size (data size in bytes)
   - Accept metadata.source (URL or server ID)

3. Verification status:
   - Add verificationStatus field to stored entry: 'verified' | 'failed' | 'pending'
   - Set to 'verified' if hash matches expected, 'failed' if mismatch, 'pending' if no expected hash

4. Return enhanced result:
   - Return { success: boolean, hash: string, verified: boolean }
   - Include verification details in return value

Update the stored entry structure:
{ id, data, metadata: { etag, size, source }, hash, cachedAt, lastAccessed, verificationStatus }
  </action>
  <verify>set() method computes hash and stores verificationStatus</verify>
  <done>Cache write computes hash and stores verification status</done>
</task>

<task type="auto">
  <name>Task 3: Add hash verification on cache read</name>
  <files>systems/visual_shell/web/CatalogCacheManager.js</files>
  <action>
Modify the `get(entryId)` method to verify hash on retrieval:

1. Add `verifyHash(data, expectedHash)` helper method:
   - Compute hash of data
   - Compare with expected hash
   - Return boolean

2. Add `getWithVerification(entryId)` method:
   - Retrieve cached entry
   - Compute hash of stored data
   - Compare with stored hash
   - Return { entry, verified: boolean, computedHash: string, storedHash: string }
   - If verification fails, log warning with [CatalogCacheManager] prefix

3. Modify existing `get(entryId)`:
   - Optionally verify hash (add verifyOnRead class property, default false)
   - Update lastAccessed timestamp
   - Return entry as before (backward compatible)

4. Add `getVerificationStatus(entryId)` method:
   - Quick check without reading full data
   - Returns 'verified' | 'failed' | 'pending' | 'not-found'

This enables UI to show verification status without loading full container data.
  </action>
  <verify>File contains verifyHash, getWithVerification, getVerificationStatus methods</verify>
  <done>Cache read verifies hash and returns verification status</done>
</task>

</tasks>

<verification>
1. computeHash returns correct SHA256 hex string for known test inputs
2. set() computes and stores hash with verification status
3. getWithVerification() validates stored data against hash
4. getVerificationStatus() returns correct status without loading data
5. Verification failures are logged but don't crash
</verification>

<success_criteria>
- Hash is computed on every cache write
- Hash is verified on read (via getWithVerification)
- Verification status is queryable
- Corrupted entries are detected and flagged
</success_criteria>

<output>
After completion, create `.planning/phases/07-cache-infrastructure/07-02-SUMMARY.md`
</output>
