---
phase: 07-cache-infrastructure
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - systems/visual_shell/web/CatalogCacheManager.js
  - systems/visual_shell/web/CatalogBridge.js
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "CatalogCacheManager can be imported by other modules"
    - "CatalogBridge uses cache for offline-capable container boot"
    - "Cache-first fetch falls back to network when cache misses"
  artifacts:
    - path: "systems/visual_shell/web/CatalogCacheManager.js"
      provides: "Exportable cache manager class"
      exports: ["CatalogCacheManager"]
    - path: "systems/visual_shell/web/CatalogBridge.js"
      provides: "Cache-aware API client"
      contains: "CatalogCacheManager import and usage"
  key_links:
    - from: "CatalogCacheManager.js"
      to: "other modules"
      via: "ES6 export + window attachment"
      pattern: "export.*CatalogCacheManager"
    - from: "CatalogBridge.js"
      to: "CatalogCacheManager"
      via: "import and cache-first fetch"
      pattern: "cache\\.(get|set)\\("
---

<objective>
Wire CatalogCacheManager to the boot flow by adding exports and integrating with CatalogBridge for cache-first fetching.

Purpose: Enable offline boot of previously downloaded containers.
Output: Exportable CatalogCacheManager and cache-aware CatalogBridge.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing implementation (complete but orphaned)
@systems/visual_shell/web/CatalogCacheManager.js

# Target for integration
@systems/visual_shell/web/CatalogBridge.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ES6 export and window attachment to CatalogCacheManager</name>
  <files>systems/visual_shell/web/CatalogCacheManager.js</files>
  <action>
    At the END of CatalogCacheManager.js (after line 1278, after the closing brace of the configure method), add:

    ```javascript
    // ES6 module export
    export { CatalogCacheManager };

    // Global window attachment for non-module usage
    if (typeof window !== 'undefined') {
        window.CatalogCacheManager = CatalogCacheManager;
    }
    ```

    This follows the exact pattern used in CatalogBridge.js (lines 357-362).
    The export enables ES6 imports; the window attachment enables script-tag usage.
  </action>
  <verify>
    ```bash
    grep -n "export { CatalogCacheManager }" systems/visual_shell/web/CatalogCacheManager.js && \
    grep -n "window.CatalogCacheManager" systems/visual_shell/web/CatalogCacheManager.js
    ```
  </verify>
  <done>
    CatalogCacheManager.js has both export statement and window attachment matching CatalogBridge.js pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire CatalogCacheManager into CatalogBridge for cache-first fetch</name>
  <files>systems/visual_shell/web/CatalogBridge.js</files>
  <action>
    Modify CatalogBridge.js to use CatalogCacheManager for cache-first fetching:

    1. Add import at top of file (after the module docstring, before the class):
       ```javascript
       import { CatalogCacheManager } from './CatalogCacheManager.js';
       ```

    2. In constructor (after line 22), initialize cache:
       ```javascript
       this.cache = new CatalogCacheManager();
       ```

    3. Add a new method `getContainerData` after `getCatalog` (around line 110):
       ```javascript
       /**
        * Fetch container data with cache-first strategy
        * Falls back to network if cache misses or is stale
        * @param {string} entryId - Container entry ID
        * @returns {Promise<Object|null>} Container data or null on failure
        */
       async getContainerData(entryId) {
           // Try cache first
           await this.cache.init();
           const cached = await this.cache.get(entryId);

           if (cached) {
               // Check if revalidation needed
               if (await this.cache.needsRevalidation(entryId)) {
                   // Background revalidation (don't block)
                   this.cache.revalidate(entryId, `${this.baseUrl}/api/v1/containers/${entryId}/data`)
                       .catch(err => console.warn('[CatalogBridge] Background revalidation failed:', err));
               }
               console.log(`[CatalogBridge] Cache hit for ${entryId}`);
               return cached;
           }

           // Cache miss - fetch from network
           console.log(`[CatalogBridge] Cache miss for ${entryId}, fetching from network`);
           const data = await this._fetch(`/api/v1/containers/${entryId}/data`);

           if (data) {
               // Store in cache for future offline access
               await this.cache.set(entryId, data);
           }

           return data;
       }
       ```

    This implements the cache-first pattern with stale-while-revalidate background updates.
  </action>
  <verify>
    ```bash
    grep -n "import.*CatalogCacheManager" systems/visual_shell/web/CatalogBridge.js && \
    grep -n "this.cache = new CatalogCacheManager" systems/visual_shell/web/CatalogBridge.js && \
    grep -n "async getContainerData" systems/visual_shell/web/CatalogBridge.js
    ```
  </verify>
  <done>
    CatalogBridge imports CatalogCacheManager, initializes it in constructor, and provides cache-first getContainerData method.
  </done>
</task>

</tasks>

<verification>
1. Export verification:
   - `grep "export { CatalogCacheManager }" systems/visual_shell/web/CatalogCacheManager.js` returns match
   - `grep "window.CatalogCacheManager" systems/visual_shell/web/CatalogCacheManager.js` returns match

2. Integration verification:
   - `grep "import.*CatalogCacheManager" systems/visual_shell/web/CatalogBridge.js` returns match
   - `grep "this.cache" systems/visual_shell/web/CatalogBridge.js` returns match

3. Syntax verification:
   - No JavaScript syntax errors in either file
</verification>

<success_criteria>
- CatalogCacheManager.js exports the class for ES6 imports
- CatalogCacheManager.js attaches to window for script-tag usage
- CatalogBridge.js imports and initializes CatalogCacheManager
- CatalogBridge.js provides cache-first getContainerData method
- Pattern matches existing CatalogBridge.js export style (lines 357-362)
</success_criteria>

<output>
After completion, create `.planning/phases/07-cache-infrastructure/07-04-SUMMARY.md`
</output>
