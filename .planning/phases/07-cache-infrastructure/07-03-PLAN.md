---
phase: 07-cache-infrastructure
plan: 03
type: execute
wave: 3
depends_on: [07-02]
files_modified: [systems/visual_shell/web/CatalogCacheManager.js]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can boot a previously downloaded container without network access"
    - "Cache automatically evicts least-recently-used entries when size limit reached"
    - "Stale cache entries are revalidated with ETag check on next access"
  artifacts:
    - path: "systems/visual_shell/web/CatalogCacheManager.js"
      provides: "LRU eviction policy and ETag-based stale validation"
      contains: "evictLRU"
  key_links:
    - from: "CatalogCacheManager.set"
      to: "evictLRU"
      via: "size limit check on write"
      pattern: "evictLRU"
    - from: "CatalogCacheManager.get"
      to: "needsRevalidation"
      via: "stale check on read"
      pattern: "needsRevalidation"
---

<objective>
Implement LRU eviction policy and ETag-based stale validation for the CatalogCacheManager.

Purpose: Ensure cache stays within size limits and stale entries are revalidated with the server before use.
Output: Enhanced CatalogCacheManager.js with eviction and revalidation logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan context
@.planning/phases/07-cache-infrastructure/07-02-SUMMARY.md

# File being modified
@systems/visual_shell/web/CatalogCacheManager.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement LRU eviction logic</name>
  <files>systems/visual_shell/web/CatalogCacheManager.js</files>
  <action>
Add LRU (Least Recently Used) eviction methods to CatalogCacheManager:

1. `async evictLRU(bytesNeeded)` - Evict entries to make room
   - Calculate current size + bytesNeeded
   - If exceeds maxSize, evict entries sorted by lastAccessed (oldest first)
   - Continue evicting until under limit
   - Return array of evicted entry IDs

Implementation approach:
```javascript
async evictLRU(bytesNeeded) {
    const entries = await this.getAll();
    const sorted = entries.sort((a, b) => a.lastAccessed - b.lastAccessed);
    const evicted = [];
    let freedBytes = 0;

    for (const entry of sorted) {
        if (this.currentSize + bytesNeeded - freedBytes <= this.maxSize) break;
        await this.delete(entry.id);
        evicted.push(entry.id);
        freedBytes += entry.size;
    }

    return { evicted, freedBytes };
}
```

2. Modify `set()` to check size and evict if needed:
   - Before storing, check if data size + current size > max size
   - Call evictLRU(data.byteLength) if needed
   - Log eviction events with [CatalogCacheManager] prefix

3. Add `getEvictionCandidates(count)` method:
   - Return next N entries that would be evicted
   - Useful for UI showing "low space" warnings
  </action>
  <verify>File contains evictLRU method and set() triggers eviction when needed</verify>
  <done>LRU eviction works when cache exceeds size limit</done>
</task>

<task type="auto">
  <name>Task 2: Add stale detection and revalidation logic</name>
  <files>systems/visual_shell/web/CatalogCacheManager.js</files>
  <action>
Add stale detection methods for ETag-based validation:

1. Add configuration properties:
   - maxAge: maximum cache age in ms (default: 7 days = 7 * 24 * 60 * 60 * 1000)
   - staleWhileRevalidate: allow stale for this long (default: 1 day)

2. `isStale(entry)` - Check if entry is stale:
   - Compare cachedAt timestamp against maxAge
   - Return boolean

3. `needsRevalidation(entry)` - Check if entry needs server validation:
   - Returns true if: isStale AND past staleWhileRevalidate window
   - Returns false if: fresh or within staleWhileRevalidate window

4. `getStaleStatus(entryId)` - Get staleness information:
   - Return { isStale, needsRevalidation, age, maxAge, remainingTTL }
   - age in milliseconds
   - remainingTTL: ms until revalidation required

5. Modify `get(entryId)` to update lastAccessed even for stale entries:
   - Stale entries still count as "used" for LRU purposes
   - Don't auto-delete stale entries (let revalidation decide)
  </action>
  <verify>File contains isStale, needsRevalidation, getStaleStatus methods</verify>
  <done>Stale detection works based on cachedAt timestamp</done>
</task>

<task type="auto">
  <name>Task 3: Implement ETag-based revalidation</name>
  <files>systems/visual_shell/web/CatalogCacheManager.js</files>
  <action>
Add ETag revalidation support for stale entries:

1. `async revalidate(entryId, fetchCallback)` - Revalidate with server
   - Parameters:
     - entryId: cache entry to revalidate
     - fetchCallback: async function that performs conditional fetch
   - fetchCallback signature: async (etag) => { data, metadata, changed: boolean }
   - If server returns 304 (not changed), update cachedAt timestamp
   - If server returns new data, update cache with new data
   - Return { revalidated: boolean, updated: boolean }

2. `getOrRevalidate(entryId, fetchCallback)` - Get with automatic revalidation:
   - If entry missing: return null
   - If entry fresh: return entry
   - If entry stale but within staleWhileRevalidate:
     - Return stale entry immediately (background revalidation optional)
   - If entry needs revalidation:
     - Call fetchCallback with stored ETag
     - Return fresh data or updated cache entry

3. Integration helper for CatalogBridge:
   - `createRevalidationFetcher(catalogBridge, entryId)` - Helper to create fetchCallback
   - Uses catalogBridge to fetch with If-None-Match header
   - Returns appropriate format for revalidate()

This implements the stale-while-revalidate pattern mentioned in project constraints.
  </action>
  <verify>File contains revalidate, getOrRevalidate, createRevalidationFetcher methods</verify>
  <done>ETag revalidation works with conditional fetch pattern</done>
</task>

<task type="auto">
  <name>Task 4: Add cache management utilities</name>
  <files>systems/visual_shell/web/CatalogCacheManager.js</files>
  <action>
Add utility methods for cache management:

1. `evictAllStale()` - Remove all stale entries:
   - Delete entries where needsRevalidation returns true
   - Return count of deleted entries

2. `getCacheReport()` - Human-readable cache status:
   - Return object with: entryCount, totalSize, maxSize, percentUsed
   - Include staleCount: number of stale entries
   - Include pendingRevalidationCount: entries needing revalidation
   - Include oldestEntry: timestamp
   - Include averageAge: in milliseconds

3. `configure(options)` - Update cache settings:
   - Accept { maxSize, maxAge, staleWhileRevalidate, verifyOnRead }
   - Persist to localStorage for session continuity

4. Add event emission for UI integration:
   - Extend class from PIXI.utils.EventEmitter (same pattern as DesktopObjectManager)
   - Emit 'cache-evicted' with { entryIds, freedBytes }
   - Emit 'entry-revalidated' with { entryId, updated }
   - Emit 'verification-failed' with { entryId, expectedHash, computedHash }

5. Final export and documentation:
   - Add JSDoc comments for all public methods
   - Ensure ES6 export is still present
  </action>
  <verify>File contains evictAllStale, getCacheReport, configure methods and event emission</verify>
  <done>Cache management utilities work and events are emitted</done>
</task>

</tasks>

<verification>
1. evictLRU correctly removes oldest entries when cache exceeds limit
2. isStale and needsRevalidation work based on timestamps
3. getOrRevalidate handles fresh/stale/revalidation cases correctly
4. ETag revalidation integrates with conditional fetch pattern
5. Events are emitted for evictions and revalidations
6. Cache statistics are accurate
</verification>

<success_criteria>
- Cache automatically evicts LRU entries when size limit reached
- Stale entries are detected and flagged
- ETag-based revalidation works with server
- Offline boot works for fresh cached entries
- UI can display cache status and verification state
</success_criteria>

<output>
After completion, create `.planning/phases/07-cache-infrastructure/07-03-SUMMARY.md`
</output>
