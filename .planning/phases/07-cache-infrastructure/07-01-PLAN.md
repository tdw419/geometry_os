---
phase: 07-cache-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [systems/visual_shell/web/CatalogCacheManager.js]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can store container data in browser cache"
    - "User can retrieve cached container data by ID"
    - "User can delete cached container data"
    - "Cache persists across browser sessions"
  artifacts:
    - path: "systems/visual_shell/web/CatalogCacheManager.js"
      provides: "IndexedDB-based cache storage for container data"
      exports: ["CatalogCacheManager"]
      min_lines: 100
  key_links:
    - from: "CatalogCacheManager.js"
      to: "IndexedDB"
      via: "native indexedDB API"
      pattern: "indexedDB\\.open"
---

<objective>
Create CatalogCacheManager class with IndexedDB storage for caching downloaded container data.

Purpose: Enable offline access to previously downloaded containers by storing them in browser-based persistent storage.
Output: CatalogCacheManager.js with full IndexedDB implementation for container caching.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing components to integrate with
@systems/visual_shell/web/CatalogBridge.js
@systems/visual_shell/web/DesktopObjectManager.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CatalogCacheManager class structure with IndexedDB setup</name>
  <files>systems/visual_shell/web/CatalogCacheManager.js</files>
  <action>
Create a new CatalogCacheManager class that provides IndexedDB-based caching for container data.

Implementation details:
1. Class constructor with database name and version configuration
2. Initialize IndexedDB database named 'gos-cache' with object store 'containers'
3. Use native IndexedDB API (no external dependencies per project constraints)
4. Store container entries with structure: { id, data, metadata, size, cachedAt, lastAccessed, etag, hash }
5. Implement database migration pattern for future schema changes

IndexedDB schema:
- Database: 'gos-cache' (version 1)
- Object store: 'containers' with keyPath 'id'
- Indexes: 'cachedAt', 'lastAccessed', 'size'

Error handling:
- Wrap all IDB operations in try/catch
- Log errors with [CatalogCacheManager] prefix
- Return null on failures (fail gracefully)
  </action>
  <verify>Node check: file exists and contains 'class CatalogCacheManager' and 'indexedDB.open'</verify>
  <done>CatalogCacheManager.js exists with IndexedDB initialization, database opens successfully</done>
</task>

<task type="auto">
  <name>Task 2: Implement cache CRUD operations</name>
  <files>systems/visual_shell/web/CatalogCacheManager.js</files>
  <action>
Add async methods for cache operations:

1. `get(entryId)` - Retrieve cached container by ID
   - Returns { id, data, metadata, size, cachedAt, lastAccessed, etag, hash } or null
   - Updates lastAccessed timestamp on successful get

2. `set(entryId, data, metadata)` - Store container in cache
   - Parameters: entryId (string), data (ArrayBuffer or Blob), metadata (object with etag, hash, size)
   - Stores with cachedAt and lastAccessed timestamps
   - Returns true on success, false on failure

3. `delete(entryId)` - Remove container from cache
   - Returns true if deleted, false if not found or error

4. `has(entryId)` - Check if container exists in cache
   - Returns boolean

5. `getAll()` - Get list of all cached entries (without full data)
   - Returns array of { id, metadata, size, cachedAt, lastAccessed }

6. `clear()` - Delete all cached containers
   - Returns count of deleted entries

All methods must be async and return Promises.
Use IDBRequest event handlers (onsuccess/onerror) wrapped in Promise constructor.
  </action>
  <verify>File contains async methods: get, set, delete, has, getAll, clear</verify>
  <done>All CRUD methods implemented and return Promises</done>
</task>

<task type="auto">
  <name>Task 3: Add cache statistics and size tracking</name>
  <files>systems/visual_shell/web/CatalogCacheManager.js</files>
  <action>
Add methods for cache management:

1. `getStats()` - Get cache statistics
   - Returns { entryCount, totalSize, oldestEntry, newestEntry }
   - totalSize in bytes, timestamps as Date objects

2. `getSize()` - Get total cache size in bytes
   - Iterates all entries and sums size field

3. `getMaxSize()` and `setMaxSize(bytes)` - Configure cache size limit
   - Default: 500MB (500 * 1024 * 1024)
   - Store in localStorage for persistence

4. Export the class:
   - ES6 export: `export { CatalogCacheManager }`
   - Window attachment: `if (typeof window !== 'undefined') { window.CatalogCacheManager = CatalogCacheManager }`

Follow the pattern from CatalogBridge.js for exports.
  </action>
  <verify>File contains getStats, getSize, getMaxSize, setMaxSize methods and ES6 export</verify>
  <done>Cache statistics methods work, class exported correctly</done>
</task>

</tasks>

<verification>
1. CatalogCacheManager.js exists at systems/visual_shell/web/CatalogCacheManager.js
2. Class initializes IndexedDB database 'gos-cache' with 'containers' object store
3. All CRUD methods (get, set, delete, has, getAll, clear) are async and functional
4. Statistics methods (getStats, getSize) work correctly
5. ES6 export and window attachment follow existing patterns
</verification>

<success_criteria>
- IndexedDB database opens successfully in browser
- Can store and retrieve container data by ID
- Cache persists across browser sessions
- Statistics accurately reflect cache state
</success_criteria>

<output>
After completion, create `.planning/phases/07-cache-infrastructure/07-01-SUMMARY.md`
</output>
