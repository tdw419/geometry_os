---
phase: 04-visual-catalog-manager
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - systems/pixel_compiler/catalog/__init__.py
  - systems/pixel_compiler/catalog/catalog_scanner.py
  - systems/pixel_compiler/catalog/thumbnail_cache.py
autonomous: true

must_haves:
  truths:
    - "CatalogScanner discovers all .rts.png files in configured directories"
    - "CatalogScanner extracts metadata (kernel, distro, architecture) from PNG files"
    - "ThumbnailCache generates 256x256 thumbnails from .rts.png files"
    - "ThumbnailCache caches thumbnails to avoid regeneration"
    - "ThumbnailCache serves thumbnails as base64 for JSON API responses"
  artifacts:
    - path: "systems/pixel_compiler/catalog/catalog_scanner.py"
      provides: "File discovery and metadata extraction"
      exports: ["CatalogScanner", "CatalogEntry"]
      min_lines: 80
    - path: "systems/pixel_compiler/catalog/thumbnail_cache.py"
      provides: "Thumbnail generation and caching"
      exports: ["ThumbnailCache", "ThumbnailResult"]
      min_lines: 70
    - path: "systems/pixel_compiler/catalog/__init__.py"
      provides: "Package exports"
      contains: "from .catalog_scanner import"
  key_links:
    - from: "catalog_scanner.py"
      to: "rts_registry_manager.py"
      via: "pattern reuse for metadata extraction"
      pattern: "Image\\.open.*\\.text"
    - from: "thumbnail_cache.py"
      to: "PIL.Image"
      via: "thumbnail generation with LANCZOS"
      pattern: "thumbnail.*LANCZOS|Image\\.open"
---

<objective>
Create the foundation components for the Visual Catalog Manager: CatalogScanner for discovering .rts.png files and extracting metadata, and ThumbnailCache for generating and caching visual thumbnails.

Purpose: These components are the data layer that the catalog server and UI will use. They follow established patterns from RTSRegistryManager (metadata extraction) and existing PIL usage.
Output: catalog_scanner.py, thumbnail_cache.py, __init__.py
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/04-visual-catalog-manager/04-RESEARCH.md

# Reference existing patterns
@systems/pixel_compiler/rts_registry_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CatalogScanner and CatalogEntry</name>
  <files>systems/pixel_compiler/catalog/catalog_scanner.py, systems/pixel_compiler/catalog/__init__.py</files>
  <action>
Create the catalog_scanner.py module with:

1. `CatalogEntry` dataclass:
   - `id: str` - unique identifier (hash of path or path-based)
   - `name: str` - display name (from metadata or filename stem)
   - `path: str` - absolute path to .rts.png file
   - `size: int` - file size in bytes
   - `grid_size: Optional[str]` - from PNG metadata (pixelrts.grid_size)
   - `kernel_version: Optional[str]` - from PNG metadata
   - `distro: Optional[str]` - from PNG metadata
   - `architecture: Optional[str]` - from PNG metadata
   - `thumbnail_position: Tuple[int, int]` - grid position (default 0,0)

2. `CatalogScanner` class:
   - Constructor takes `watch_paths: List[str]` (default: ["."] or from RTS_REGISTRY_PATH env var)
   - `scan() -> List[CatalogEntry]` - recursively find all .rts.png files
   - `_create_entry(rts_path: Path) -> CatalogEntry` - extract metadata using PIL Image.open()
   - `_generate_id(path: Path) -> str` - create stable ID from path

Key implementation details:
- Use `Path.rglob("*.rts.png")` for recursive discovery
- Extract metadata from PNG tEXt chunks using `Image.open(path).text` (same as RTSRegistryManager)
- Handle exceptions gracefully (log warning, skip file)
- Generate ID using `hashlib.md5(str(path).encode()).hexdigest()[:12]` for stability

Create __init__.py with exports:
```python
from .catalog_scanner import CatalogScanner, CatalogEntry
```

DO NOT implement filesystem watching yet - just scan on demand. Polling/watching comes later if needed.
</action>
  <verify>python3 -c "from systems.pixel_compiler.catalog import CatalogScanner, CatalogEntry; scanner = CatalogScanner(['.']); print('OK')"</verify>
  <done>CatalogScanner discovers .rts.png files and extracts metadata into CatalogEntry objects</done>
</task>

<task type="auto">
  <name>Task 2: Create ThumbnailCache for thumbnail generation</name>
  <files>systems/pixel_compiler/catalog/thumbnail_cache.py, systems/pixel_compiler/catalog/__init__.py</files>
  <action>
Create the thumbnail_cache.py module with:

1. `ThumbnailResult` dataclass:
   - `path: str` - path to cached thumbnail file
   - `cached: bool` - whether it was already cached
   - `size: int` - thumbnail size (width=height)

2. `ThumbnailCache` class:
   - Constructor takes `cache_dir: str = "~/.cache/pixelrts/thumbnails"` and `default_size: int = 256`
   - `get_thumbnail(rts_path: str, size: int = None) -> ThumbnailResult`:
     - Generate cache key using `hashlib.md5(f"{rts_path}:{size}".encode()).hexdigest()`
     - If cache file exists, return cached result
     - Otherwise, open image with PIL, create thumbnail, save to cache
     - Use `Image.Resampling.LANCZOS` for high quality
   - `get_thumbnail_base64(rts_path: str, size: int = None) -> str`:
     - Get thumbnail and return as base64-encoded string
     - Used for JSON API responses
   - `clear_cache() -> int` - clear all cached thumbnails, return count

Key implementation details:
- Create cache directory with `Path.mkdir(parents=True, exist_ok=True)`
- Use `img.thumbnail((size, size), Image.Resampling.LANCZOS)` for resizing
- Save as PNG format for lossless quality
- Cache filename: `{cache_key}.png`

Update __init__.py to export:
```python
from .thumbnail_cache import ThumbnailCache, ThumbnailResult
```
</action>
  <verify>python3 -c "from systems.pixel_compiler.catalog import ThumbnailCache, ThumbnailResult; cache = ThumbnailCache(); print('OK')"</verify>
  <done>ThumbnailCache generates and caches 256x256 thumbnails, serves as base64</done>
</task>

</tasks>

<verification>
- [ ] CatalogScanner importable with CatalogEntry dataclass
- [ ] ThumbnailCache importable with ThumbnailResult dataclass
- [ ] CatalogScanner.scan() returns list of CatalogEntry objects
- [ ] ThumbnailCache.get_thumbnail() creates cached thumbnails
- [ ] ThumbnailCache.get_thumbnail_base64() returns base64 strings
</verification>

<success_criteria>
- CatalogScanner discovers all .rts.png files in watch paths
- CatalogEntry contains metadata extracted from PNG tEXt chunks
- ThumbnailCache generates 256x256 thumbnails with LANCZOS resampling
- Thumbnails are cached in ~/.cache/pixelrts/thumbnails with content-hash filenames
- Base64 encoding works for JSON API responses
</success_criteria>

<output>
After completion, create `.planning/phases/04-visual-catalog-manager/04-01-SUMMARY.md`
</output>
