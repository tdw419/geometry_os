---
phase: 06-boot-progress-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - systems/pixel_compiler/catalog/catalog_server.py
  - systems/visual_shell/web/CatalogBridge.js
  - systems/visual_shell/web/DesktopObjectManager.js
autonomous: true

must_haves:
  truths:
    - "CatalogBridge polls container status from /api/v1/catalog/{id}/status"
    - "CatalogServer tracks PID and status for each booted container"
    - "DesktopObjectManager updates object status based on poll results"
    - "Status colors show: gray=stopped, green=running, red=error"
  artifacts:
    - path: "systems/pixel_compiler/catalog/catalog_server.py"
      provides: "Status endpoint and PID tracking"
      endpoints: ["GET /api/v1/catalog/{entry_id}/status"]
      contains: ["_active_boots", "get_status", "status_endpoint"]
    - path: "systems/visual_shell/web/CatalogBridge.js"
      provides: "Status polling client method"
      contains: ["getStatus", "pollStatus"]
    - path: "systems/visual_shell/web/DesktopObjectManager.js"
      provides: "Status polling loop and UI updates"
      contains: ["startStatusPolling", "_pollStatus"]
  key_links:
    - from: "CatalogBridge.getStatus()"
      to: "/api/v1/catalog/{id}/status"
      via: "fetch GET"
      pattern: "status.*fetch|/status"
    - from: "DesktopObjectManager._pollStatus()"
      to: "RTSDesktopObject.setStatus()"
      via: "updates UI based on poll result"
      pattern: "setStatus.*poll|_pollStatus"
---

<objective>
Add status tracking and polling to show real-time container status (running/stopped/error). Backend tracks PID and process status, frontend polls for updates and reflects in UI.

Purpose: Satisfy BOOT-02 requirement - users can see visual status of each container.
Output: Updated catalog_server.py with status endpoint, updated CatalogBridge.js with polling, updated DesktopObjectManager.js with status update loop
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-boot-progress-integration/06-CONTEXT.md

# Existing implementations to extend
@systems/pixel_compiler/catalog/catalog_server.py
@systems/visual_shell/web/CatalogBridge.js
@systems/visual_shell/web/DesktopObjectManager.js

# Design decisions from context
- Status colors: gray=stopped, yellow/orange=booting, green=running, red=error
- Status polling via catalog server API
- PID tracking needed for orphan prevention
- 30 second boot timeout before marking as error
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add status tracking to CatalogServer backend</name>
  <files>systems/pixel_compiler/catalog/catalog_server.py</files>
  <action>
Extend the CatalogServer class to track boot status and process information.

Add to CatalogServer.__init__() after self._active_boots initialization (around line 149):

```python
# Track boot status for each entry
# Format: { entry_id: { status, pid, started_at, error_message, vnc_port } }
self._boot_status: Dict[str, Dict[str, Any]] = {}
```

Add new method after boot_entry() method (around line 325):

```python
def get_status(self, entry_id: str) -> Dict[str, Any]:
    """
    Get the current status of a catalog entry.

    Args:
        entry_id: ID of entry to check

    Returns:
        Dictionary with status information:
        - status: 'stopped' | 'booting' | 'running' | 'error'
        - pid: Process ID if running
        - started_at: ISO timestamp when started
        - uptime_seconds: Seconds since boot (if running)
        - vnc_port: VNC port if available
        - error_message: Error description if failed

    Raises:
        ValueError: If entry_id not found
    """
    # Check if entry exists
    entry_exists = any(e.id == entry_id for e in self._entries)
    if not entry_exists:
        raise ValueError(f"Entry not found: {entry_id}")

    # Get stored status or return stopped
    status_info = self._boot_status.get(entry_id, {
        'status': 'stopped',
        'pid': None,
        'started_at': None,
        'uptime_seconds': None,
        'vnc_port': None,
        'error_message': None
    })

    # If running, check if process is still alive
    if status_info['status'] == 'running' and status_info.get('pid'):
        try:
            import os
            os.kill(status_info['pid'], 0)  # Check if process exists
            # Update uptime
            if status_info.get('started_at'):
                from datetime import datetime
                started = datetime.fromisoformat(status_info['started_at'])
                status_info['uptime_seconds'] = (datetime.now() - started).total_seconds()
        except (OSError, ProcessLookupError):
            # Process died - update status to error
            status_info = {
                'status': 'error',
                'pid': status_info['pid'],
                'started_at': status_info['started_at'],
                'uptime_seconds': None,
                'vnc_port': None,
                'error_message': 'Process terminated unexpectedly'
            }
            self._boot_status[entry_id] = status_info

    return status_info

def update_boot_status(self, entry_id: str, status: str, **kwargs) -> None:
    """
    Update the boot status for an entry.

    Args:
        entry_id: Entry ID to update
        status: New status value
        **kwargs: Additional status fields (pid, error_message, vnc_port)
    """
    from datetime import datetime

    current = self._boot_status.get(entry_id, {})
    current['status'] = status

    if status == 'booting':
        current['started_at'] = datetime.now().isoformat()
    elif status == 'error':
        current['error_message'] = kwargs.get('error_message', 'Boot failed')

    # Merge additional kwargs
    for key in ['pid', 'vnc_port', 'error_message']:
        if key in kwargs:
            current[key] = kwargs[key]

    self._boot_status[entry_id] = current
```
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/pixel_compiler/catalog/catalog_server.py', 'utf8'); console.log(code.includes('get_status') && code.includes('_boot_status') ? 'OK' : 'FAIL')"</verify>
  <done>Backend status tracking added to CatalogServer</done>
</task>

<task type="auto">
  <name>Task 2: Update boot_entry to track status</name>
  <files>systems/pixel_compiler/catalog/catalog_server.py</files>
  <action>
Update the boot_entry() method to track status changes throughout the boot process.

Replace the boot_entry() method (around line 232) with this updated version:

```python
def boot_entry(self, entry_id: str, options: BootOptions) -> Dict[str, Any]:
    """
    Boot a catalog entry using BootBridge.

    Runs boot in background thread to avoid blocking API.
    Tracks status throughout boot process.

    Args:
        entry_id: ID of entry to boot
        options: Boot options (memory, cpus, cmdline)

    Returns:
        Dictionary with boot result

    Raises:
        ValueError: If entry_id not found
    """
    # Find entry
    entry = None
    for e in self._entries:
        if e.id == entry_id:
            entry = e
            break

    if entry is None:
        raise ValueError(f"Entry not found: {entry_id}")

    # Set status to booting
    self.update_boot_status(entry_id, 'booting')

    # Import BootBridge
    try:
        from systems.pixel_compiler.boot import BootBridge, BootResult
    except ImportError:
        try:
            from pixel_compiler.boot import BootBridge, BootResult
        except ImportError:
            self.update_boot_status(entry_id, 'error', error_message='BootBridge not available')
            raise ImportError(
                "BootBridge not available. Ensure systems.pixel_compiler.boot is importable."
            )

    # Create boot bridge
    bridge = BootBridge(
        rts_png_path=entry.path,
        memory=options.memory,
        cpus=options.cpus,
        verbose=False
    )

    # Store bridge for cleanup tracking
    self._active_boots[entry_id] = bridge

    # Run boot in thread
    result_holder = {"result": None, "error": None}

    def run_boot():
        try:
            result = bridge.boot(cmdline=options.cmdline)
            result_holder["result"] = result
        except Exception as e:
            result_holder["error"] = str(e)
            logger.error(f"Boot failed for {entry.name}: {e}")

    thread = threading.Thread(target=run_boot, daemon=True)
    thread.start()
    thread.join(timeout=30)  # Wait up to 30 seconds for boot

    # Check result and update status
    if result_holder["error"]:
        self.update_boot_status(entry_id, 'error', error_message=result_holder["error"])
        return {
            "success": False,
            "entry_id": entry_id,
            "entry_name": entry.name,
            "vnc_port": None,
            "pid": None,
            "error_message": result_holder["error"]
        }

    result = result_holder["result"]
    if result and result.success:
        self.update_boot_status(
            entry_id,
            'running',
            pid=result.pid,
            vnc_port=result.vnc_port
        )
        return {
            "success": True,
            "entry_id": entry_id,
            "entry_name": entry.name,
            "vnc_port": result.vnc_port,
            "pid": result.pid,
            "error_message": None
        }
    else:
        error_msg = result.error_message if result else "Boot failed"
        self.update_boot_status(entry_id, 'error', error_message=error_msg)
        return {
            "success": False,
            "entry_id": entry_id,
            "entry_name": entry.name,
            "vnc_port": None,
            "pid": None,
            "error_message": error_msg
        }
```
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/pixel_compiler/catalog/catalog_server.py', 'utf8'); console.log(code.includes(\"update_boot_status(entry_id, 'booting')\") && code.includes(\"update_boot_status(entry_id, 'running'\") ? 'OK' : 'FAIL')"</verify>
  <done>boot_entry() updated to track status changes</done>
</task>

<task type="auto">
  <name>Task 3: Add status API endpoint</name>
  <files>systems/pixel_compiler/catalog/catalog_server.py</files>
  <action>
Add a new Pydantic model and API endpoint for status queries.

Add after the BootResponse model (around line 84):

```python
class StatusResponse(BaseModel):
    """Response model for status query."""
    entry_id: str
    status: str  # 'stopped' | 'booting' | 'running' | 'error'
    pid: Optional[int]
    started_at: Optional[str]
    uptime_seconds: Optional[float]
    vnc_port: Optional[int]
    error_message: Optional[str]
```

Add the endpoint after the boot_catalog_entry endpoint (around line 417):

```python
@app.get("/api/v1/catalog/{entry_id}/status", response_model=StatusResponse, tags=["Catalog"])
async def get_entry_status(entry_id: str):
    """
    Get the current status of a catalog entry.

    Returns status information including:
    - status: Current state (stopped, booting, running, error)
    - pid: Process ID if running
    - uptime_seconds: Time since boot if running
    - vnc_port: VNC port for console access
    - error_message: Error description if failed

    Args:
        entry_id: ID of entry to check

    Returns:
        StatusResponse with current status
    """
    server = get_catalog_server()

    try:
        status = server.get_status(entry_id)
        return StatusResponse(
            entry_id=entry_id,
            status=status['status'],
            pid=status.get('pid'),
            started_at=status.get('started_at'),
            uptime_seconds=status.get('uptime_seconds'),
            vnc_port=status.get('vnc_port'),
            error_message=status.get('error_message')
        )
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))
```
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/pixel_compiler/catalog/catalog_server.py', 'utf8'); console.log(code.includes('StatusResponse') && code.includes('/api/v1/catalog/{entry_id}/status') ? 'OK' : 'FAIL')"</verify>
  <done>Status API endpoint added to catalog server</done>
</task>

<task type="auto">
  <name>Task 4: Add status polling to CatalogBridge</name>
  <files>systems/visual_shell/web/CatalogBridge.js</files>
  <action>
Add status polling methods to CatalogBridge.

Add after the stopEntry() method (around line 162):

```javascript
/**
 * Get the current status of a catalog entry
 * @param {string} entryId - The entry ID to check
 * @returns {Promise<Object|null>} Status object or null on failure
 *
 * @example
 * const status = await bridge.getStatus('ubuntu-22.04');
 * // Returns: { status: 'running', pid: 12345, uptime_seconds: 3600, vnc_port: 5900 }
 */
async getStatus(entryId) {
    const data = await this._fetch(`/api/v1/catalog/${encodeURIComponent(entryId)}/status`);
    return data;
}

/**
 * Start polling for status updates
 * @param {string} entryId - Entry ID to poll
 * @param {Function} callback - Called with status updates: (status) => void
 * @param {Object} options - Polling options
 * @param {number} options.interval - Polling interval in ms (default: 1000)
 * @param {number} options.maxAttempts - Max polls before stopping (default: 60)
 * @returns {Object} Polling controller with stop() method
 */
pollStatus(entryId, callback, options = {}) {
    const interval = options.interval || 1000;  // 1 second default
    const maxAttempts = options.maxAttempts || 60;  // 60 attempts = 1 minute max
    let attempts = 0;
    let pollId = null;

    const poll = async () => {
        attempts++;

        try {
            const status = await this.getStatus(entryId);
            if (status) {
                callback(status);

                // Stop polling if status is no longer 'booting'
                if (status.status !== 'booting') {
                    this.stopPolling(pollId);
                    return;
                }
            }

            // Stop after max attempts
            if (attempts >= maxAttempts) {
                callback({ status: 'error', error_message: 'Status polling timeout' });
                this.stopPolling(pollId);
                return;
            }

            // Schedule next poll
            pollId = setTimeout(poll, interval);
        } catch (error) {
            console.error(`[CatalogBridge] Status poll error for ${entryId}:`, error);
            // Continue polling on error
            pollId = setTimeout(poll, interval);
        }
    };

    // Start polling immediately
    poll();

    // Return controller
    return {
        id: pollId,
        stop: () => this.stopPolling(pollId)
    };
}

/**
 * Stop a polling loop
 * @param {number} pollId - The poll ID to stop
 */
stopPolling(pollId) {
    if (pollId) {
        clearTimeout(pollId);
    }
}
```
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/CatalogBridge.js', 'utf8'); console.log(code.includes('getStatus') && code.includes('pollStatus') ? 'OK' : 'FAIL')"</verify>
  <done>Status polling methods added to CatalogBridge</done>
</task>

<task type="auto">
  <name>Task 5: Add status polling to DesktopObjectManager</name>
  <files>systems/visual_shell/web/DesktopObjectManager.js</files>
  <action>
Add status polling integration to DesktopObjectManager.

Add to constructor (after this.selectedObjectId = null, around line 49):

```javascript
// Active status pollers
this._statusPollers = new Map();  // entryId -> { id, stop() }
```

Add new methods after bootObject() method (around line 367):

```javascript
/**
 * Start status polling for an entry
 * @param {string} entryId - Entry ID to poll
 * @param {number} interval - Polling interval in ms (default: 1000)
 */
startStatusPolling(entryId, interval = 1000) {
    // Don't start if already polling
    if (this._statusPollers.has(entryId)) {
        return;
    }

    console.log(`[DesktopObjectManager] Starting status polling for ${entryId}`);

    const poller = this.bridge.pollStatus(
        entryId,
        (status) => this._handleStatusUpdate(entryId, status),
        { interval, maxAttempts: 120 }  // 2 minutes max
    );

    this._statusPollers.set(entryId, poller);
}

/**
 * Stop status polling for an entry
 * @param {string} entryId - Entry ID to stop polling
 */
stopStatusPolling(entryId) {
    const poller = this._statusPollers.get(entryId);
    if (poller) {
        poller.stop();
        this._statusPollers.delete(entryId);
        console.log(`[DesktopObjectManager] Stopped status polling for ${entryId}`);
    }
}

/**
 * Handle status update from polling
 * @private
 * @param {string} entryId - Entry ID that was polled
 * @param {Object} status - Status object from server
 */
_handleStatusUpdate(entryId, status) {
    const obj = this.objects.get(entryId);
    if (!obj) {
        this.stopStatusPolling(entryId);
        return;
    }

    // Update object status
    const previousStatus = obj.getStatus();
    obj.setStatus(status.status);

    // Handle status transitions
    if (status.status === 'running' && previousStatus === 'booting') {
        // Boot completed successfully
        console.log(`[DesktopObjectManager] ${entryId} boot completed`);
        this.emit('boot-completed', { entryId, status, object: obj });
        this.stopStatusPolling(entryId);
    } else if (status.status === 'error') {
        // Boot failed
        console.log(`[DesktopObjectManager] ${entryId} boot failed:`, status.error_message);
        this.emit('boot-failed', { entryId, status, object: obj });
        obj.failBootProgress(status.error_message);
        this.stopStatusPolling(entryId);
    } else if (status.status === 'stopped') {
        // Process stopped
        this.stopStatusPolling(entryId);
    }

    // Store additional status info on object
    obj._statusInfo = status;

    this.emit('status-updated', { entryId, status, object: obj });
}

/**
 * Get detailed status info for an object
 * @param {string} entryId - Entry ID
 * @returns {Object|null} Status info or null
 */
getStatusInfo(entryId) {
    const obj = this.objects.get(entryId);
    return obj?._statusInfo || null;
}
```

Update bootObject() to start polling after boot request (around line 352):

Replace the existing bootObject() method with:

```javascript
/**
 * Boot an object (trigger container start)
 * @param {string} entryId - Entry ID to boot
 * @param {Object} options - Boot options
 * @returns {Promise<Object|null>}
 */
async bootObject(entryId, options = {}) {
    const obj = this.objects.get(entryId);

    if (!obj) {
        console.warn(`[DesktopObjectManager] Cannot boot non-existent object ${entryId}`);
        return null;
    }

    // Update status to booting
    obj.setStatus('booting');

    try {
        const result = await this.bridge.bootEntry(entryId, options);

        if (result && result.success) {
            // Start polling for status updates
            this.startStatusPolling(entryId);
            this.emit('boot-started', { object: obj, entryId, result });
        } else {
            // Boot failed immediately
            obj.setStatus('error');
            obj.failBootProgress(result?.error_message || 'Boot failed');
            this.emit('boot-failed', { object: obj, entryId, error: result?.error_message });
        }

        return result;
    } catch (error) {
        obj.setStatus('error');
        obj.failBootProgress(error.message || 'Boot failed');
        console.error(`[DesktopObjectManager] Boot failed for ${entryId}:`, error);
        this.emit('boot-failed', { object: obj, entryId, error: error.message });
        return null;
    }
}
```
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/DesktopObjectManager.js', 'utf8'); console.log(code.includes('startStatusPolling') && code.includes('_handleStatusUpdate') ? 'OK' : 'FAIL')"</verify>
  <done>Status polling added to DesktopObjectManager</done>
</task>

<task type="auto">
  <name>Task 6: Clean up pollers on destroy</name>
  <files>systems/visual_shell/web/DesktopObjectManager.js</files>
  <action>
Update the destroy() and removeObject() methods to clean up pollers.

Update removeObject() to stop polling (around line 168):

Add after const obj = this.objects.get(entryId); check:

```javascript
// Stop any active polling
this.stopStatusPolling(entryId);
```

Update destroy() to clean up all pollers (around line 519):

Add after this.clearAll();:

```javascript
// Stop all status pollers
for (const entryId of this._statusPollers.keys()) {
    this.stopStatusPolling(entryId);
}
```
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/DesktopObjectManager.js', 'utf8'); console.log(code.includes('stopStatusPolling(entryId)') && code.includes('for (const entryId of this._statusPollers.keys())') ? 'OK' : 'FAIL')"</verify>
  <done>Poller cleanup added to destroy methods</done>
</task>

</tasks>

<verification>
- [ ] CatalogServer has _boot_status tracking dictionary
- [ ] CatalogServer.get_status() returns status info
- [ ] CatalogServer.update_boot_status() updates status
- [ ] boot_entry() tracks status throughout boot
- [ ] GET /api/v1/catalog/{entry_id}/status endpoint exists
- [ ] StatusResponse model defines response format
- [ ] CatalogBridge.getStatus() fetches status from API
- [ ] CatalogBridge.pollStatus() polls for updates
- [ ] DesktopObjectManager.startStatusPolling() starts polling
- [ ] DesktopObjectManager._handleStatusUpdate() updates UI
- [ ] bootObject() starts polling after boot request
- [ ] Pollers cleaned up on destroy
</verification>

<success_criteria>
- Backend tracks PID and status for each booted container
- Status endpoint returns current status with uptime info
- Frontend polls status during boot and updates UI
- Status indicator shows correct colors (gray/green/red)
- Process death detected and reflected in UI
- Polling stops when boot completes or fails
</success_criteria>

<output>
After completion, create `.planning/phases/06-boot-progress-integration/06-02-SUMMARY.md`
</output>
