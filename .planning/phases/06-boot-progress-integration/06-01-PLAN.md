---
phase: 06-boot-progress-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - systems/visual_shell/web/RTSDesktopObject.js
autonomous: true

must_haves:
  truths:
    - "Progress bar overlay appears on RTSDesktopObject during boot"
    - "Progress shows percentage (0-100%) with stage label"
    - "Booting status shows yellow/orange pulsing animation"
    - "Progress bar fills based on elapsed time"
  artifacts:
    - path: "systems/visual_shell/web/RTSDesktopObject.js"
      provides: "Progress bar overlay and boot status visualization"
      exports: ["RTSDesktopObject"]
      contains: ["_createProgressBar", "setProgress", "BOOT_STAGES"]
  key_links:
    - from: "RTSDesktopObject._createProgressBar()"
      to: "PIXI.Graphics"
      via: "overlay on thumbnail container"
      pattern: "progressBar|progressFill"
    - from: "RTSDesktopObject.setStatus('booting')"
      to: "_startPulse()"
      via: "triggers pulse animation"
      pattern: "booting.*pulse|_startPulse"
---

<objective>
Add a visual progress bar overlay to RTSDesktopObject that shows boot progress during container startup. The progress bar displays on the thumbnail with percentage and stage label (e.g., "Loading kernel... 45%").

Purpose: Satisfy BOOT-01 requirement - users see a progress indicator during QEMU boot launch (>1 second operations).
Output: Updated RTSDesktopObject.js with progress bar overlay and boot stage system
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-boot-progress-integration/06-CONTEXT.md

# Existing implementation to extend
@systems/visual_shell/web/RTSDesktopObject.js

# Design decisions from context
- Progress bar: Linear 0-100% with stage labels
- Position: Overlay on thumbnail + details in side panel
- Animation: Pulse while booting (already implemented)
- Boot stages: Starting QEMU -> Loading kernel -> Initializing -> Ready
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add boot stage constants and progress state</name>
  <files>systems/visual_shell/web/RTSDesktopObject.js</files>
  <action>
Add boot stage definitions and progress tracking state to RTSDesktopObject.

Add after the existing STATUS_COLORS static property (around line 30):

```javascript
/**
 * Boot stages with labels and timing percentages
 * @static
 */
static BOOT_STAGES = {
    STARTING: { label: 'Starting QEMU...', startPercent: 0, endPercent: 25 },
    LOADING: { label: 'Loading kernel...', startPercent: 25, endPercent: 60 },
    INITIALIZING: { label: 'Initializing...', startPercent: 60, endPercent: 90 },
    READY: { label: 'Ready', startPercent: 90, endPercent: 100 }
};

/**
 * Progress bar dimensions
 * @static
 */
static PROGRESS = {
    BAR_HEIGHT: 4,
    BAR_PADDING: 2,
    BACKGROUND_COLOR: 0x333333,
    FILL_COLOR: 0x00aaff,
    TEXT_COLOR: 0xffffff,
    TIMEOUT_MS: 30000  // 30 second boot timeout
};
```

Add to constructor (after this._pulseTime = 0, around line 71):

```javascript
// Progress tracking state
this._progressPercent = 0;
this._progressStage = null;
this._bootStartTime = null;
this._progressAnimationId = null;
```
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/RTSDesktopObject.js', 'utf8'); console.log(code.includes('BOOT_STAGES') && code.includes('PROGRESS') ? 'OK' : 'FAIL')"</verify>
  <done>Boot stage constants and progress state added to RTSDesktopObject</done>
</task>

<task type="auto">
  <name>Task 2: Create progress bar visual components</name>
  <files>systems/visual_shell/web/RTSDesktopObject.js</files>
  <action>
Add methods to create and manage the progress bar overlay.

Add after _createStatusIndicator() method (around line 226):

```javascript
/**
 * Create the progress bar overlay
 * @private
 */
_createProgressBar() {
    const { THUMBNAIL_SIZE, OBJECT_WIDTH, PADDING } = RTSDesktopObject.DIMENSIONS;
    const { BAR_HEIGHT, BAR_PADDING, BACKGROUND_COLOR, TEXT_COLOR } = RTSDesktopObject.PROGRESS;

    // Progress bar container (hidden by default)
    this.progressContainer = new PIXI.Container();
    this.progressContainer.visible = false;
    this.progressContainer.x = (OBJECT_WIDTH - THUMBNAIL_SIZE) / 2;
    this.progressContainer.y = PADDING + 4 + THUMBNAIL_SIZE - BAR_HEIGHT - BAR_PADDING;
    this.addChild(this.progressContainer);

    // Background bar
    this.progressBackground = new PIXI.Graphics();
    this.progressBackground.rect(0, 0, THUMBNAIL_SIZE, BAR_HEIGHT);
    this.progressBackground.fill({ color: BACKGROUND_COLOR, alpha: 0.8 });
    this.progressContainer.addChild(this.progressBackground);

    // Fill bar (width updated based on progress)
    this.progressFill = new PIXI.Graphics();
    this.progressContainer.addChild(this.progressFill);

    // Stage label text
    this.progressLabel = new PIXI.Text({
        text: '',
        style: {
            fontFamily: 'Courier New, monospace',
            fontSize: 9,
            fill: TEXT_COLOR,
            align: 'center'
        }
    });
    this.progressLabel.x = THUMBNAIL_SIZE / 2;
    this.progressLabel.y = -14;  // Above the bar
    this.progressLabel.anchor.set(0.5, 0);
    this.progressContainer.addChild(this.progressLabel);
}

/**
 * Update progress bar fill
 * @private
 * @param {number} percent - Progress percentage (0-100)
 */
_drawProgressFill(percent) {
    const { THUMBNAIL_SIZE } = RTSDesktopObject.DIMENSIONS;
    const { BAR_HEIGHT, FILL_COLOR } = RTSDesktopObject.PROGRESS;

    const fillWidth = Math.max(0, Math.min(THUMBNAIL_SIZE, (percent / 100) * THUMBNAIL_SIZE));

    this.progressFill.clear();
    if (fillWidth > 0) {
        this.progressFill.rect(0, 0, fillWidth, BAR_HEIGHT);
        this.progressFill.fill({ color: FILL_COLOR, alpha: 0.9 });
    }
}
```

Call _createProgressBar() in constructor after _createStatusIndicator():
```javascript
this._createProgressBar();  // Add after this._createStatusIndicator();
```
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/RTSDesktopObject.js', 'utf8'); console.log(code.includes('_createProgressBar') && code.includes('progressContainer') ? 'OK' : 'FAIL')"</verify>
  <done>Progress bar visual components created</done>
</task>

<task type="auto">
  <name>Task 3: Add setProgress() method for progress updates</name>
  <files>systems/visual_shell/web/RTSDesktopObject.js</files>
  <action>
Add the public setProgress() method to update progress display.

Add after setStatus() method (around line 460):

```javascript
/**
 * Set the boot progress
 * @param {number} percent - Progress percentage (0-100)
 * @param {string} stageLabel - Optional stage label to display
 */
setProgress(percent, stageLabel = null) {
    this._progressPercent = Math.max(0, Math.min(100, percent));

    // Update fill bar
    this._drawProgressFill(this._progressPercent);

    // Update label
    if (stageLabel) {
        this.progressLabel.text = `${stageLabel} ${Math.round(this._progressPercent)}%`;
    } else {
        this.progressLabel.text = `${Math.round(this._progressPercent)}%`;
    }

    // Show progress container
    this.progressContainer.visible = true;
}

/**
 * Hide the progress bar
 */
hideProgress() {
    this.progressContainer.visible = false;
    this._progressPercent = 0;
    this._progressStage = null;
}

/**
 * Get current progress
 * @returns {number} Progress percentage
 */
getProgress() {
    return this._progressPercent;
}
```
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/RTSDesktopObject.js', 'utf8'); console.log(code.includes('setProgress') && code.includes('hideProgress') ? 'OK' : 'FAIL')"</verify>
  <done>setProgress() method added for progress updates</done>
</task>

<task type="auto">
  <name>Task 4: Add time-based progress animation</name>
  <files>systems/visual_shell/web/RTSDesktopObject.js</files>
  <action>
Add automatic progress animation based on elapsed time during boot.

Add after _stopPulse() method (around line 495):

```javascript
/**
 * Start boot progress animation
 * Uses time-based progress estimation
 */
startBootProgress() {
    this._bootStartTime = Date.now();
    this._progressPercent = 0;
    this._progressStage = RTSDesktopObject.BOOT_STAGES.STARTING;

    // Show progress bar
    this.progressContainer.visible = true;
    this.setProgress(0, this._progressStage.label);

    // Start animation loop
    this._updateBootProgress();
}

/**
 * Update boot progress based on elapsed time
 * @private
 */
_updateBootProgress() {
    if (!this._bootStartTime || this._status !== 'booting') {
        return;
    }

    const elapsed = Date.now() - this._bootStartTime;
    const { TIMEOUT_MS } = RTSDesktopObject.PROGRESS;
    const { BOOT_STAGES } = RTSDesktopObject;

    // Check for timeout
    if (elapsed >= TIMEOUT_MS) {
        this.setStatus('error');
        this.setProgress(100, 'Boot timeout');
        return;
    }

    // Calculate progress based on elapsed time
    // Progress advances faster in early stages, slower later
    const rawPercent = (elapsed / TIMEOUT_MS) * 100;

    // Determine current stage and adjust progress
    let stage = BOOT_STAGES.STARTING;
    let displayPercent = rawPercent;

    if (rawPercent < BOOT_STAGES.STARTING.endPercent) {
        stage = BOOT_STAGES.STARTING;
        displayPercent = rawPercent;
    } else if (rawPercent < BOOT_STAGES.LOADING.endPercent) {
        stage = BOOT_STAGES.LOADING;
        displayPercent = BOOT_STAGES.STARTING.endPercent +
            (rawPercent - BOOT_STAGES.STARTING.endPercent);
    } else if (rawPercent < BOOT_STAGES.INITIALIZING.endPercent) {
        stage = BOOT_STAGES.INITIALIZING;
        displayPercent = BOOT_STAGES.LOADING.endPercent +
            (rawPercent - BOOT_STAGES.LOADING.endPercent);
    } else {
        stage = BOOT_STAGES.READY;
        displayPercent = Math.min(99, rawPercent);  // Cap at 99% until actually ready
    }

    this._progressStage = stage;
    this.setProgress(displayPercent, stage.label);

    // Continue animation
    this._progressAnimationId = requestAnimationFrame(() => this._updateBootProgress());
}

/**
 * Complete boot progress (called when boot succeeds)
 */
completeBootProgress() {
    if (this._progressAnimationId) {
        cancelAnimationFrame(this._progressAnimationId);
        this._progressAnimationId = null;
    }

    this._bootStartTime = null;
    this.setProgress(100, RTSDesktopObject.BOOT_STAGES.READY.label);

    // Hide progress after short delay
    setTimeout(() => {
        this.hideProgress();
    }, 500);
}

/**
 * Fail boot progress with error
 * @param {string} errorMessage - Error message to display
 */
failBootProgress(errorMessage) {
    if (this._progressAnimationId) {
        cancelAnimationFrame(this._progressAnimationId);
        this._progressAnimationId = null;
    }

    this._bootStartTime = null;
    this.setStatus('error');

    // Show error on progress bar
    this.progressFill.clear();
    this.progressFill.rect(0, 0, RTSDesktopObject.DIMENSIONS.THUMBNAIL_SIZE, RTSDesktopObject.PROGRESS.BAR_HEIGHT);
    this.progressFill.fill({ color: 0xff0000, alpha: 0.9 });  // Red for error

    this.progressLabel.text = errorMessage || 'Boot failed';
    this.progressLabel.style.fill = 0xff6666;
    this.progressContainer.visible = true;
}
```
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/RTSDesktopObject.js', 'utf8'); console.log(code.includes('startBootProgress') && code.includes('completeBootProgress') && code.includes('failBootProgress') ? 'OK' : 'FAIL')"</verify>
  <done>Time-based progress animation added</done>
</task>

<task type="auto">
  <name>Task 5: Update setStatus to integrate with progress</name>
  <files>systems/visual_shell/web/RTSDesktopObject.js</files>
  <action>
Update setStatus() to start progress animation when entering 'booting' state.

Replace the existing setStatus() method (around line 450) with:

```javascript
/**
 * Set the status of the object
 * @param {string} status - Status value (idle, booting, running, error, stopped, unknown)
 */
setStatus(status) {
    this._status = status;
    const color = RTSDesktopObject.STATUS_COLORS[status] || RTSDesktopObject.STATUS_COLORS.unknown;
    this._drawStatusCircle(color);

    // Handle status-specific behavior
    if (status === 'booting') {
        this._startPulse();
        this.startBootProgress();  // Start progress animation
    } else if (status === 'running') {
        this._stopPulse();
        this.completeBootProgress();  // Complete and hide progress
    } else if (status === 'error') {
        this._stopPulse();
        // Progress bar shows error state via failBootProgress()
    } else {
        this._stopPulse();
        this.hideProgress();  // Hide progress for other states
    }
}
```
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/RTSDesktopObject.js', 'utf8'); console.log(code.includes('startBootProgress') && code.includes(\"status === 'booting'\") ? 'OK' : 'FAIL')"</verify>
  <done>setStatus() integrated with progress animation</done>
</task>

<task type="auto">
  <name>Task 6: Clean up resources on destroy</name>
  <files>systems/visual_shell/web/RTSDesktopObject.js</files>
  <action>
Update the destroy() method to clean up progress animation.

Add to the destroy() method (before super.destroy(), around line 615):

```javascript
// Cancel progress animation
if (this._progressAnimationId) {
    cancelAnimationFrame(this._progressAnimationId);
    this._progressAnimationId = null;
}
```
</action>
  <verify>node -e "const fs = require('fs'); const code = fs.readFileSync('systems/visual_shell/web/RTSDesktopObject.js', 'utf8'); console.log(code.includes('cancelAnimationFrame') && code.includes('_progressAnimationId') ? 'OK' : 'FAIL')"</verify>
  <done>Progress animation cleanup added to destroy()</done>
</task>

</tasks>

<verification>
- [ ] BOOT_STAGES constant defines 4 stages with labels and percentages
- [ ] PROGRESS constant defines bar dimensions and colors
- [ ] _createProgressBar() creates progress container with background, fill, and label
- [ ] setProgress() updates fill width and label text
- [ ] startBootProgress() starts time-based animation
- [ ] completeBootProgress() completes and hides progress bar
- [ ] failBootProgress() shows red error state
- [ ] setStatus('booting') starts progress animation
- [ ] setStatus('running') completes progress
- [ ] destroy() cancels progress animation
</verification>

<success_criteria>
- Progress bar appears when container enters 'booting' status
- Progress bar shows percentage (0-100%) with stage label
- Progress advances based on elapsed time
- Yellow/orange pulse animation plays during boot
- Progress bar hides when boot completes or fails
- Boot timeout at 30 seconds shows error state
</success_criteria>

<output>
After completion, create `.planning/phases/06-boot-progress-integration/06-01-SUMMARY.md`
</output>
