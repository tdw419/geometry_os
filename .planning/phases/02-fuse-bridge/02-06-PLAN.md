---
phase: 02-fuse-bridge
plan: 06
type: execute
wave: 6
depends_on: ["02-05"]
files_modified:
  - systems/pixel_compiler/tests/test_boot_bridge.py
autonomous: false
user_setup: []

must_haves:
  truths:
    - "BootBridge unit tests verify mount/unmount behavior"
    - "BootBridge unit tests verify boot file discovery"
    - "BootBridge unit tests verify cleanup on error"
  artifacts:
    - path: "systems/pixel_compiler/tests/test_boot_bridge.py"
      provides: "BootBridge unit tests"
      min_lines: 200
  key_links:
    - from: "systems/pixel_compiler/tests/test_boot_bridge.py"
      to: "systems/pixel_compiler/boot/boot_bridge.py"
      via: "BootBridge import"
      pattern: "from systems.pixel_compiler.boot import BootBridge"
---

<objective>
Create unit tests for BootBridge and MountHelper.

Purpose: Verify the FUSE bridge components work correctly, including mount lifecycle, boot file discovery, and cleanup behavior.

Output: Test file with comprehensive coverage of boot components.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-fuse-bridge/02-RESEARCH.md

@systems/pixel_compiler/boot/boot_bridge.py
@systems/pixel_compiler/boot/mount_helper.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BootBridge unit tests</name>
  <files>systems/pixel_compiler/tests/test_boot_bridge.py</files>
  <action>
Create comprehensive unit tests for boot components.

1. Create test file with these test classes:

```python
#!/usr/bin/env python3
"""
Unit tests for BootBridge and MountHelper.

Tests cover:
- MountHelper lifecycle (mount/unmount)
- Boot file discovery from metadata
- BootBridge boot flow
- Cleanup on error/signal
- Progress display
"""

import os
import sys
import json
import tempfile
import unittest
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock

# Add project root
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

from systems.pixel_compiler.boot import (
    MountHelper, MountError,
    BootBridge, BootResult,
    BootProgress, ProgressStage
)


class TestMountHelper(unittest.TestCase):
    """Tests for MountHelper class."""

    def test_init_with_path(self):
        """MountHelper initializes with rts path."""
        mh = MountHelper("/path/to/file.rts.png")
        self.assertEqual(str(mh.rts_path), "/path/to/file.rts.png")
        self.assertIsNone(mh.mountpoint)

    def test_init_with_custom_mountpoint(self):
        """MountHelper accepts custom mountpoint."""
        mh = MountHelper("/path/to/file.rts.png", mountpoint="/mnt/custom")
        self.assertEqual(str(mh.mountpoint), "/mnt/custom")

    def test_discover_boot_files_kernel_patterns(self):
        """discover_boot_files finds kernel patterns."""
        # Mock metadata with kernel
        mh = MountHelper("/nonexistent.png")
        mh._metadata = {
            'segments': {
                'vmlinuz': {'size': 1000},
                'initrd.img': {'size': 5000}
            }
        }
        kernel, initrd = mh.discover_boot_files()
        self.assertEqual(kernel, 'vmlinuz')
        self.assertEqual(initrd, 'initrd.img')

    def test_discover_boot_files_no_kernel(self):
        """discover_boot_files returns None when no kernel found."""
        mh = MountHelper("/nonexistent.png")
        mh._metadata = {'segments': {'config.txt': {'size': 100}}}
        kernel, initrd = mh.discover_boot_files()
        self.assertIsNone(kernel)
        self.assertIsNone(initrd)

    def test_context_manager_cleanup(self):
        """MountHelper context manager cleans up on exit."""
        with MountHelper("/nonexistent.png") as mh:
            # Even if we don't mount, cleanup should not fail
            pass
        # No exception means success


class TestBootBridge(unittest.TestCase):
    """Tests for BootBridge class."""

    def test_init_parameters(self):
        """BootBridge stores parameters correctly."""
        bb = BootBridge(
            "/path/to/file.rts.png",
            memory="4G",
            cpus=4,
            vnc_display=1,
            verbose=False
        )
        self.assertEqual(str(bb.rts_path), "/path/to/file.rts.png")
        self.assertEqual(bb.memory, "4G")
        self.assertEqual(bb.cpus, 4)
        self.assertEqual(bb.vnc_display, 1)
        self.assertFalse(bb.verbose)

    def test_boot_result_dataclass(self):
        """BootResult dataclass stores fields correctly."""
        result = BootResult(
            success=True,
            process=None,
            mountpoint=Path("/mnt/test"),
            vnc_port=5900,
            serial_socket=Path("/tmp/serial.sock"),
            error_message=None
        )
        self.assertTrue(result.success)
        self.assertEqual(result.mountpoint, Path("/mnt/test"))

    def test_boot_result_failure(self):
        """BootResult can represent failure."""
        result = BootResult(
            success=False,
            process=None,
            mountpoint=None,
            vnc_port=None,
            serial_socket=None,
            error_message="File not found"
        )
        self.assertFalse(result.success)
        self.assertEqual(result.error_message, "File not found")

    def test_context_manager(self):
        """BootBridge context manager stops on exit."""
        bb = BootBridge("/nonexistent.png")
        # Just verify it's a context manager
        self.assertTrue(hasattr(bb, '__enter__'))
        self.assertTrue(hasattr(bb, '__exit__'))


class TestBootProgress(unittest.TestCase):
    """Tests for BootProgress class."""

    def test_init_verbose(self):
        """BootProgress verbose mode."""
        bp = BootProgress(verbose=True)
        self.assertTrue(bp.verbose)

    def test_init_quiet(self):
        """BootProgress quiet mode."""
        bp = BootProgress(verbose=False)
        self.assertFalse(bp.verbose)

    def test_stage_progression(self):
        """ProgressStage enum has all stages."""
        stages = list(ProgressStage)
        self.assertIn(ProgressStage.PARSING_METADATA, stages)
        self.assertIn(ProgressStage.MOUNTING_FUSE, stages)
        self.assertIn(ProgressStage.STARTING_QEMU, stages)
        self.assertIn(ProgressStage.BOOT_COMPLETE, stages)

    def test_tty_detection(self):
        """BootProgress detects TTY."""
        bp = BootProgress()
        # Just verify the attribute exists
        self.assertTrue(hasattr(bp, 'is_tty'))


if __name__ == "__main__":
    unittest.main()
```

2. The tests cover:
   - MountHelper initialization and parameters
   - Boot file discovery logic
   - BootBridge initialization and context manager
   - BootResult dataclass
   - BootProgress stages and TTY detection

3. Note: Actual FUSE mount tests require root/special permissions, so mock those.
</action>
  <verify>
```bash
cd /home/jericho/zion/projects/geometry_os/geometry_os
python3 -m pytest systems/pixel_compiler/tests/test_boot_bridge.py -v
```
  </verify>
  <done>
Unit tests pass for MountHelper, BootBridge, and BootProgress.
</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
BootBridge unit tests for FUSE mount lifecycle, boot file discovery, and cleanup behavior.
  </what-built>
  <how-to-verify>
1. Run tests: `python3 -m pytest systems/pixel_compiler/tests/test_boot_bridge.py -v`
2. Verify all tests pass (or skip appropriately for permissions)
3. Check that test coverage includes:
   - MountHelper init and discover_boot_files
   - BootBridge init and context manager
   - BootResult dataclass
   - BootProgress stages
  </how-to-verify>
  <resume-signal>Type "approved" if tests pass, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. Test file exists at systems/pixel_compiler/tests/test_boot_bridge.py
2. Tests can be run with pytest
3. MountHelper tests cover initialization and discovery
4. BootBridge tests cover initialization and context manager
5. BootProgress tests cover stages and TTY detection
</verification>

<success_criteria>
- Unit tests provide coverage of boot components
- Tests can be run in CI without special permissions
- Tests follow existing test patterns in codebase
</success_criteria>

<output>
After completion, create `.planning/phases/02-fuse-bridge/02-06-SUMMARY.md`
</output>
