---
phase: 02-fuse-bridge
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - systems/pixel_compiler/boot/__init__.py
  - systems/pixel_compiler/boot/boot_bridge.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "BootBridge orchestrates FUSE mount + QEMU boot in single call"
    - "BootBridge passes kernel/initrd paths from FUSE mount to QEMU"
    - "BootBridge cleans up both FUSE and QEMU on exit"
  artifacts:
    - path: "systems/pixel_compiler/boot/boot_bridge.py"
      provides: "Unified boot orchestration"
      exports: ["BootBridge", "BootResult"]
      min_lines: 200
  key_links:
    - from: "systems/pixel_compiler/boot/boot_bridge.py"
      to: "systems/pixel_compiler/boot/mount_helper.py"
      via: "MountHelper context manager"
      pattern: "from .mount_helper import MountHelper"
    - from: "systems/pixel_compiler/boot/boot_bridge.py"
      to: "systems/pixel_compiler/integration/qemu_boot.py"
      via: "QemuBoot class"
      pattern: "from systems.pixel_compiler.integration.qemu_boot import QemuBoot"
---

<objective>
Create the BootBridge class that orchestrates FUSE mount + QEMU boot.

Purpose: Provide a single interface to boot .rts.png files by mounting FUSE and passing kernel/initrd paths to QEMU. This is the core integration layer.

Output: BootBridge class with boot() method and cleanup handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-fuse-bridge/02-RESEARCH.md

@systems/pixel_compiler/integration/qemu_boot.py
@systems/pixel_compiler/boot/mount_helper.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement BootBridge class</name>
  <files>systems/pixel_compiler/boot/boot_bridge.py</files>
  <action>
Create BootBridge class that orchestrates the full boot pipeline.

**DIRECT-01: Boot .rts.png files without manual extraction**
**DIRECT-02: FUSE filesystem presents PNG as kernel/initrd for boot**
**DIRECT-03: Boot completes with less than 10% overhead**
**DIRECT-04: Proper cleanup after boot completes or fails**

1. Create `BootResult` dataclass:
   ```python
   @dataclass
   class BootResult:
       success: bool
       process: Optional[subprocess.Popen]
       mountpoint: Optional[Path]
       vnc_port: Optional[int]
       serial_socket: Optional[Path]
       error_message: Optional[str]
   ```

2. Create `BootBridge` class:
   ```python
   class BootBridge:
       def __init__(
           self,
           rts_png_path: str,
           memory: str = "2G",
           cpus: int = 2,
           vnc_display: int = 0
       ):
           self.rts_path = Path(rts_png_path)
           self.memory = memory
           self.cpus = cpus
           self.vnc_display = vnc_display

           self._mount_helper: Optional[MountHelper] = None
           self._qemu: Optional[QemuBoot] = None

       def boot(
           self,
           cmdline: Optional[str] = None,
           extra_qemu_args: Optional[List[str]] = None
       ) -> BootResult:
           """Boot the .rts.png with single call."""
           ...

       def stop(self) -> None:
           """Stop QEMU and unmount FUSE."""
           ...

       def get_status(self) -> Dict[str, Any]:
           """Get current boot status."""
           ...

       def __enter__(self):
           return self

       def __exit__(self, exc_type, exc_val, exc_tb):
           self.stop()
           return False
   ```

3. The `boot()` method must:
   - Use MountHelper context manager to mount FUSE
   - Call `discover_boot_files()` to find kernel/initrd paths
   - Create QemuBoot instance with memory/cpus config
   - Call `qemu.boot(kernel=..., initrd=..., cmdline=...)`
   - Return BootResult with process info
   - Handle all exceptions and return BootResult with error_message

4. The `stop()` method must:
   - Call `qemu.stop()` if QEMU is running
   - MountHelper context manager handles FUSE cleanup automatically

5. For DIRECT-03 (<10% overhead):
   - Reuse existing LRU cache from `infinite_map_cache.py`
   - Enable KVM acceleration in QEMU by default
   - Stream kernel/initrd directly from FUSE (no intermediate files)
</action>
  <verify>
```bash
cd /home/jericho/zion/projects/geometry_os/geometry_os
python3 -c "
from systems.pixel_compiler.boot.boot_bridge import BootBridge, BootResult
print('BootBridge class exists')
print('BootResult dataclass exists')
bb = BootBridge('/nonexistent.png')
print('BootBridge instantiates')
print('boot method:', hasattr(bb, 'boot'))
print('stop method:', hasattr(bb, 'stop'))
"
```
  </verify>
  <done>
BootBridge orchestrates FUSE mount + QEMU boot with single boot() call and proper cleanup.
</done>
</task>

<task type="auto">
  <name>Task 2: Update boot package exports</name>
  <files>systems/pixel_compiler/boot/__init__.py</files>
  <action>
Update __init__.py to export BootBridge and BootResult:

```python
from .mount_helper import MountHelper, MountError
from .boot_bridge import BootBridge, BootResult

__all__ = ["MountHelper", "MountError", "BootBridge", "BootResult"]
```
  </action>
  <verify>
```bash
python3 -c "from systems.pixel_compiler.boot import BootBridge, BootResult; print('OK')"
```
  </verify>
  <done>
Boot package exports all boot components.
</done>
</task>

</tasks>

<verification>
1. BootBridge class exists with boot(), stop(), get_status() methods
2. BootBridge uses MountHelper for FUSE mount
3. BootBridge creates QemuBoot with discovered kernel/initrd
4. BootResult dataclass contains process/mountpoint/error info
5. Context manager pattern works correctly
</verification>

<success_criteria>
- BootBridge provides unified boot interface
- FUSE and QEMU lifecycle properly managed
- All exceptions handled gracefully
- Code integrates with existing QemuBoot class
</success_criteria>

<output>
After completion, create `.planning/phases/02-fuse-bridge/02-02-SUMMARY.md`
</output>
