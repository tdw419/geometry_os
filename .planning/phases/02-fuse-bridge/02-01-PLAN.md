---
phase: 02-fuse-bridge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - systems/pixel_compiler/boot/__init__.py
  - systems/pixel_compiler/boot/mount_helper.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "FUSE mount can be created at a temporary mountpoint"
    - "FUSE mount exposes kernel and initrd as readable files"
    - "FUSE mount is cleaned up properly on exit or error"
  artifacts:
    - path: "systems/pixel_compiler/boot/__init__.py"
      provides: "Package initialization with exports"
      min_lines: 10
    - path: "systems/pixel_compiler/boot/mount_helper.py"
      provides: "FUSE mount lifecycle management"
      exports: ["MountHelper", "MountError"]
      min_lines: 150
  key_links:
    - from: "systems/pixel_compiler/boot/mount_helper.py"
      to: "systems/rts_fuse/filesystem.py"
      via: "RTSFilesystem class"
      pattern: "from systems.rts_fuse.filesystem"
    - from: "systems/pixel_compiler/boot/mount_helper.py"
      to: "systems/pixel_compiler/infinite_map_fuse.py"
      via: "InfiniteMapContainer for VAT"
      pattern: "InfiniteMapContainer|mount_infinite_map"
---

<objective>
Create the FUSE mount lifecycle management infrastructure.

Purpose: Enable safe, clean FUSE mount/unmount operations with automatic cleanup on errors or signals. This is the foundation layer that the BootBridge will use.

Output: MountHelper class with context manager support and signal handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-fuse-bridge/02-RESEARCH.md

@systems/rts_fuse/filesystem.py
@systems/pixel_compiler/infinite_map_fuse.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create boot package structure</name>
  <files>systems/pixel_compiler/boot/__init__.py</files>
  <action>
Create the boot package directory and init file.

1. Create directory: `systems/pixel_compiler/boot/`
2. Create `__init__.py` with exports:
   - `from .mount_helper import MountHelper, MountError`
   - `from .boot_bridge import BootBridge` (will be added in plan 02)
   - `__all__ = ["MountHelper", "MountError", "BootBridge"]`

This follows the existing package pattern in `systems/pixel_compiler/integration/__init__.py`.
  </action>
  <verify>
```bash
python3 -c "from systems.pixel_compiler.boot import MountHelper; print('OK')" 2>&1 || echo "Import failed"
```
  </verify>
  <done>
Package `systems.pixel_compiler.boot` exists and exports MountHelper (will fail until Task 2 complete).
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement MountHelper class</name>
  <files>systems/pixel_compiler/boot/mount_helper.py</files>
  <action>
Create MountHelper class that manages FUSE mount lifecycle with these requirements:

**DIRECT-04 compliance: Proper cleanup with no resource leaks**

1. Create `MountError` exception class

2. Create `MountHelper` class with:
   - `__init__(self, rts_png_path: str, mountpoint: Optional[str] = None)`
   - `mount(self) -> Path` - Mount FUSE, return mountpoint path
   - `unmount(self) -> None` - Lazy unmount with `fusermount -uz`
   - `discover_boot_files(self) -> Tuple[Optional[str], Optional[str]]` - Find kernel/initrd from VAT/metadata
   - Context manager support (`__enter__`, `__exit__`)
   - atexit handler registration for cleanup on crash
   - Signal handlers for SIGTERM, SIGINT

3. Key implementation details:
   - Use `tempfile.mkdtemp(prefix="pixelrts_boot_")` for mountpoint
   - Use existing `systems/rts_fuse/filesystem.py` `RTSFilesystem` class (NOT mount_rtsfs function, as it blocks)
   - Run FUSE with `foreground=False` in a daemon thread
   - Parse metadata using `PixelRTSDecoder` from `pixelrts_v2_core.py`
   - Look for kernel patterns: `kernel`, `vmlinuz`, `vmlinux`, `bzImage`
   - Look for initrd patterns: `initrd`, `initramfs`, `initrd.img`

4. From RESEARCH.md Pitfall 1:
   ```python
   import atexit
   import signal
   import subprocess
   import threading

   class MountHelper:
       def __init__(self, rts_png_path: str, mountpoint: Optional[str] = None):
           self.rts_path = Path(rts_png_path)
           self.mountpoint = Path(mountpoint) if mountpoint else None
           self._fuse_thread: Optional[threading.Thread] = None
           self._fs: Optional[RTSFilesystem] = None

           atexit.register(self._force_cleanup)
           signal.signal(signal.SIGTERM, self._signal_handler)
           signal.signal(signal.SIGINT, self._signal_handler)
   ```

5. The `_force_cleanup` method must use lazy unmount (`fusermount -uz`) to handle stuck mounts.
  </action>
  <verify>
```bash
cd /home/jericho/zion/projects/geometry_os/geometry_os
python3 -c "
from systems.pixel_compiler.boot.mount_helper import MountHelper, MountError
print('MountHelper class exists')
print('MountError exception exists')
mh = MountHelper('/nonexistent.png')
print('MountHelper instantiates')
"
```
  </verify>
  <done>
MountHelper class provides context manager for FUSE mount/unmount with automatic cleanup on signals and exit.
</done>
</task>

</tasks>

<verification>
1. Package `systems.pixel_compiler.boot` can be imported
2. MountHelper class exists with mount/unmount/discover_boot_files methods
3. MountHelper works as context manager
4. atexit and signal handlers are registered
5. discover_boot_files() parses metadata to find kernel/initrd patterns
</verification>

<success_criteria>
- MountHelper provides safe FUSE mount lifecycle
- Cleanup handles crashes and signals properly
- Boot file discovery works from metadata
- Code follows existing patterns in codebase
</success_criteria>

<output>
After completion, create `.planning/phases/02-fuse-bridge/02-01-SUMMARY.md`
</output>
