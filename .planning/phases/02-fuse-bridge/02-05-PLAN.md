---
phase: 02-fuse-bridge
plan: 05
type: execute
wave: 5
depends_on: ["02-04"]
files_modified:
  - systems/pixel_compiler/pixelrts_cli.py
  - bin/pixelrts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can run pixelrts boot <file.png> to boot .rts.png files"
    - "CLI accepts memory, cpus, vnc, and other boot options"
    - "CLI returns appropriate exit codes for success/failure"
  artifacts:
    - path: "systems/pixel_compiler/pixelrts_cli.py"
      provides: "CLI boot subcommand"
      contains: "cmd_boot function"
      min_lines_add: 80
  key_links:
    - from: "systems/pixel_compiler/pixelrts_cli.py"
      to: "systems/pixel_compiler/boot/boot_bridge.py"
      via: "BootBridge import"
      pattern: "from systems.pixel_compiler.boot import BootBridge"
---

<objective>
Add `pixelrts boot` CLI subcommand for direct PNG boot.

Purpose: INTEGRATION-02 - provide user-facing command to boot .rts.png files with single command. Expose BootBridge functionality through the existing CLI.

Output: `pixelrts boot` subcommand with memory, cpus, vnc options.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-fuse-bridge/02-RESEARCH.md

@systems/pixel_compiler/pixelrts_cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cmd_boot function to CLI</name>
  <files>systems/pixel_compiler/pixelrts_cli.py</files>
  <action>
Add boot command handler to pixelrts_cli.py.

1. Add import at top of file (around line 20-30):
   ```python
   from systems.pixel_compiler.boot import BootBridge, BootResult
   ```

2. Add cmd_boot function (add after existing cmd_* functions, around line 620):
   ```python
   def cmd_boot(args):
       """Handle boot command - boot .rts.png with QEMU."""
       from systems.pixel_compiler.boot import BootBridge

       input_path = Path(args.input)

       if not input_path.exists():
           print(f"Error: Input file not found: {args.input}", file=sys.stderr)
           return 1

       if args.verbose:
           print(f"[*] Booting: {args.input}")

       try:
           with BootBridge(
               str(input_path),
               memory=args.memory,
               cpus=args.cpus,
               vnc_display=args.vnc,
               verbose=args.verbose or not args.quiet
           ) as bridge:
               result = bridge.boot(
                   cmdline=args.cmdline,
                   extra_qemu_args=args.qemu_arg
               )

               if not result.success:
                   print(f"Error: {result.error_message}", file=sys.stderr)
                   return 1

               if args.verbose:
                   print(f"[*] QEMU started with PID {result.process.pid}")
                   if result.vnc_port:
                       print(f"[*] VNC: localhost:{result.vnc_port}")
                   if result.serial_socket:
                       print(f"[*] Serial: {result.serial_socket}")

               if not args.background:
                   # Wait for QEMU to exit
                   result.process.wait()

               return 0

       except KeyboardInterrupt:
           print("\n[*] Boot interrupted")
           return 130
       except Exception as e:
           print(f"Error: {e}", file=sys.stderr)
           if args.verbose:
               import traceback
               traceback.print_exc()
           return 1
   ```

3. Add the boot subparser in main() function (after existing subparsers, around line 900):
   ```python
   # Boot command
   boot_parser = subparsers.add_parser('boot', help='Boot .rts.png with QEMU')
   boot_parser.add_argument('input', help='Input .rts.png file path')
   boot_parser.add_argument('--memory', '-m', default='2G',
                           help='Memory allocation (default: 2G)')
   boot_parser.add_argument('--cpus', '-c', type=int, default=2,
                           help='CPU cores (default: 2)')
   boot_parser.add_argument('--vnc', type=int, default=0,
                           help='VNC display number (default: 0)')
   boot_parser.add_argument('--background', '-b', action='store_true',
                           help='Run in background (don\'t wait for QEMU)')
   boot_parser.add_argument('--cmdline',
                           help='Additional kernel command line parameters')
   boot_parser.add_argument('--qemu-arg', action='append',
                           help='Extra QEMU arguments (can be specified multiple times)')
   boot_parser.add_argument('--quiet', '-q', action='store_true',
                           help='Suppress progress output')
   boot_parser.add_argument('-v', '--verbose', action='store_true',
                           help='Enable verbose output')
   ```

4. Add 'boot': cmd_boot to the handlers dictionary (around line 955):
   ```python
   handlers = {
       'convert': cmd_convert,
       'transpile': cmd_transpile,
       'benchmark': cmd_benchmark,
       'dashboard': cmd_dashboard,
       'info': cmd_info,
       'analyze': cmd_analyze,
       'execute': cmd_execute,
       'vision': cmd_vision,
       'blueprint': lambda args: _dispatch_blueprint(args),
       'boot': cmd_boot,  # ADD THIS LINE
   }
   ```

5. Update the epilog help text to include boot command (around line 725):
   ```python
   epilog="""
   Commands:
     convert      Convert binary files to .rts.png format
     transpile    Transpile native software (source/binary/WASM) to PixelRTS format
     benchmark    Run performance benchmarks
     dashboard    Generate performance dashboard
     info         Display information about .rts.png file
     analyze      Pattern detection analysis (edges, fourier, clusters)
     execute      Execute WASM embedded in .rts.png
     vision       Vision analysis (summary, entropy overlay)
     blueprint    Blueprint management commands
     boot         Boot .rts.png with QEMU (single command)

   Examples:
     ...
     pixelrts boot alpine.rts.png --memory 2G --cpus 4
     pixelrts boot os.rts.png --vnc 1 --background
   """
   ```
  </action>
  <verify>
```bash
cd /home/jericho/zion/projects/geometry_os/geometry_os
python3 -m systems.pixel_compiler.pixelrts_cli boot --help
```
  </verify>
  <done>
CLI has boot subcommand with memory, cpus, vnc, background options.
</done>
</task>

<task type="auto">
  <name>Task 2: Update bin/pixelrts entry point</name>
  <files>bin/pixelrts</files>
  <action>
Ensure bin/pixelrts entry point exposes boot command.

Read the existing bin/pixelrts file and verify it calls the CLI main function. If needed, update to ensure boot is accessible.

The entry point should be:
```python
#!/usr/bin/env python3
import sys
from systems.pixel_compiler.pixelrts_cli import main

if __name__ == "__main__":
    sys.exit(main())
```

Make sure the file is executable:
```bash
chmod +x bin/pixelrts
```
  </action>
  <verify>
```bash
cd /home/jericho/zion/projects/geometry_os/geometry_os
./bin/pixelrts boot --help
```
  </verify>
  <done>
bin/pixelrts exposes boot command.
</done>
</task>

</tasks>

<verification>
1. `pixelrts boot --help` shows boot options
2. `pixelrts boot <file>` works with existing .rts.png
3. Memory, cpus, vnc options are accepted
4. Background mode runs without waiting
5. Exit codes: 0 for success, 1 for error, 130 for interrupt
</verification>

<success_criteria>
- Single command boot works: `pixelrts boot file.png`
- All boot options are accessible via CLI
- Consistent with existing CLI patterns
</success_criteria>

<output>
After completion, create `.planning/phases/02-fuse-bridge/02-05-SUMMARY.md`
</output>
