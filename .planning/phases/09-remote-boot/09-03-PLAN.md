---
phase: 09-remote-boot
plan: 03
type: execute
wave: 3
depends_on: ["09-01", "09-02"]
files_modified:
  - systems/visual_shell/web/RTSDesktopObject.js
  - systems/visual_shell/web/DesktopObjectManager.js
  - systems/visual_shell/web/CatalogCacheManager.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can boot a cached remote container while offline"
    - "User sees a visual badge indicating container is available offline"
    - "Uncached remote containers show 'network required' error when offline"
    - "Stale cache boots immediately with background revalidation"
    - "Cache status updates after successful download"
  artifacts:
    - path: "systems/visual_shell/web/RTSDesktopObject.js"
      provides: "Offline availability badge on desktop objects"
      adds_methods: ["setOfflineAvailable"]
    - path: "systems/visual_shell/web/DesktopObjectManager.js"
      provides: "Cache-first boot path for remote containers"
      modifies: ["_bootRemoteContainer"]
    - path: "systems/visual_shell/web/CatalogCacheManager.js"
      provides: "Cache existence check and offline status"
      adds_methods: ["has", "isOfflineCapable"]
  key_links:
    - from: "DesktopObjectManager"
      to: "CatalogCacheManager"
      via: "has() check before download"
      pattern: "cache\\.has\\("
    - from: "RTSDesktopObject"
      to: "offline badge"
      via: "setOfflineAvailable method"
      pattern: "setOfflineAvailable"
---

<objective>
Implement cache-first boot path for remote containers with offline access indicator.

Purpose: Enable users to boot previously downloaded containers while offline, with visual indication of offline availability. Stale cache entries boot immediately with background revalidation.

Output: Cache-first boot logic, offline availability badge, network detection for uncached remote containers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-remote-boot/09-CONTEXT.md

# Prior plan context
@.planning/phases/09-remote-boot/09-01-PLAN.md
@.planning/phases/09-remote-boot/09-02-PLAN.md

# Existing patterns to follow
@systems/visual_shell/web/RTSDesktopObject.js
@systems/visual_shell/web/DesktopObjectManager.js
@systems/visual_shell/web/CatalogCacheManager.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add offline availability badge to RTSDesktopObject</name>
  <files>systems/visual_shell/web/RTSDesktopObject.js</files>
  <action>
Add offline availability indicator to RTSDesktopObject:

1. **Add OFFLINE_BADGE configuration:**
```javascript
static OFFLINE_BADGE = {
  SIZE: 6,              // Small indicator
  OFFSET_X: 4,          // Bottom-left corner
  OFFSET_Y: -10,        // Below the name label
  COLOR_AVAILABLE: 0x00ff00,  // Green - cached and available offline
  COLOR_UNAVAILABLE: 0x666666 // Gray - not cached, network required
};
```

2. **Create offline badge in constructor:**
   - Small colored dot in bottom-left corner (below name label)
   - Hidden by default for local containers
   - Visible for remote containers

3. **Add setOfflineAvailable method:**
```javascript
setOfflineAvailable(available) {
  // available: boolean
  // - Show green dot if available
  // - Show gray dot if not available (for remote containers)
  // - Hidden entirely for local containers
  this._offlineAvailable = available;
  this._drawOfflineBadge(available);
  this.offlineBadge.visible = this._isRemote; // Only show for remote
}
```

4. **Add offline badge tooltip:**
   - Hover shows "Available offline" or "Network required"
   - Position near badge, similar to server source tooltip

5. **Integrate with existing setServerSource:**
   - Track _isRemote based on serverSourceId presence
   - Auto-show offline badge for remote containers

6. **Update cache status integration:**
   - When setCacheStatus('verified') is called, also setOfflineAvailable(true)
   - When setCacheStatus('uncached') is called, setOfflineAvailable(false)

Badge design: Small 6px green dot in bottom-left corner, distinct from:
- Server source badge (top-left, 8px, server color)
- Cache status indicator (top-right area, verification state)
- Main status indicator (top-right, boot status)

Do NOT add badge for local containers (they're always available).
Do NOT block interaction based on offline status - just indicate.
  </action>
  <verify>
    - Offline badge appears for remote containers
    - Green dot when cached, gray when not cached
    - Hover tooltip shows availability status
    - Badge hidden for local containers
    - setOfflineAvailable() method works
  </verify>
  <done>
    - Remote containers show offline availability badge
    - Badge color indicates cached (green) vs uncached (gray)
    - Tooltip explains availability on hover
    - Local containers have no offline badge
  </done>
</task>

<task type="auto">
  <name>Task 2: Add has() method to CatalogCacheManager</name>
  <files>systems/visual_shell/web/CatalogCacheManager.js</files>
  <action>
Add quick existence check method to CatalogCacheManager:

1. **Add has() method:**
```javascript
/**
 * Quick check if entry exists in cache (without loading data)
 * @param {string} entryId - The entry ID to check
 * @returns {Promise<boolean>} True if entry exists in cache
 */
async has(entryId) {
  const store = await this._getStore('readonly');
  if (!store) {
    return false;
  }

  try {
    // Use IDBKeyRange.only for efficient existence check
    const request = store.getKey(entryId);
    const result = await this._wrapRequest(request, null);
    return result !== undefined && result !== null;
  } catch (error) {
    console.error('[CatalogCacheManager] has() error:', error);
    return false;
  }
}
```

2. **Add isOfflineCapable() method:**
```javascript
/**
 * Check if container can be booted offline
 * Returns true if: entry exists AND verificationStatus is 'verified'
 * @param {string} entryId - The entry ID to check
 * @returns {Promise<boolean>} True if container can be booted offline
 */
async isOfflineCapable(entryId) {
  const store = await this._getStore('readonly');
  if (!store) {
    return false;
  }

  try {
    const entry = await this._wrapRequest(store.get(entryId));
    if (!entry) {
      return false;
    }
    return entry.verificationStatus === 'verified';
  } catch (error) {
    console.error('[CatalogCacheManager] isOfflineCapable() error:', error);
    return false;
  }
}
```

These methods enable fast checks without loading the full container data.

Do NOT load the full data - use getKey() for has() efficiency.
  </action>
  <verify>
    - has() method returns true for cached entries
    - has() returns false for non-existent entries
    - isOfflineCapable() returns true only for verified entries
    - Methods work without loading full data
  </verify>
  <done>
    - CatalogCacheManager.has() enables quick cache existence check
    - CatalogCacheManager.isOfflineCapable() checks verified status
    - Both methods are efficient (no full data load)
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement cache-first boot path in DesktopObjectManager</name>
  <files>systems/visual_shell/web/DesktopObjectManager.js</files>
  <action>
Implement cache-first boot path for remote containers:

1. **Modify _bootRemoteContainer to check cache first:**
```javascript
async _bootRemoteContainer(entryId, entry) {
  const obj = this.objects.get(entryId);
  if (!obj) return;

  // 1. Check if already cached and verified
  const isCached = await this.bridge.cache.isOfflineCapable(entryId);

  if (isCached) {
    // Cache hit - boot immediately from cache
    console.log(`[DesktopObjectManager] Booting ${entryId} from cache`);
    obj.setOfflineAvailable(true);

    // Check staleness for background revalidation
    const staleStatus = await this.bridge.cache.getStaleStatus(entryId);
    if (staleStatus.isStale) {
      // Trigger background revalidation (non-blocking)
      this._revalidateInBackground(entryId, entry);
    }

    // Boot from cache
    await this._bootFromCache(entryId);
    return;
  }

  // 2. Check if entry exists in cache but not verified
  const hasEntry = await this.bridge.cache.has(entryId);
  if (hasEntry) {
    // Exists but not verified - verify then boot
    obj.setCacheStatus('pending');
    const result = await this.bridge.cache.getWithVerification(entryId);
    if (result.verified) {
      obj.setOfflineAvailable(true);
      await this._bootFromCache(entryId);
    } else {
      // Verification failed - re-download
      console.warn(`[DesktopObjectManager] Cache verification failed for ${entryId}, re-downloading`);
      await this._downloadAndBoot(entryId, entry);
    }
    return;
  }

  // 3. Not cached - check network availability
  if (!navigator.onLine) {
    // Offline and not cached - show error
    obj.showError({
      message: 'Not cached - network required',
      stage: 'offline-check',
      guidance: 'Connect to network or find a cached copy.'
    });
    obj.setOfflineAvailable(false);
    return;
  }

  // 4. Online and not cached - start download
  obj.setOfflineAvailable(false);
  await this._downloadAndBoot(entryId, entry);
}
```

2. **Add _bootFromCache helper:**
```javascript
async _bootFromCache(entryId) {
  const cached = await this.bridge.cache.get(entryId);
  if (cached && cached.data) {
    // Boot using cached data
    await this._startBoot(entryId, cached.data);
  }
}
```

3. **Add background revalidation helper:**
```javascript
async _revalidateInBackground(entryId, entry) {
  // Use existing SWR pattern from CatalogBridge
  // Non-blocking - just trigger the revalidation
  try {
    const serverUrl = entry.sourceServerUrl;
    const containerUrl = `${serverUrl}/api/v1/catalog/${entryId}/data`;

    // Just check ETag, don't re-download if match
    const response = await fetch(containerUrl, { method: 'HEAD' });
    const etag = response.headers.get('ETag');

    const cached = await this.bridge.cache.get(entryId);
    if (cached && cached.metadata?.etag !== etag) {
      // ETag changed - trigger silent update
      console.log(`[DesktopObjectManager] Background update available for ${entryId}`);
      // Actual download happens lazily on next access
    }
  } catch (error) {
    // Background revalidation failure is silent
    console.warn(`[DesktopObjectManager] Background revalidation failed for ${entryId}`);
  }
}
```

4. **Update download complete handler to set offline available:**
```javascript
_handleDownloadComplete(entryId, result) {
  // ... existing code ...
  const obj = this.objects.get(entryId);
  if (obj && result.verified) {
    obj.setOfflineAvailable(true);
  }
  // ... rest of completion logic ...
}
```

5. **Listen for online/offline events:**
```javascript
_setupNetworkListeners() {
  window.addEventListener('online', () => this._updateOfflineBadges());
  window.addEventListener('offline', () => this._updateOfflineBadges());
}

_updateOfflineBadges() {
  // Update offline badges based on current network status
  for (const [entryId, obj] of this.objects) {
    if (obj._isRemote) {
      this._updateOfflineStatus(entryId, obj);
    }
  }
}
```

Do NOT block boot on network check - use navigator.onLine for quick check.
Do NOT re-download if cache is fresh - only revalidate stale entries.
  </action>
  <verify>
    - Cached remote containers boot immediately
    - Offline boot works without network
    - Uncached + offline shows appropriate error
    - Stale cache boots with background revalidation
    - Offline badges update on network status change
  </verify>
  <done>
    - Cache-first boot path implemented for remote containers
    - Offline users can boot previously downloaded containers
    - Network status errors show clear guidance
    - Stale cache uses SWR pattern (boot now, update later)
  </done>
</task>

</tasks>

<verification>
1. CatalogCacheManager.has() method exists and works
2. Offline badge shows on remote containers
3. Cached remote containers boot while offline
4. Uncached + offline shows error with guidance
5. Stale cache boots immediately with background revalidation
6. Network status changes update offline badges
</verification>

<success_criteria>
- User can boot a cached remote container without network access
- Offline availability badge indicates cache status (green=available, gray=network required)
- Uncached remote containers show clear error when offline
- Stale cache entries boot immediately, revalidate in background
- Download verification updates offline availability
</success_criteria>

<output>
After completion, create `.planning/phases/09-remote-boot/09-03-SUMMARY.md`
</output>
