---
spec: boot-linux-geometry-font
basePath: specs/boot-linux-geometry-font
phase: requirements
task: 0/0
updated: 2026-02-25T17:30:00Z
---

# Progress: boot-linux-geometry-font

## Original Goal

Boot RISC-V Linux kernels encoded as morphological glyph textures through the Visual Shell WebGPU hypervisor.

The Python encoder (`riscv_morphological_encoder.py`) produces textures where each pixel's R channel holds a charset index (visual glyph) and G/B channels hold a TokenID (execution lookup). The JS runtime must decode these pixels, lookup instructions from the dictionary, and feed them to the WebGPU RISC-V emulator.

## Existing Plan

Implementation plan available at: `docs/plans/2026-02-25-boot-linux-geometry-font.md`

### Key Components
1. **RISCV Morphological Loader (JS)** - Decodes .rts.png pixels → TokenID → RISC-V instructions
2. **Update WGPULinuxHypervisor** - Add `loadKernelFromMorphologicalRTS()` method
3. **GPU Execution System** - Add `deployWithInstructions()` for pre-expanded buffers
4. **Test HTML Page** - Manual testing interface
5. **Unit Tests** - Loader validation
6. **Encode Test Binary** - Run encoder on `hello_syscall.bin`
7. **Glyph Renderer** (optional) - Visual display

## Completed Tasks

- [x] 1.1 Create RISCVOrphologicalLoader class - feat(riscv): add RISCVOrphologicalLoader for morphological decoding
- [x] 1.2 Add deployWithInstructions() to GPUExecutionSystem - feat(gpu): add deployWithInstructions() for pre-expanded code
- [x] 1.3 Add loadKernelFromMorphologicalRTS() to hypervisor - feat(hypervisor): add loadKernelFromMorphologicalRTS() method
- [x] 1.4 Generate test assets with encoder - test(assets): add hello_morph.rts.png encoded test binary
- [x] 1.5 Create manual test HTML page - test(morphological): add manual test page for morphological boot
- [x] 1.6 POC Checkpoint - End-to-end boot verification - feat(morphological): complete POC

## Current Task

All POC tasks complete. Ready for Phase 2 (Refactoring).

## Learnings

- Test page uses module import for WGPULinuxHypervisor, consistent with existing test pages
- onConsoleOutput callback receives UART output from hypervisor
- Status indicator styling uses CSS classes for different states (loading/running/stopped/error)
- Encoder output: 11980 bytes → 64x64 texture (2995 instructions, 55 unique)
- Visual charset used: !+?AJL (6 distinct glyphs for this binary)
- .meta.json format verified: `type: "riscv-morphological"`, dictionary.instructions is array of u32
- Encoder output format verified: R=charset index, G/B=TokenID (high/low bytes), A=0xFF executable mask
- Dictionary format is `direct-lookup`: `instructions[tokenId]` returns RISC-V u32 directly
- `GPUExecutionSystem` has `deploy()` but not `deployWithInstructions()` - gap identified
- `WGPULinuxHypervisor.loadKernelFromRTS()` extracts raw PNG bytes - not suitable for morphological format
- WebGPUSemanticManager is for GPU-side expansion (different use case), morphological needs CPU-side decode
- Test binary `hello_syscall.bin` exists at `systems/infinite_map_rs/tests/` - ready for encoding
- Visual CPU shader expects `expanded_code: array<u32>` at binding(0) - decoder output format is correct
- Requirements lean - prioritizing speed, deferred Task 7 (glyph renderer) as Low priority
- 4 user stories cover core workflow: load, decode, verify output, visual coherence
- 11 functional requirements (10 core, 1 deferred)
- All acceptance criteria are testable with hello_syscall.bin
- No unresolved questions - research phase was comprehensive

### Design Phase Learnings

- GPUExecutionSystem follows module pattern: export class + window assignment for browser
- deploy() method already handles buffer creation pattern: codeBuffer, memoryBuffer, stateBuffer, bindGroup
- Buffer creation uses mappedAtCreation for initial data write (avoids extra queue.writeBuffer)
- WGPULinuxHypervisor has existing loadKernelFromRTS() pattern - new method follows same flow
- CPU-side decode chosen over GPU compute for simplicity - dictionary lookup is inherently sequential
- NOP fallback (0x00000013) provides graceful degradation for invalid pixels
- Existing test pattern: HTML test pages + JS unit tests in tests/ directory
- visual_cpu_riscv.wgsl uses UART FIFO at 0x05000400 with pointer at 0x050004FC

### POC Verification Learnings

- All JS files pass `node --check` syntax validation
- HTTP server serves all required files correctly:
  - test_morphological_boot.html - contains loadKernelFromMorphologicalRTS call
  - riscv_morphological_loader.js - exports RISCVOrphologicalLoader class
  - wgpu_linux_hypervisor.js - imports loader and has loadKernelFromMorphologicalRTS method
  - gpu_execution_system.js - has deployWithInstructions method
  - assets/hello_morph.rts.png and .meta.json - valid morphological format
- Verify command passes: curl returns 1 match for loadKernelFromMorphologicalRTS

## Blockers

- None currently

## Interview Responses

### Requirements Interview
- **Primary users:** Internal developers only
- **Priority tradeoffs:** Prioritize speed of delivery
- **Success criteria:** Feature works as specified

### Tasks Interview (from tasks.md)
- **Testing depth:** Standard - unit + integration tests
- **Execution priority:** Balanced - reasonable quality with speed

## Next

Phase 2: Refactoring - Add error handling and improve code structure
