# Progress: The Motherboard

## Original Goal

Make the Infinite Map execute placed Resonance Glyphs - transforming the visual desktop into executable RAM.

## Interview Format
- Version: 1.0

## Intent Classification
- Type: GREENFIELD
- Confidence: high (5 keywords matched)
- Min questions: 5
- Max questions: 10
- Keywords matched: execute, glyphs, infinite, map, ram

## Interview Responses

### Goal Interview (from start.md)
- Problem: Adding new functionality - The Infinite Map currently displays glyphs but doesn't execute them
- Constraints: Must integrate with existing Resonance Glyph System and WebGPU shader
- Success criteria: Tests pass and glyphs execute on the map with visual feedback
- Additional context: Plan already exists at docs/plans/2026-02-26-the-motherboard-implementation.md

## Related Specs
- resonance-glyph-system: Foundation for executable glyphs with symmetry and holographic encoding

## Tasks Completed

- [x] 1.1 Create GlyphExecutor skeleton - TBD
- [x] 1.2 Implement WebGPU initialization - TBD
- [x] 1.3 Implement atlas texture loading - TBD
- [x] 1.4 Implement glyph registration - 5c8e2f1
- [x] 1.5 Implement execution loop - (pending commit)

## Learnings

- Shader `visual_cpu_riscv_morph.wgsl` uses 46 registers per core (REGS_PER_CORE = 46u)
- CPU state layout: [0-31] = x0-x31, [32] = PC, [38] = CSR_HALT flag
- Holographic decode uses 2D Hadamard basis matching Python BASIS_MAP
- Symmetry validation checks quadrant mass distribution for geometric audit
- Glyph size is hardcoded to 16x16 pixels (GLYPH_SIZE = 16u)
- Max workgroup size is 64 in shader @workgroup_size(64)
- InfiniteMap already has PixelCPUIntegration pattern to follow for integration
- GlyphExecutor uses ES6 class syntax with dual export (module.exports for Node, window for browser)
- All placeholder methods log their invocation for debugging during POC phase
- WebGPU buffer sizes: systemMemory=1MB (1048576 bytes), cpuStates=64*46*4=11776 bytes
- Buffer usages: STORAGE | COPY_READ | COPY_WRITE for both buffers
- Atlas loading uses fetch() + createImageBitmap() + copyExternalImageToTexture() pattern
- Atlas texture format: rgba8unorm with TEXTURE_BINDING | COPY_DST | RENDER_ATTACHMENT usage
- atlasWidth/atlasHeight stored as instance properties after loading
- Glyph registry uses Map with key format `${x},${y}` for O(1) lookup
- GlyphEntry structure: { sprite, atlasX, atlasY, coreId, pc, active, lastResult, executionCount, glowIntensity }
- Core assignment uses round-robin modulo: coreId = registry.size % maxCores
- Duplicate registration at same position returns existing coreId without overwrite
- getActiveGlyphs() returns Array.from(registry.values()) for easy iteration
- execute() is async with executing flag to prevent re-entry
- syncCPUIStates creates Uint32Array, sets PC at baseIdx+32, atlas coords at baseIdx+0/+1
- dispatchCompute() is simulated for POC - increments glyph.executionCount
- readResults() checks halt flag at baseIdx+38 (simulated, always false for POC)
- updateVisualFeedback() updates sprite alpha/scale based on active/halted state
- glyphsPerRow = atlasWidth / 16 for calculating glyph index in atlas
- lastResult contains { executed, timestamp, results } after each execute() call
