<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IDEAssemblyEngine Tests - Phase J.2</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
            margin: 0;
        }
        h1 {
            color: #00ff88;
            border-bottom: 2px solid #00ff88;
            padding-bottom: 10px;
        }
        h2 {
            color: #00ffff;
            margin-top: 30px;
        }
        .test-suite {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .test-result {
            padding: 10px 15px;
            margin: 8px 0;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .test-result.pass {
            background: #0f3d0f;
            border-left: 4px solid #00ff88;
        }
        .test-result.fail {
            background: #3d0f0f;
            border-left: 4px solid #ff4444;
        }
        .test-name {
            font-weight: bold;
        }
        .test-status {
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
        }
        .test-status.pass {
            background: #00ff88;
            color: #000;
        }
        .test-status.fail {
            background: #ff4444;
            color: #fff;
        }
        .summary {
            background: #0f3460;
            padding: 20px;
            border-radius: 8px;
            margin-top: 30px;
        }
        .summary h3 {
            margin-top: 0;
            color: #00ffff;
        }
        .summary-stats {
            display: flex;
            gap: 30px;
            font-size: 18px;
        }
        .stat {
            display: flex;
            flex-direction: column;
        }
        .stat-value {
            font-size: 36px;
            font-weight: bold;
        }
        .stat-label {
            color: #888;
            font-size: 14px;
        }
        .pass .stat-value { color: #00ff88; }
        .fail .stat-value { color: #ff4444; }
        pre {
            background: #0d1117;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 12px;
        }
        .error-message {
            color: #ff4444;
            font-size: 12px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>IDEAssemblyEngine Unit Tests</h1>
    <p>Phase J.2: Neural IDE Visual Builder - Task 5.1</p>

    <div id="test-results"></div>

    <div id="summary" class="summary" style="display: none;">
        <h3>Test Summary</h3>
        <div class="summary-stats">
            <div class="stat pass">
                <span class="stat-value" id="pass-count">0</span>
                <span class="stat-label">Passed</span>
            </div>
            <div class="stat fail">
                <span class="stat-value" id="fail-count">0</span>
                <span class="stat-label">Failed</span>
            </div>
            <div class="stat">
                <span class="stat-value" id="total-count">0</span>
                <span class="stat-label">Total</span>
            </div>
        </div>
    </div>

    <!-- Load dependencies -->
    <script src="ide_tile_renderer.js"></script>
    <script src="tile_connections.js"></script>
    <script src="ide_semantic_overlay.js"></script>
    <script src="ide_assembly_engine.js"></script>

    <script>
        // Test framework
        class TestRunner {
            constructor() {
                this.results = [];
                this.passCount = 0;
                this.failCount = 0;
            }

            test(name, fn) {
                try {
                    fn();
                    this.results.push({ name, passed: true });
                    this.passCount++;
                } catch (error) {
                    this.results.push({ name, passed: false, error: error.message });
                    this.failCount++;
                }
            }

            assertEqual(actual, expected, message = '') {
                if (actual !== expected) {
                    throw new Error(`${message} Expected: ${JSON.stringify(expected)}, Got: ${JSON.stringify(actual)}`);
                }
            }

            assertTrue(condition, message = 'Assertion failed') {
                if (!condition) {
                    throw new Error(message);
                }
            }

            assertFalse(condition, message = 'Expected false') {
                if (condition) {
                    throw new Error(message);
                }
            }

            assertNotNull(value, message = 'Expected not null') {
                if (value === null || value === undefined) {
                    throw new Error(message);
                }
            }

            assertArrayLength(arr, expectedLength, message = '') {
                if (!Array.isArray(arr)) {
                    throw new Error(`${message} Expected array, got ${typeof arr}`);
                }
                if (arr.length !== expectedLength) {
                    throw new Error(`${message} Expected array length ${expectedLength}, got ${arr.length}`);
                }
            }

            renderResults() {
                const container = document.getElementById('test-results');
                let html = '<div class="test-suite">';

                this.results.forEach(result => {
                    html += `
                        <div class="test-result ${result.passed ? 'pass' : 'fail'}">
                            <span class="test-name">${result.name}</span>
                            <span class="test-status ${result.passed ? 'pass' : 'fail'}">${result.passed ? 'PASS' : 'FAIL'}</span>
                        </div>
                    `;
                    if (!result.passed) {
                        html += `<div class="error-message">${result.error}</div>`;
                    }
                });

                html += '</div>';
                container.innerHTML = html;

                // Update summary
                document.getElementById('summary').style.display = 'block';
                document.getElementById('pass-count').textContent = this.passCount;
                document.getElementById('fail-count').textContent = this.failCount;
                document.getElementById('total-count').textContent = this.passCount + this.failCount;
            }
        }

        // Create mock objects for testing
        function createMockBuilderPanel() {
            return {
                tiles: new Map(),
                placeTile: function(type, x, y, options) {
                    const id = `tile_${Date.now()}`;
                    this.tiles.set(id, { type, x, y, options });
                    return { success: true, tile_id: id };
                }
            };
        }

        function createMockConnectionManager() {
            return {
                connections: [],
                addConnection: function(sourceId, targetId, type) {
                    const connId = `conn_${Date.now()}`;
                    this.connections.push({ connection_id: connId, source: sourceId, target: targetId, type });
                    return { success: true, connection_id: connId };
                },
                getAllConnections: function() {
                    return [...this.connections];
                },
                clear: function() {
                    this.connections = [];
                }
            };
        }

        function createMockSemanticOverlay() {
            return {
                states: new Map(),
                setComponentState: function(tileId, state) {
                    this.states.set(tileId, state);
                },
                getComponentState: function(tileId) {
                    return this.states.get(tileId) || null;
                },
                exportState: function() {
                    const components = {};
                    this.states.forEach((v, k) => components[k] = v);
                    return { components };
                },
                importState: function(state) {
                    if (state && state.components) {
                        Object.entries(state.components).forEach(([k, v]) => {
                            this.states.set(k, v);
                        });
                    }
                },
                clear: function() {
                    this.states.clear();
                }
            };
        }

        function createMockTileRenderer() {
            return {
                tiles: new Map(),
                renderTile: function(tileId, type, bounds, content) {
                    this.tiles.set(tileId, { type, bounds, content });
                    return { success: true, tile_id: tileId };
                },
                updateTileContent: function(tileId, content) {
                    const tile = this.tiles.get(tileId);
                    if (tile) {
                        tile.content = content;
                        return { success: true };
                    }
                    return { success: false, error: 'Tile not found' };
                },
                clear: function() {
                    this.tiles.clear();
                }
            };
        }

        // Run tests
        const runner = new TestRunner();

        // Test 1: IDEAssemblyEngine can be instantiated
        runner.test('IDEAssemblyEngine can be instantiated', () => {
            const mockBuilderPanel = createMockBuilderPanel();
            const mockConnectionManager = createMockConnectionManager();
            const mockSemanticOverlay = createMockSemanticOverlay();
            const mockTileRenderer = createMockTileRenderer();

            const engine = new IDEAssemblyEngine(
                mockBuilderPanel,
                mockConnectionManager,
                mockSemanticOverlay,
                mockTileRenderer
            );

            assertNotNull(engine, 'Engine should not be null');
            assertTrue(typeof engine === 'object', 'Engine should be an object');
            assertTrue(typeof engine.placeIDETile === 'function', 'Engine should have placeIDETile method');
            assertTrue(typeof engine.connectIDETiles === 'function', 'Engine should have connectIDETiles method');
            assertTrue(typeof engine.preview === 'function', 'Engine should have preview method');
        });

        // Test 2: Places IDE tiles correctly
        runner.test('Places IDE tiles correctly', () => {
            const engine = new IDEAssemblyEngine(
                createMockBuilderPanel(),
                createMockConnectionManager(),
                createMockSemanticOverlay(),
                createMockTileRenderer()
            );

            // Place a code editor tile
            const result = engine.placeIDETile('code_editor', 100, 200, { content: 'print("hello")' });

            assertTrue(result.success, 'placeIDETile should return success');
            assertNotNull(result.tile_id, 'Result should include tile_id');
            assertEqual(result.type, 'code_editor', 'Type should be code_editor');
            assertEqual(result.position.x, 100, 'X position should be 100');
            assertEqual(result.position.y, 200, 'Y position should be 200');

            // Verify tile count
            assertEqual(engine.tileCount, 1, 'Should have 1 tile');

            // Test invalid tile type
            const invalidResult = engine.placeIDETile('invalid_type', 50, 50);
            assertFalse(invalidResult.success, 'Invalid type should fail');
        });

        // Test 3: Connects IDE tiles correctly
        runner.test('Connects IDE tiles correctly', () => {
            const engine = new IDEAssemblyEngine(
                createMockBuilderPanel(),
                createMockConnectionManager(),
                createMockSemanticOverlay(),
                createMockTileRenderer()
            );

            // Place two tiles
            const fileBrowser = engine.placeIDETile('file_browser', 0, 0);
            const codeEditor = engine.placeIDETile('code_editor', 200, 0);

            assertTrue(fileBrowser.success, 'File browser should be placed');
            assertTrue(codeEditor.success, 'Code editor should be placed');

            // Connect them with valid connection type
            const connection = engine.connectIDETiles(
                fileBrowser.tile_id,
                codeEditor.tile_id,
                'data_flow'
            );

            assertTrue(connection.success, 'Connection should succeed');
            assertNotNull(connection.connection_id, 'Should have connection_id');
            assertEqual(connection.source_id, fileBrowser.tile_id, 'Source ID should match');
            assertEqual(connection.target_id, codeEditor.tile_id, 'Target ID should match');

            // Test invalid connection type
            const terminal = engine.placeIDETile('terminal', 400, 0);
            const invalidConn = engine.connectIDETiles(
                fileBrowser.tile_id,
                terminal.tile_id,
                'debug_flow'
            );
            assertFalse(invalidConn.success, 'Invalid connection type should fail');
        });

        // Test 4: Logs actions
        runner.test('Logs actions', () => {
            const engine = new IDEAssemblyEngine(
                createMockBuilderPanel(),
                createMockConnectionManager(),
                createMockSemanticOverlay(),
                createMockTileRenderer()
            );

            // Place a tile
            const result = engine.placeIDETile('code_editor', 100, 100);
            assertTrue(result.success, 'Tile placement should succeed');

            // Check action log
            const log = engine.getActionLog();
            assertArrayLength(log, 1, 'Should have 1 log entry');

            const entry = log[0];
            assertEqual(entry.action, 'placeIDETile', 'Action should be placeIDETile');
            assertEqual(entry.status, 'success', 'Status should be success');
            assertNotNull(entry.timestamp, 'Should have timestamp');
            assertNotNull(entry.details, 'Should have details');

            // Perform more actions and verify log grows
            engine.connectIDETiles('nonexistent1', 'nonexistent2', 'data_flow');
            const log2 = engine.getActionLog();
            assertArrayLength(log2, 2, 'Should have 2 log entries');
            assertEqual(log2[1].status, 'error', 'Failed connection should be logged as error');
        });

        // Test 5: Provides preview
        runner.test('Provides preview', () => {
            const engine = new IDEAssemblyEngine(
                createMockBuilderPanel(),
                createMockConnectionManager(),
                createMockSemanticOverlay(),
                createMockTileRenderer()
            );

            // Place tiles
            const tile1 = engine.placeIDETile('code_editor', 0, 0, { content: 'code' });
            const tile2 = engine.placeIDETile('terminal', 200, 0);

            // Connect tiles
            engine.connectIDETiles(tile1.tile_id, tile2.tile_id, 'command_flow');

            // Get preview
            const preview = engine.preview();

            assertNotNull(preview, 'Preview should not be null');
            assertArrayLength(preview.tiles, 2, 'Should have 2 tiles in preview');
            assertArrayLength(preview.connections, 1, 'Should have 1 connection in preview');
            assertEqual(preview.tile_count, 2, 'Tile count should be 2');
            assertEqual(preview.connection_count, 1, 'Connection count should be 1');
            assertNotNull(preview.semanticState, 'Should have semanticState');
            assertArrayLength(preview.actionLog, 3, 'Should have 3 action log entries');

            // Verify tile data structure
            const tileData = preview.tiles[0];
            assertNotNull(tileData.tile_id, 'Tile should have tile_id');
            assertNotNull(tileData.type, 'Tile should have type');
            assertNotNull(tileData.position, 'Tile should have position');
        });

        // Test 6: IDEAssemblyEngine exports cartridge
        runner.test('IDEAssemblyEngine exports cartridge', () => {
            const engine = new IDEAssemblyEngine(
                createMockBuilderPanel(),
                createMockConnectionManager(),
                createMockSemanticOverlay(),
                createMockTileRenderer()
            );

            // Place a tile
            const result = engine.placeIDETile('code_editor', 100, 200);
            assertTrue(result.success, 'Tile placement should succeed');

            // Export cartridge
            const cartridge = engine.exportCartridge();

            assertNotNull(cartridge, 'Cartridge should not be null');
            assertEqual(cartridge.format, 'neural-ide-v1', 'Format should be neural-ide-v1');
            assertEqual(cartridge.version, '1.0.0', 'Version should be 1.0.0');
            assertNotNull(cartridge.created, 'Should have created timestamp');
            assertNotNull(cartridge.tiles, 'Cartridge should have tiles');
            assertEqual(cartridge.metadata.tileCount, 1, 'Tile count should be 1');
            assertEqual(cartridge.metadata.generator, 'IDEAssemblyEngine', 'Generator should be IDEAssemblyEngine');
            assertTrue(Array.isArray(cartridge.shaderRefs), 'shaderRefs should be an array');
            assertTrue(Array.isArray(cartridge.connections), 'connections should be an array');
            assertTrue(Array.isArray(cartridge.actionLog), 'actionLog should be an array');
        });

        // Test 7: Cartridge includes shader references
        runner.test('Cartridge includes shader references', () => {
            const engine = new IDEAssemblyEngine(
                createMockBuilderPanel(),
                createMockConnectionManager(),
                createMockSemanticOverlay(),
                createMockTileRenderer()
            );

            // Place a code_editor tile
            const result = engine.placeIDETile('code_editor', 50, 50);
            assertTrue(result.success, 'Tile placement should succeed');

            // Export cartridge
            const cartridge = engine.exportCartridge();

            assertNotNull(cartridge.shaderRefs, 'Should have shaderRefs');
            assertTrue(cartridge.shaderRefs.includes('ide_code_editor'), 'shaderRefs should include ide_code_editor');

            // Place another tile type
            engine.placeIDETile('terminal', 200, 50);
            const cartridge2 = engine.exportCartridge();

            assertTrue(cartridge2.shaderRefs.includes('ide_code_editor'), 'Should still include ide_code_editor');
            assertTrue(cartridge2.shaderRefs.includes('ide_terminal'), 'Should include ide_terminal');
            assertEqual(cartridge2.shaderRefs.length, 2, 'Should have 2 unique shader refs');
        });

        // Render results
        runner.renderResults();

        // Log final status
        console.log(`Tests complete: ${runner.passCount} passed, ${runner.failCount} failed`);
    </script>
</body>
</html>
