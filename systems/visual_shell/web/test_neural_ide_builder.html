<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural IDE: AI Assembly Demo</title>
    <style>
        body { font-family: 'Courier New', monospace; background: #0a0a0f; color: #00ff88; padding: 20px; max-width: 1400px; margin: 0 auto; }
        h1 { color: #00ffff; border-bottom: 1px solid #333; padding-bottom: 10px; }
        h2 { color: #ff00ff; margin-top: 20px; }
        .step { background: #111; border: 1px solid #333; padding: 15px; margin: 10px 0; border-radius: 4px; }
        .step-header { display: flex; justify-content: space-between; align-items: center; }
        .step-name { font-weight: bold; color: #00ffff; }
        .step-time { color: #888; font-size: 12px; }
        .pass { color: #00ff00; } .fail { color: #ff0000; } .pending { color: #ffff00; }
        pre { background: #000; padding: 10px; overflow-x: auto; font-size: 11px; margin: 10px 0; }
        button { background: #222; color: #00ff88; border: 1px solid #00ff88; padding: 8px 16px; cursor: pointer; margin: 5px; font-family: inherit; }
        button:hover { background: #00ff88; color: #000; }
        #summary { font-size: 18px; padding: 20px; background: #111; margin-top: 20px; border-radius: 4px; }
        #canvas-container { width: 100%; height: 400px; border: 1px solid #333; margin: 20px 0; }
    </style>
</head>
<body>
    <h1> Neural IDE: AI Assembly Demo</h1>
    <p>This demonstrates an AI agent using WebMCP tools to assemble a complete IDE.</p>

    <div id="canvas-container"></div>

    <div class="step">
        <button onclick="runFullAssembly()"> Run Full AI Assembly</button>
        <button onclick="runStepByStep()"> Run Step-by-Step</button>
        <button onclick="resetDemo()"> Reset</button>
    </div>

    <h2>Assembly Steps</h2>
    <div id="steps"></div>

    <div id="summary">
        <strong>Summary:</strong> <span id="summary-text">Click "Run Full AI Assembly" to begin</span>
    </div>

    <!-- Dependencies -->
    <script src="ide_tile_types.js"></script>
    <script src="tile_connections.js"></script>
    <script src="BuilderPanel.js"></script>

    <script>
        const steps = [];
        let currentStep = 0;
        let builderPanel = null;

        // Mock app for testing
        const mockApp = {
            worldContainer: {
                addChild: () => {},
                eventMode: 'static',
                on: () => {}
            },
            config: { gridSize: 100 }
        };

        function addStep(name, description, fn) {
            steps.push({ name, description, fn, status: 'pending', time: null });
        }

        function renderSteps() {
            const container = document.getElementById('steps');
            container.innerHTML = steps.map((step, i) => `
                <div class="step">
                    <div class="step-header">
                        <span class="step-name">${i + 1}. ${step.name}</span>
                        <span class="step-time">${step.time ? step.time + 'ms' : ''}</span>
                    </div>
                    <div class="${step.status}">${step.status.toUpperCase()}: ${step.description}</div>
                    ${step.result ? `<pre>${JSON.stringify(step.result, null, 2)}</pre>` : ''}
                </div>
            `).join('');
        }

        function updateSummary(text) {
            document.getElementById('summary-text').textContent = text;
        }

        async function runStep(index) {
            if (index >= steps.length) return;

            const step = steps[index];
            const start = performance.now();

            try {
                step.result = await step.fn();
                step.status = 'pass';
                step.description = step.description.replace('FAILED', 'SUCCESS');
            } catch (e) {
                step.status = 'fail';
                step.description += ` - FAILED: ${e.message}`;
            }

            step.time = Math.round(performance.now() - start);
            renderSteps();
        }

        // Define assembly steps
        addStep('Initialize Builder', 'Create BuilderPanel instance', async () => {
            builderPanel = new BuilderPanel();
            // Force initialization with mock
            builderPanel.show();
            return { success: true, message: 'BuilderPanel initialized' };
        });

        addStep('Place Code Editor Tile', 'AI uses builder_place_tile to add code_editor', async () => {
            return builderPanel.placeTile('code', 0, 0, { metadata: { type: 'code_editor' } });
        });

        addStep('Place File Browser Tile', 'AI uses builder_place_tile to add file_browser', async () => {
            return builderPanel.placeTile('data', 1, 0, { metadata: { type: 'file_browser' } });
        });

        addStep('Place Terminal Tile', 'AI uses builder_place_tile to add terminal', async () => {
            return builderPanel.placeTile('system', 2, 0, { metadata: { type: 'terminal' } });
        });

        addStep('Place Debugger Tile', 'AI uses builder_place_tile to add debugger', async () => {
            return builderPanel.placeTile('system', 0, 1, { metadata: { type: 'debugger' } });
        });

        addStep('Connect File Browser  Code Editor', 'AI uses builder_connect_tiles with data_flow', async () => {
            const state = builderPanel.getIDEState();
            const browser = state.tiles.find(t => t.metadata?.type === 'file_browser');
            const editor = state.tiles.find(t => t.metadata?.type === 'code_editor');
            if (!browser || !editor) throw new Error('Tiles not found');
            return builderPanel.connectTiles(browser.tile_id, editor.tile_id, 'data_flow');
        });

        addStep('Connect Code Editor  Terminal', 'AI uses builder_connect_tiles with command_flow', async () => {
            const state = builderPanel.getIDEState();
            const editor = state.tiles.find(t => t.metadata?.type === 'code_editor');
            const terminal = state.tiles.find(t => t.metadata?.type === 'terminal');
            if (!editor || !terminal) throw new Error('Tiles not found');
            return builderPanel.connectTiles(editor.tile_id, terminal.tile_id, 'command_flow');
        });

        addStep('Connect Code Editor  Debugger', 'AI uses builder_connect_tiles with debug_flow', async () => {
            const state = builderPanel.getIDEState();
            const editor = state.tiles.find(t => t.metadata?.type === 'code_editor');
            const debuggerTile = state.tiles.find(t => t.metadata?.type === 'debugger');
            if (!editor || !debuggerTile) throw new Error('Tiles not found');
            return builderPanel.connectTiles(editor.tile_id, debuggerTile.tile_id, 'debug_flow');
        });

        addStep('Get IDE State', 'AI uses ide_get_state to verify assembly', async () => {
            return builderPanel.getIDEState();
        });

        addStep('Verify Assembly', 'Check 4 tiles + 3 connections exist', async () => {
            const state = builderPanel.getIDEState();
            if (state.tile_count !== 4) throw new Error(`Expected 4 tiles, got ${state.tile_count}`);
            if (state.connection_count !== 3) throw new Error(`Expected 3 connections, got ${state.connection_count}`);
            return {
                success: true,
                message: 'Neural IDE assembled successfully!',
                tile_count: state.tile_count,
                connection_count: state.connection_count
            };
        });

        async function runFullAssembly() {
            const totalStart = performance.now();
            for (let i = 0; i < steps.length; i++) {
                await runStep(i);
                await new Promise(r => setTimeout(r, 100)); // Small delay for visual feedback
            }
            const totalTime = Math.round(performance.now() - totalStart);
            const passed = steps.filter(s => s.status === 'pass').length;
            const failed = steps.filter(s => s.status === 'fail').length;

            updateSummary(`Assembly ${failed === 0 ? 'SUCCESS' : 'FAILED'}: ${passed}/${steps.length} steps passed in ${totalTime}ms`);
        }

        async function runStepByStep() {
            if (currentStep >= steps.length) {
                updateSummary('Step-by-step complete!');
                return;
            }
            await runStep(currentStep);
            currentStep++;
        }

        function resetDemo() {
            currentStep = 0;
            steps.forEach(s => { s.status = 'pending'; s.result = null; s.time = null; });
            if (builderPanel) {
                builderPanel.clear?.();
            }
            builderPanel = null;
            renderSteps();
            updateSummary('Click "Run Full AI Assembly" to begin');
        }

        // Initial render
        renderSteps();
    </script>
</body>
</html>
