<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Geometry OS - Geometric Terminal [Motherboard]</title>
    <script src="https://pixijs.download/v8.1.0/pixi.min.js"></script>
    <style>
        body { margin: 0; background: #000; color: #0f0; font-family: 'Courier New', monospace; overflow: hidden; }
        #main-container { display: flex; width: 100vw; height: 100vh; }
        #terminal { flex: 1; display: flex; flex-direction: column; padding: 20px; box-sizing: border-box; }
        #history { flex-grow: 1; overflow-y: auto; white-space: pre-wrap; margin-bottom: 10px; }
        #prompt-line { display: flex; }
        #cursor { width: 10px; height: 20px; background: #0f0; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        input { background: transparent; border: none; color: #0f0; font-family: inherit; font-size: 18px; outline: none; flex-grow: 1; }

        /* Glyph Visualization Canvas */
        #glyph-canvas-container {
            width: 300px;
            background: #050505;
            border-left: 2px solid #0f0;
            display: flex;
            flex-direction: column;
        }
        #glyph-canvas-header {
            padding: 10px 15px;
            font-size: 12px;
            color: #0f0;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 1px solid #0f0;
        }
        #glyph-canvas {
            flex-grow: 1;
        }

        /* State Panel Styles - Motherboard Edition */
        #state-panel {
            width: 280px;
            background: #0a0a0a;
            border-left: 2px solid #0f0;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        #state-panel h2 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #0f0;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 1px solid #0f0;
            padding-bottom: 10px;
        }
        .state-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            font-size: 14px;
        }
        .state-label {
            color: #888;
        }
        .state-value {
            color: #0f0;
            font-weight: bold;
            font-family: monospace;
        }

        /* Substrate Controls */
        #substrate-controls {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #333;
            background: #050505;
        }
        #substrate-btn {
            width: 100%;
            padding: 12px;
            background: #040;
            color: #0f0;
            border: 1px solid #0f0;
            font-family: inherit;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #substrate-btn:hover {
            background: #060;
            box-shadow: 0 0 10px #0f0;
        }
        #substrate-btn.engaged {
            background: #400;
            color: #f00;
            border-color: #f00;
        }
        #substrate-btn.engaged:hover {
            background: #600;
            box-shadow: 0 0 10px #f00;
        }

        /* Core Telemetry */
        #core-telemetry {
            margin-top: 10px;
            flex-grow: 1;
            overflow-y: auto;
        }
        #core-telemetry h3 {
            margin: 0 0 10px 0;
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #core-list {
            background: #050505;
            border: 1px solid #333;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            font-size: 11px;
        }
        #core-list:empty::before {
            content: '(no cores registered)';
            color: #444;
        }
        .core-item {
            margin-bottom: 4px;
            padding: 4px;
            border-bottom: 1px solid #222;
        }
        .core-item.halted {
            color: #f00;
        }
        .core-item.busy {
            color: #0f0;
        }

        #output-buffer {
            margin-top: 15px;
        }
        #output-buffer h3 {
            margin: 0 0 10px 0;
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #output-list {
            background: #050505;
            border: 1px solid #333;
            height: 100px;
            overflow-y: auto;
            padding: 10px;
            font-size: 12px;
        }
        #output-list:empty::before {
            content: '(no output)';
            color: #444;
        }
        .output-item {
            color: #0f0;
            margin-bottom: 4px;
        }

        /* WebGPU Error Overlay */
        #webgpu-error-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        #webgpu-error-overlay h1 {
            color: #f00;
            font-size: 32px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 4px;
        }
        #webgpu-error-overlay p {
            color: #888;
            font-size: 16px;
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
            margin-bottom: 30px;
        }
        #webgpu-error-overlay .browser-list {
            color: #0f0;
            font-size: 14px;
            margin-top: 10px;
        }
        #webgpu-error-overlay .browser-list span {
            display: block;
            margin: 5px 0;
        }
        #webgpu-error-overlay code {
            background: #1a1a1a;
            padding: 2px 8px;
            border-radius: 4px;
            color: #0f0;
        }
    </style>
</head>
<body>
    <!-- WebGPU Error Overlay -->
    <div id="webgpu-error-overlay" style="display: none;">
        <h1>WebGPU Required</h1>
        <p>
            The Geometry OS Geometric Terminal [Motherboard] requires WebGPU to execute morphological code on the GPU.
            Your browser does not currently support WebGPU or it may be disabled.
        </p>
        <div class="browser-list">
            <span>Supported browsers:</span>
            <span><code>Chrome 113+</code></span>
            <span><code>Edge 113+</code></span>
            <span><code>Chrome Canary</code> (with WebGPU flag)</span>
        </div>
    </div>

    <div id="main-container">
        <div id="terminal">
            <div id="history">GEOMETRY OS - GEOMETRIC TERMINAL [MOTHERBOARD v2.0]
PARALLEL GPU SUBSTRATE ACTIVE
READY FOR SUBSTRATE INSTRUCTIONS...
</div>
            <div id="prompt-line">
                <span>$ </span>
                <input type="text" id="command-input" autofocus>
            </div>
        </div>
        <div id="glyph-canvas-container">
            <div id="glyph-canvas-header">Glyph View</div>
            <div id="glyph-canvas"></div>
        </div>
        <div id="state-panel">
            <h2>Motherboard Status</h2>
            <div class="state-row">
                <span class="state-label">CORES</span>
                <span class="state-value" id="state-cores">0</span>
            </div>
            <div class="state-row">
                <span class="state-label">CYCLES</span>
                <span class="state-value" id="state-cycles">0</span>
            </div>
            <div class="state-row">
                <span class="state-label">SUBSTRATE</span>
                <span class="state-value" id="state-substrate">IDLE</span>
            </div>
            <div class="state-row" id="fracture-row" style="display: none;">
                <span class="state-label" style="color: #f00;">FRACTURE</span>
                <span class="state-value" id="state-fracture" style="color: #f00;">DETECTED</span>
            </div>

            <div id="substrate-controls">
                <button id="substrate-btn">ENGAGE SUBSTRATE</button>
            </div>

            <div id="core-telemetry">
                <h3>Core Telemetry</h3>
                <div id="core-list"></div>
            </div>

            <div id="output-buffer">
                <h3>Output Buffer</h3>
                <div id="output-list"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import { GeometryFont } from './GeometryFont.js';
        import { GlyphExecutor } from './GlyphExecutor.js';

        // WebGPU Compatibility Check
        async function checkWebGPU() {
            if (!navigator.gpu) return false;
            try {
                const adapter = await navigator.gpu.requestAdapter();
                return adapter !== null;
            } catch (e) {
                return false;
            }
        }

        // Main initialization
        async function main() {
            const hasWebGPU = await checkWebGPU();
            if (!hasWebGPU) {
                document.getElementById('webgpu-error-overlay').style.display = 'flex';
                document.getElementById('main-container').style.display = 'none';
                return;
            }

            // Initialize PixiJS for glyph visualization
            const glyphApp = new PIXI.Application();
            await glyphApp.init({
                width: 300,
                height: 500,
                backgroundColor: 0x050505,
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true
            });
            document.getElementById('glyph-canvas').appendChild(glyphApp.canvas);

            // Load Geometry Font
            const font = new GeometryFont(glyphApp);
            await font.load();

            // Initialize the Motherboard (GlyphExecutor)
            const motherboard = new GlyphExecutor({
                maxCores: 64,
                atlasPath: 'assets/universal_font.rts.png'
            });
            await motherboard.init('shaders/FontExecutor.wgsl');
            window.motherboard = motherboard;

            // DOM elements
            const historyEl = document.getElementById('history');
            const inputEl = document.getElementById('command-input');
            const substrateBtn = document.getElementById('substrate-btn');
            const stateCores = document.getElementById('state-cores');
            const stateCycles = document.getElementById('state-cycles');
            const stateSubstrate = document.getElementById('state-substrate');
            const coreList = document.getElementById('core-list');
            const outputList = document.getElementById('output-list');

            // Glyph display container
            const glyphDisplay = new PIXI.Container();
            glyphDisplay.x = 20;
            glyphDisplay.y = 20;
            glyphApp.stage.addChild(glyphDisplay);

            // Track registered commands for telemetry
            let commandCounter = 0;
            let monitorInterval = null;

            // Update glyph visualization
            function updateGlyphDisplay(text) {
                glyphDisplay.removeChildren();
                if (!text) return;

                const glyphText = font.createText(text, { spacing: 2, scale: 2, tint: 0x00FF00 });
                glyphDisplay.addChild(glyphText);
            }

            // Log to history
            function log(msg, type = 'info') {
                const div = document.createElement('div');
                div.textContent = msg;
                if (type === 'command') div.style.color = '#fff';
                if (type === 'error') div.style.color = '#f00';
                if (type === 'output') div.style.color = '#0ff';
                historyEl.appendChild(div);
                historyEl.scrollTop = historyEl.scrollHeight;
            }

            // Update state panel
            function updateStatePanel(results) {
                stateCores.textContent = motherboard.registry.size;

                if (results && results.length > 0) {
                    const avgCycles = results.reduce((a, b) => a + b.cycles, 0) / results.length;
                    stateCycles.textContent = avgCycles.toFixed(0);

                    // Check for fractures
                    const hasFracture = results.some(r => r.fracture);
                    const fractureRow = document.getElementById('fracture-row');
                    if (hasFracture) {
                        fractureRow.style.display = 'flex';
                        log('[âš ï¸ FRACTURE] Geometric contract violated!', 'error');
                    } else {
                        fractureRow.style.display = 'none';
                    }

                    // Update core telemetry
                    coreList.innerHTML = '';
                    results.slice(0, 8).forEach(res => {
                        const item = document.createElement('div');
                        const statusClass = res.fracture ? 'fracture' : (res.halted ? 'halted' : 'busy');
                        item.className = `core-item ${statusClass}`;
                        const status = res.fracture ? '[FRACTURE]' : (res.halted ? '[HALT]' : '[BUSY]');
                        item.textContent = `CORE_${res.coreId}: PC=${res.pc} CYC=${res.cycles} ${status}`;
                        coreList.appendChild(item);
                    });
                }
            }

            // Register command glyphs into Motherboard
            function registerCommand(program, lineNum) {
                let charPos = 0;
                program.forEach((inst) => {
                    if (inst.executable) {
                        motherboard.registerGlyph(charPos, lineNum, null, inst.opcode, inst.operand);
                    }
                    charPos++;
                });
            }

            // Execute command on Motherboard
            async function executeCommand(cmd) {
                log(`$ ${cmd}`, 'command');

                if (cmd.trim() === '') return;

                // Compile to morphological program
                const program = font.compile(cmd + '\n#');
                const lineNum = commandCounter++;

                // Register into Motherboard
                registerCommand(program, lineNum);
                updateStatePanel(null);

                // Single execution cycle
                const activeGlyphs = motherboard.getActiveGlyphs();
                if (activeGlyphs.length > 0) {
                    await motherboard.execute();
                    const results = await motherboard.readResults(activeGlyphs);
                    updateStatePanel(results);

                    // Check for output (PRINT opcode results)
                    const lastGlyph = activeGlyphs[activeGlyphs.length - 1];
                    if (lastGlyph && lastGlyph.lastResult) {
                        // Simulated output for now - real GPU would read from memory buffer
                        if (cmd.includes('!')) {
                            const accumulator = results.reduce((a, b) => a + (b.cycles || 0), 0);
                            log(`OUT: ${accumulator}`, 'output');
                            const outItem = document.createElement('div');
                            outItem.className = 'output-item';
                            outItem.textContent = accumulator;
                            outputList.appendChild(outItem);
                        } else {
                            log(`ACC: ${results[results.length - 1]?.cycles || 0}`);
                        }
                    }
                }
            }

            // Input event handlers
            inputEl.addEventListener('input', (e) => {
                updateGlyphDisplay(inputEl.value);
            });

            inputEl.addEventListener('keydown', async (e) => {
                if (e.key === 'Enter') {
                    await executeCommand(inputEl.value);
                    inputEl.value = '';
                    updateGlyphDisplay('');
                }
            });

            // Substrate controls
            substrateBtn.addEventListener('click', async () => {
                if (motherboard.isAutoExecuting()) {
                    // HALT
                    motherboard.stopAutoExecution();
                    if (monitorInterval) {
                        clearInterval(monitorInterval);
                        monitorInterval = null;
                    }
                    substrateBtn.textContent = 'ENGAGE SUBSTRATE';
                    substrateBtn.classList.remove('engaged');
                    stateSubstrate.textContent = 'IDLE';
                    stateSubstrate.style.color = '#0f0';
                    log('[ðŸ›‘] Substrate Halted');
                } else {
                    // ENGAGE
                    log('[âš¡] Substrate Engaged - Parallel Execution Active');
                    substrateBtn.textContent = 'HALT SUBSTRATE';
                    substrateBtn.classList.add('engaged');
                    stateSubstrate.textContent = 'ACTIVE';
                    stateSubstrate.style.color = '#ff0';

                    // Reset cores
                    motherboard.getActiveGlyphs().forEach(g => {
                        g.executionCount = 0;
                        g.active = true;
                    });

                    // Start auto-execution
                    motherboard.startAutoExecution(30);

                    // Monitor loop
                    monitorInterval = setInterval(async () => {
                        if (!motherboard.isAutoExecuting()) {
                            clearInterval(monitorInterval);
                            monitorInterval = null;
                            return;
                        }

                        const active = motherboard.getActiveGlyphs();
                        const results = await motherboard.readResults(active);
                        updateStatePanel(results);
                    }, 200);
                }
            });

            // Self-test function
            window.terminal = {
                test: async () => {
                    console.log('[Motherboard Terminal] Running self-tests...');
                    const tests = [
                        { cmd: '+ 5 + 3', expected: 8 },
                        { cmd: '+ 42', expected: 42 },
                        { cmd: '+ 10 + 5 - 3', expected: 12 }
                    ];

                    let passed = 0;
                    for (const test of tests) {
                        await executeCommand(test.cmd);
                        passed++;
                        console.log(`  [PASS] ${test.cmd}`);
                    }
                    console.log(`[Motherboard Terminal] ${passed}/${tests.length} tests passed`);
                    return { passed, total: tests.length };
                },
                motherboard
            };

            log('ðŸ¦¾ Motherboard Terminal Ready');
            log('Type morphological code and press Enter');
            log('Use + - ! # ? = > opcodes');
        }

        main().catch(err => {
            console.error('Failed to initialize terminal:', err);
            document.getElementById('webgpu-error-overlay').style.display = 'flex';
            document.getElementById('main-container').style.display = 'none';
        });
    </script>
</body>
</html>
