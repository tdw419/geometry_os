<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry OS - Motherboard Test Page</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            background-color: #0a0a0f;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #e0e0e0;
        }

        #app {
            width: 100%;
            height: 100%;
        }

        /* Control Panel - Top Left */
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 16px;
            z-index: 1000;
            min-width: 280px;
        }

        #controls h3 {
            color: #00ff88;
            margin-bottom: 12px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #controls h4 {
            color: #888;
            margin: 12px 0 8px 0;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #controls button {
            background: transparent;
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 8px 16px;
            margin: 4px;
            cursor: pointer;
            border-radius: 4px;
            font-family: inherit;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        #controls button:hover {
            background: #00ff88;
            color: #0a0a0f;
        }

        #controls button:active {
            transform: scale(0.95);
        }

        #controls button.execute-once {
            border-color: #00aaff;
            color: #00aaff;
        }

        #controls button.execute-once:hover {
            background: #00aaff;
            color: #0a0a0f;
        }

        #controls button.start-auto {
            border-color: #00ff00;
            color: #00ff00;
        }

        #controls button.start-auto:hover {
            background: #00ff00;
            color: #0a0a0f;
        }

        #controls button.stop-auto {
            border-color: #ff4444;
            color: #ff4444;
        }

        #controls button.stop-auto:hover {
            background: #ff4444;
            color: #0a0a0f;
        }

        .mode-btn {
            border-color: #888 !important;
            color: #888 !important;
        }

        .mode-btn:hover {
            background: #888 !important;
            color: #0a0a0f !important;
        }

        .mode-btn.active {
            background: #00ff88 !important;
            border-color: #00ff88 !important;
            color: #0a0a0f !important;
        }

        #status {
            margin-top: 12px;
            padding: 8px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 4px;
            font-size: 11px;
            color: #00ff88;
        }

        .status-label {
            color: #888;
            margin-right: 8px;
        }

        .status-value {
            color: #00ff88;
        }

        .status-value.ok { color: #00ff00; }
        .status-value.error { color: #ff4444; }
        .status-value.pending { color: #ffaa00; }

        /* Log Panel - Right Side */
        #log-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 400px;
            height: 300px;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid #333;
            border-radius: 8px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        #log-panel h4 {
            color: #00ff88;
            padding: 10px 12px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid #333;
        }

        #log {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 11px;
            line-height: 1.6;
        }

        .log-entry {
            margin-bottom: 4px;
        }

        .log-entry.info { color: #888; }
        .log-entry.success { color: #00ff00; }
        .log-entry.error { color: #ff4444; }
        .log-entry.warn { color: #ffaa00; }

        .log-timestamp {
            color: #555;
            margin-right: 8px;
        }

        /* Glyph Palette - Bottom Left */
        #glyph-palette {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 16px;
            z-index: 1000;
        }

        #glyph-palette h4 {
            color: #00ff88;
            margin-bottom: 12px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .glyph-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .glyph-btn {
            width: 48px;
            height: 48px;
            background: transparent;
            border: 1px solid #00ff88;
            color: #00ff88;
            font-size: 20px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .glyph-btn:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        .glyph-btn.selected {
            background: #00ff88;
            color: #0a0a0f;
        }

        /* Help Text */
        #help {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 12px;
            font-size: 11px;
            color: #888;
            z-index: 1000;
        }

        #help kbd {
            background: #222;
            border: 1px solid #444;
            border-radius: 3px;
            padding: 2px 6px;
            font-family: inherit;
            color: #00ff88;
        }

        /* Loading Overlay */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0f;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #loading-text {
            color: #00ff88;
            font-size: 18px;
            text-align: center;
        }

        #loading-text span {
            display: block;
            font-size: 12px;
            color: #666;
            margin-top: 8px;
        }
    </style>
    <!-- PixiJS v8 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/8.0.0/pixi.min.js"></script>

    <!-- Geometry OS Modules -->
    <script src="spatial_core.js"></script>
    <script src="sprite_pool.js"></script>
    <script src="chunk_manager.js"></script>
    <script src="viewport_manager.js"></script>
    <script src="lod_system.js"></script>
    <script src="infinite_map_v2.js"></script>
    <script src="infinite_map.js"></script>
    <script src="GlyphExecutor.js"></script>
</head>
<body>
    <div id="loading">
        <div id="loading-text">
            INITIALIZING MOTHERBOARD...
            <span>WebGPU + Glyph Execution System</span>
        </div>
    </div>

    <div id="app"></div>

    <div id="controls">
        <h3>The Motherboard</h3>

        <!-- System Status -->
        <div id="status">
            <div><span class="status-label">WebGPU:</span><span id="webgpu-status" class="status-value pending">Checking...</span></div>
            <div><span class="status-label">Pipeline:</span><span id="pipeline-status" class="status-value pending">Not initialized</span></div>
            <div><span class="status-label">Atlas:</span><span id="atlas-status" class="status-value pending">Not loaded</span></div>
            <div><span class="status-label">Bind Group:</span><span id="bindgroup-status" class="status-value pending">Not created</span></div>
            <div><span class="status-label">Mode:</span><span id="mode-status" class="status-value ok">standard</span></div>
            <div><span class="status-label">Glyphs:</span><span id="glyph-count" class="status-value">0</span></div>
            <div><span class="status-label">Cycles:</span><span id="cycle-count" class="status-value">0</span></div>
            <div><span class="status-label">Auto:</span><span id="auto-status" class="status-value pending">Stopped</span></div>
        </div>

        <!-- Execution Controls -->
        <h4>Execution</h4>
        <div>
            <button id="btn-execute" class="execute-once">Execute Once</button>
            <button id="btn-start-auto" class="start-auto">Start Auto</button>
            <button id="btn-stop-auto" class="stop-auto" style="display:none;">Stop Auto</button>
            <button id="btn-clear">Clear</button>
        </div>

        <!-- Mode Switching -->
        <h4>Morphological Mode</h4>
        <div>
            <button id="btn-mode-standard" class="mode-btn active">Standard</button>
            <button id="btn-mode-native" class="mode-btn">Native</button>
            <button id="btn-mode-stealth" class="mode-btn">Stealth</button>
        </div>
    </div>

    <div id="log-panel">
        <h4>Execution Log</h4>
        <div id="log"></div>
    </div>

    <div id="glyph-palette">
        <h4>Test Glyphs</h4>
        <div class="glyph-grid">
            <button class="glyph-btn selected" data-glyph="0" data-atlas-x="0" data-atlas-y="0" title="ADD">A</button>
            <button class="glyph-btn" data-glyph="1" data-atlas-x="1" data-atlas-y="0" title="SUB">S</button>
            <button class="glyph-btn" data-glyph="2" data-atlas-x="2" data-atlas-y="0" title="LOAD">L</button>
        </div>
    </div>

    <div id="help">
        <div><kbd>Click</kbd> Place glyph</div>
        <div><kbd>Ctrl+Enter</kbd> Execute</div>
        <div><kbd>1-3</kbd> Select glyph</div>
    </div>

    <script>
        // State
        let app = null;
        let infiniteMap = null;
        let glyphExecutor = null;
        let selectedGlyph = { index: 0, atlasX: 0, atlasY: 0 };
        let placedGlyphs = [];

        // DOM elements
        const webgpuStatusEl = document.getElementById('webgpu-status');
        const pipelineStatusEl = document.getElementById('pipeline-status');
        const atlasStatusEl = document.getElementById('atlas-status');
        const bindgroupStatusEl = document.getElementById('bindgroup-status');
        const modeStatusEl = document.getElementById('mode-status');
        const glyphCountEl = document.getElementById('glyph-count');
        const cycleCountEl = document.getElementById('cycle-count');
        const autoStatusEl = document.getElementById('auto-status');
        const logEl = document.getElementById('log');
        const loadingEl = document.getElementById('loading');

        // Logging
        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span>${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
            console.log(`[${type}] ${message}`);
        }

        function updateStatus(element, value, type = 'ok') {
            element.textContent = value;
            element.className = `status-value ${type}`;
        }

        // Initialize PixiJS application
        async function initApp() {
            log('Initializing Motherboard test page...', 'info');

            // Create PixiJS app
            app = new PIXI.Application();
            await app.init({
                background: '#0a0a0f',
                resizeTo: window,
                antialias: true,
            });

            document.getElementById('app').appendChild(app.canvas);

            // Create world container for the map
            const worldContainer = new PIXI.Container();
            app.stage.addChild(worldContainer);

            // Create InfiniteMap with GlyphExecutor
            if (typeof InfiniteMap !== 'undefined') {
                infiniteMap = new InfiniteMap(worldContainer, {
                    gridSize: 100,
                    tileScale: 1.0,
                });
                glyphExecutor = infiniteMap.glyphExecutor;
                log('InfiniteMap created', 'success');
            } else {
                log('InfiniteMap not loaded - creating standalone GlyphExecutor', 'warn');

                // Create standalone GlyphExecutor for testing
                if (typeof GlyphExecutor !== 'undefined') {
                    glyphExecutor = new GlyphExecutor({
                        maxCores: 64,
                        glyphSize: 16,
                        regsPerCore: 46,
                        atlasMode: 'standard',
                        atlasPath: '/assets/polymorphic_atlas.png'
                    });
                    await glyphExecutor.init('/shaders/visual_cpu_riscv_morph.wgsl');
                } else {
                    log('GlyphExecutor not loaded!', 'error');
                    return;
                }
            }

            // Update status based on initialization
            updateSystemStatus();

            // Register 3 test glyphs
            registerTestGlyphs();

            // Setup interaction
            setupInteraction();

            // Hide loading
            loadingEl.classList.add('hidden');

            log('Motherboard ready!', 'success');
        }

        function updateSystemStatus() {
            if (!glyphExecutor) {
                updateStatus(webgpuStatusEl, 'Not initialized', 'error');
                updateStatus(pipelineStatusEl, 'Not initialized', 'error');
                updateStatus(atlasStatusEl, 'Not initialized', 'error');
                updateStatus(bindgroupStatusEl, 'Not initialized', 'error');
                return;
            }

            // WebGPU status
            if (glyphExecutor.device) {
                updateStatus(webgpuStatusEl, 'Active', 'ok');
            } else {
                updateStatus(webgpuStatusEl, 'Simulation Mode', 'warn');
            }

            // Pipeline status
            if (glyphExecutor.computePipeline) {
                updateStatus(pipelineStatusEl, 'Ready', 'ok');
            } else {
                updateStatus(pipelineStatusEl, 'Simulation Mode', 'warn');
            }

            // Atlas status
            if (glyphExecutor.atlasTexture) {
                updateStatus(atlasStatusEl, `${glyphExecutor.atlasWidth}x${glyphExecutor.atlasHeight}`, 'ok');
            } else {
                updateStatus(atlasStatusEl, 'Not loaded', 'warn');
            }

            // Bind group status
            if (glyphExecutor.bindGroup) {
                updateStatus(bindgroupStatusEl, 'Created', 'ok');
            } else {
                updateStatus(bindgroupStatusEl, 'Not created', 'warn');
            }

            // Mode status
            updateStatus(modeStatusEl, glyphExecutor.options.atlasMode || 'standard', 'ok');

            // Glyph count
            glyphCountEl.textContent = placedGlyphs.length;

            // Cycle count
            cycleCountEl.textContent = glyphExecutor.executionCount || 0;

            // Auto status
            if (glyphExecutor.isAutoExecuting && glyphExecutor.isAutoExecuting()) {
                updateStatus(autoStatusEl, 'Running (30 FPS)', 'ok');
            } else {
                updateStatus(autoStatusEl, 'Stopped', 'pending');
            }
        }

        function registerTestGlyphs() {
            // Register 3 test glyphs with mock sprites
            const testGlyphData = [
                { x: 0, y: 0, atlasX: 0, atlasY: 0, name: 'ADD (x0, x0, x1)' },
                { x: 1, y: 0, atlasX: 1, atlasY: 0, name: 'SUB (x1, x1, x2)' },
                { x: 2, y: 0, atlasX: 2, atlasY: 0, name: 'LOAD (x2, addr)' }
            ];

            for (const data of testGlyphData) {
                // Create mock sprite object
                const mockSprite = {
                    x: data.x * 16,
                    y: data.y * 16,
                    alpha: 1.0,
                    tint: 0xffffff,
                    scale: { x: 1, y: 1, set: function(v) { this.x = v; this.y = v; } }
                };

                const coreId = glyphExecutor.registerGlyph(
                    data.x,
                    data.y,
                    mockSprite,
                    data.atlasX,
                    data.atlasY
                );

                placedGlyphs.push({
                    ...data,
                    coreId,
                    mockSprite
                });

                log(`Registered test glyph: ${data.name} (core ${coreId})`, 'info');
            }

            glyphCountEl.textContent = placedGlyphs.length;
        }

        // Setup click and keyboard interaction
        function setupInteraction() {
            // Click handler for placing glyphs
            app.stage.eventMode = 'static';
            app.stage.hitArea = app.screen;
            app.stage.on('pointerdown', onMapClick);

            // Keyboard shortcuts
            window.addEventListener('keydown', onKeyDown);

            // Button handlers
            document.getElementById('btn-execute').addEventListener('click', executeOnce);
            document.getElementById('btn-start-auto').addEventListener('click', startAutoExecution);
            document.getElementById('btn-stop-auto').addEventListener('click', stopAutoExecution);
            document.getElementById('btn-clear').addEventListener('click', clearGlyphs);

            // Mode buttons
            document.getElementById('btn-mode-standard').addEventListener('click', () => setMode('standard'));
            document.getElementById('btn-mode-native').addEventListener('click', () => setMode('native'));
            document.getElementById('btn-mode-stealth').addEventListener('click', () => setMode('stealth'));

            // Glyph palette
            document.querySelectorAll('.glyph-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.glyph-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedGlyph = {
                        index: parseInt(btn.dataset.glyph),
                        atlasX: parseInt(btn.dataset.atlasX),
                        atlasY: parseInt(btn.dataset.atlasY)
                    };
                    log(`Selected glyph: ${btn.title}`, 'info');
                });
            });
        }

        // Handle map clicks
        function onMapClick(event) {
            if (!glyphExecutor) return;

            // Get world coordinates
            const worldPos = event.global;
            const mapX = Math.floor(worldPos.x / 16); // 16px per glyph
            const mapY = Math.floor(worldPos.y / 16);

            log(`Click at (${worldPos.x}, ${worldPos.y}) -> map (${mapX}, ${mapY})`, 'info');

            // Create mock sprite
            const mockSprite = {
                x: mapX * 16,
                y: mapY * 16,
                alpha: 1.0,
                tint: 0xffffff,
                scale: { x: 1, y: 1, set: function(v) { this.x = v; this.y = v; } }
            };

            // Register glyph
            const coreId = glyphExecutor.registerGlyph(
                mapX,
                mapY,
                mockSprite,
                selectedGlyph.atlasX,
                selectedGlyph.atlasY
            );

            placedGlyphs.push({ x: mapX, y: mapY, coreId, mockSprite });
            glyphCountEl.textContent = placedGlyphs.length;
            log(`Placed glyph at (${mapX}, ${mapY}) - core ${coreId}`, 'success');
        }

        // Handle keyboard shortcuts
        function onKeyDown(event) {
            // Ctrl+Enter: Execute glyphs
            if (event.key === 'Enter' && event.ctrlKey) {
                event.preventDefault();
                executeOnce();
                return;
            }

            // Number keys 1-3: Select glyph
            const num = parseInt(event.key);
            if (num >= 1 && num <= 3) {
                document.querySelectorAll('.glyph-btn').forEach((btn, idx) => {
                    if (idx === num - 1) {
                        btn.classList.add('selected');
                        selectedGlyph = {
                            index: parseInt(btn.dataset.glyph),
                            atlasX: parseInt(btn.dataset.atlasX),
                            atlasY: parseInt(btn.dataset.atlasY)
                        };
                    } else {
                        btn.classList.remove('selected');
                    }
                });
            }
        }

        // Execute once
        async function executeOnce() {
            if (!glyphExecutor) {
                log('GlyphExecutor not initialized', 'error');
                return;
            }

            log('Executing once...', 'info');
            const result = await glyphExecutor.execute();

            if (result.skipped) {
                log('Execution skipped (already in progress)', 'warn');
            } else {
                log(`Executed ${result.executed} glyphs`, 'success');
                cycleCountEl.textContent = glyphExecutor.executionCount;
            }
        }

        // Start auto execution
        function startAutoExecution() {
            if (!glyphExecutor) {
                log('GlyphExecutor not initialized', 'error');
                return;
            }

            glyphExecutor.startAutoExecution(30);
            log('Auto execution started at 30 FPS', 'success');
            updateStatus(autoStatusEl, 'Running (30 FPS)', 'ok');

            document.getElementById('btn-start-auto').style.display = 'none';
            document.getElementById('btn-stop-auto').style.display = 'inline-block';

            // Update cycle count periodically
            window.autoUpdateInterval = setInterval(() => {
                cycleCountEl.textContent = glyphExecutor.executionCount;
            }, 1000);
        }

        // Stop auto execution
        function stopAutoExecution() {
            if (!glyphExecutor) return;

            glyphExecutor.stopAutoExecution();
            log('Auto execution stopped', 'info');
            updateStatus(autoStatusEl, 'Stopped', 'pending');

            document.getElementById('btn-start-auto').style.display = 'inline-block';
            document.getElementById('btn-stop-auto').style.display = 'none';

            if (window.autoUpdateInterval) {
                clearInterval(window.autoUpdateInterval);
                window.autoUpdateInterval = null;
            }
        }

        // Set morphological mode
        async function setMode(mode) {
            if (!glyphExecutor) {
                log('GlyphExecutor not initialized', 'error');
                return;
            }

            await glyphExecutor.setMorphologicalMode(mode);
            updateStatus(modeStatusEl, mode, 'ok');
            log(`Morphological mode changed to: ${mode}`, 'success');

            // Update button states
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`btn-mode-${mode}`).classList.add('active');
        }

        // Clear all glyphs
        function clearGlyphs() {
            if (!glyphExecutor) {
                log('GlyphExecutor not initialized', 'error');
                return;
            }

            // Stop auto-execution if running
            if (glyphExecutor.isAutoExecuting()) {
                stopAutoExecution();
            }

            // Unregister all glyphs
            for (const glyph of placedGlyphs) {
                glyphExecutor.unregisterGlyph(glyph.x, glyph.y);
            }

            placedGlyphs = [];
            glyphCountEl.textContent = 0;
            log('Cleared all glyphs', 'info');

            // Re-register test glyphs
            registerTestGlyphs();
        }

        // Initialize on load
        window.addEventListener('load', initApp);

        // Handle window resize
        window.addEventListener('resize', () => {
            if (app) {
                app.renderer.resize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
