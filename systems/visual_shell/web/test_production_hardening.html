<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Phase I: Production Hardening Verification</title>
    <style>
        body {
            font-family: monospace;
            background: #111;
            color: #ddd;
            padding: 20px;
        }

        .log {
            background: #222;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #444;
        }

        .success {
            color: #8f8;
        }

        .error {
            color: #f88;
        }

        .info {
            color: #88f;
        }

        button {
            padding: 8px 16px;
            background: #0066cc;
            color: white;
            border: none;
            cursor: pointer;
            margin-right: 10px;
        }
    </style>
</head>

<body>
    <h1>Phase I: Production Hardening</h1>

    <div style="margin-bottom: 20px;">
        <button onclick="runValidationTest()">Test Validation (Schema)</button>
        <button onclick="runRateLimitTest()">Test Rate Limiting</button>
        <button onclick="runMetricsTest()">Test Metrics</button>
    </div>

    <div id="log" class="log">Initializing...</div>

    <!-- MOCK WebMCP Environment -->
    <script>
        window.geometryOSApp = {
            // Mock OS App
        };

        // Mock Model Context Protocol
        window.navigator.modelContext = {
            tools: new Map(),
            registerTool: async (tool, handler) => {
                console.log(`[MockMCP] Registering ${tool.name}`);
                window.navigator.modelContext.tools.set(tool.name, { tool, handler });
            }
        };
    </script>

    <!-- Load Hardening Modules (ensure they work in browser) -->
    <script type="module" src="production_hardening.js"></script>

    <!-- Load Bridge -->
    <script src="webmcp_bridge.js"></script>

    <script type="module">
        const logEl = document.getElementById('log');
        const log = (msg, type = '') => {
            logEl.innerHTML += `<div class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            console.log(msg);
        };

        // Initialize Bridge manually since we don't have 'geometry-os-ready' event source
        async function init() {
            log("Initializing WebMCP Bridge...", 'info');

            // Trigger initialize
            // We can dispatch the event
            window.dispatchEvent(new CustomEvent('geometry-os-ready', { detail: window.geometryOSApp }));

            // Give it a moment to load modules and register tools
            setTimeout(() => {
                log("Bridge Initialized. Tools registered: " + window.navigator.modelContext.tools.size, 'info');
            }, 1000);
        }

        window.runValidationTest = async () => {
            log("--- Validation Test ---", 'info');
            // Try invoking 'hypervisor_boot' with missing args
            const toolName = 'hypervisor_boot';
            const entry = window.navigator.modelContext.tools.get(toolName);

            if (!entry) {
                log("Tool not registered: " + toolName, 'error');
                return;
            }

            try {
                log("Calling hypervisor_boot with empty params (Should Fail)...");
                await entry.handler({}); // Should throw
                log("❌ FAILURE: Validation did not catch missing params!", 'error');
            } catch (e) {
                if (e.message.includes('Missing required field')) {
                    log("✅ SUCCESS: Caught missing params: " + e.message, 'success');
                } else {
                    log("❌ Unexpected error: " + e.message, 'error');
                }
            }

            try {
                log("Calling hypervisor_boot with invalid types...");
                await entry.tool.handler({ kernel_url: 123, memory_mb: 'large' }); // Invalid types
                log("❌ FAILURE: Validation did not catch invalid types!", 'error');
            } catch (e) {
                // Note: handler wrapper might be on 'entry.tool.handler' OR 'entry.handler' depending on how mock registered it
                if (e.message.includes('Invalid type')) {
                    log("✅ SUCCESS: Caught invalid types: " + e.message, 'success');
                } else {
                    log("⚠️ Check error: " + e.message, 'info');
                }
            }
        };

        window.runRateLimitTest = async () => {
            log("--- Rate Limit Test ---", 'info');
            // 'trigger_evolution' has limit 10/min
            const toolName = 'trigger_evolution';
            const entry = window.navigator.modelContext.tools.get(toolName);

            if (!entry) return log("Tool not found", 'error');

            log("Spamming trigger_evolution (Limit 10)...");
            let successes = 0;
            let blocked = false;

            for (let i = 0; i < 15; i++) {
                try {
                    // Valid params
                    await entry.handler({ generations: 1, target_fitness: 0.9 });
                    successes++;
                } catch (e) {
                    if (e.message.includes('Rate limit exceeded')) {
                        blocked = true;
                        log(`✅ Blocked at call #${i + 1}: ${e.message}`, 'success');
                        break;
                    } else {
                        log(`Error at call #${i + 1}: ${e.message}`, 'error');
                    }
                }
            }

            if (!blocked) log("❌ FAILURE: Rate limit did not trigger!", 'error');
            else log(`Allowed ${successes} calls before blocking.`, 'info');
        };

        window.runMetricsTest = async () => {
            log("--- Metrics Test ---", 'info');
            // Access private #metrics via... wait we can't.
            // But we can check if console logs success?
            // Or we can add a tool to expose it?
            // production_hardening.js exports MetricsCollector, but the instance is private in bridge.

            // However, successful calls should just work without error.
            log("Calling get_os_state (should be tracked)...");
            const entry = window.navigator.modelContext.tools.get('get_os_state');
            try {
                await entry.handler({});
                log("✅ Call successful. (Metrics are internal)", 'success');
            } catch (e) {
                log("Error: " + e.message, 'error');
            }
        };

        // Start
        init();
    </script>
</body>

</html>