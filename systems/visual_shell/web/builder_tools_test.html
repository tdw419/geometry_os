<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebMCP Phase F - Builder Tools Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        h1 { color: #00ff88; }
        h2 { color: #00ccff; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .test-section { margin: 20px 0; padding: 15px; background: #16213e; border-radius: 8px; }
        .test-result { margin: 10px 0; padding: 10px; border-radius: 4px; font-family: monospace; }
        .test-result.pass { background: #1a4a1a; border-left: 4px solid #00ff88; }
        .test-result.fail { background: #4a1a1a; border-left: 4px solid #ff4444; }
        .test-result.pending { background: #3a3a1a; border-left: 4px solid #ffcc00; }
        button {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover { background: #00cc66; }
        button:disabled { background: #666; cursor: not-allowed; }
        #run-all { background: #00ccff; font-size: 16px; }
        pre { background: #0a0a1a; padding: 10px; overflow-x: auto; border-radius: 4px; }
        .summary { font-size: 18px; margin: 20px 0; padding: 15px; background: #2a2a4e; border-radius: 8px; }
    </style>
</head>
<body>
    <h1>WebMCP Phase F - Builder Tools Test</h1>

    <div class="summary">
        <strong>Status:</strong> <span id="status">Ready</span> |
        <strong>Passed:</strong> <span id="passed">0</span> |
        <strong>Failed:</strong> <span id="failed">0</span>
    </div>

    <button id="run-all">Run All Tests</button>

    <div class="test-section">
        <h2>Test 1: builder_place_tile</h2>
        <button onclick="runTest('testPlaceTile')">Run</button>
        <div id="test-1-result" class="test-result pending">Pending</div>
    </div>

    <div class="test-section">
        <h2>Test 2: builder_load_shader</h2>
        <button onclick="runTest('testLoadShader')">Run</button>
        <div id="test-2-result" class="test-result pending">Pending</div>
    </div>

    <div class="test-section">
        <h2>Test 3: builder_evolve_shader</h2>
        <button onclick="runTest('testEvolveShader')">Run</button>
        <div id="test-3-result" class="test-result pending">Pending</div>
    </div>

    <div class="test-section">
        <h2>Test 4: builder_assemble_cartridge</h2>
        <button onclick="runTest('testAssembleCartridge')">Run</button>
        <div id="test-4-result" class="test-result pending">Pending</div>
    </div>

    <div class="test-section">
        <h2>Test 5: builder_preview</h2>
        <button onclick="runTest('testPreview')">Run</button>
        <div id="test-5-result" class="test-result pending">Pending</div>
    </div>

    <div class="test-section">
        <h2>Test 6: builder_get_state</h2>
        <button onclick="runTest('testGetState')">Run</button>
        <div id="test-6-result" class="test-result pending">Pending</div>
    </div>

    <script src="BuilderPanel.js"></script>
    <script src="webmcp_bridge.js"></script>
    <script>
        // Instantiate WebMCPBridge in mock mode for testing purposes
        window.webmcpBridgeInstance = new WebMCPBridge({}, { allowMock: true });

        // Enable auto-confirm for automated testing (W3C WebMCP human-in-the-loop)
        // Set to false to see real confirmation dialogs
        window.webmcpAutoConfirm = true;

        // Track when WebMCP tools are ready
        window.webmcpReady = false;
        window.addEventListener('webmcp-ready', (e) => {
            window.webmcpReady = true;
            console.log('Test page received webmcp-ready event:', e.detail);
            document.getElementById('status').textContent = 'Ready';
        });
        window.addEventListener('webmcp-error', (e) => {
            console.error('WebMCP registration failed:', e.detail);
            document.getElementById('status').textContent = 'Error: ' + e.detail.error;
        });
    </script>
    <script>
        let passed = 0;
        let failed = 0;

        // Initialize BuilderPanel
        window.builderPanel = new BuilderPanel();

        function updateSummary() {
            document.getElementById('passed').textContent = passed;
            document.getElementById('failed').textContent = failed;
            document.getElementById('status').textContent =
                failed === 0 && passed > 0 ? 'All Passed!' : 'Running...';
        }

        function setResult(testNum, status, message) {
            const el = document.getElementById(`test-${testNum}-result`);
            el.className = `test-result ${status}`;
            el.innerHTML = `<strong>${status.toUpperCase()}:</strong> ${message}`;
            if (status === 'pass') passed++;
            if (status === 'fail') failed++;
            updateSummary();
        }

        async function runTest(testName) {
            const tests = {
                testPlaceTile: async () => {
                    const result = await window.invokeWebMCPTool('builder_place_tile', {
                        tile_type: 'system',
                        x: 100,
                        y: 200,
                        size: 50
                    });
                    if (result.success && result.tile_id) {
                        return { pass: true, msg: `Tile placed: ${result.tile_id} at (${result.position.x}, ${result.position.y})` };
                    }
                    return { pass: false, msg: JSON.stringify(result) };
                },

                testLoadShader: async () => {
                    const result = await window.invokeWebMCPTool('builder_load_shader', {
                        name: 'test_compute',
                        wgsl_code: '@compute @workgroup_size(64) fn main() {}'
                    });
                    if (result.success && result.shader_id) {
                        return { pass: true, msg: `Shader loaded: ${result.name}` };
                    }
                    return { pass: false, msg: JSON.stringify(result) };
                },

                testEvolveShader: async () => {
                    // First load a shader to get a shader_id
                    const loadResult = await window.invokeWebMCPTool('builder_load_shader', {
                        name: 'evolve_test',
                        wgsl_code: '@compute @workgroup_size(64) fn main() {}'
                    });
                    const shaderId = loadResult.shader_id || 'evolve_test';
                    const result = await window.invokeWebMCPTool('builder_evolve_shader', {
                        shader_id: shaderId,
                        evolution_params: {
                            generations: 5,
                            mutation_rate: 0.1
                        }
                    });
                    if (result.success && result.fitness_score >= 0) {
                        return { pass: true, msg: `Evolved: fitness=${result.fitness_score.toFixed(2)}` };
                    }
                    return { pass: false, msg: JSON.stringify(result) };
                },

                testAssembleCartridge: async () => {
                    // Place a tile first
                    await window.invokeWebMCPTool('builder_place_tile', {
                        tile_type: 'code',
                        x: 0,
                        y: 0
                    });
                    const result = await window.invokeWebMCPTool('builder_assemble_cartridge', {
                        name: 'test_cartridge',
                        region: { x: 0, y: 0, width: 200, height: 200 }
                    });
                    if (result.success) {
                        return { pass: true, msg: `Cartridge assembled: ${result.name} with ${result.tiles_included} tiles` };
                    }
                    return { pass: false, msg: JSON.stringify(result) };
                },

                testPreview: async () => {
                    const result = await window.invokeWebMCPTool('builder_preview', {});
                    if (result.success) {
                        return { pass: true, msg: `Preview captured: ${result.message || result.tiles_previewed + ' tiles previewed'}` };
                    }
                    return { pass: false, msg: JSON.stringify(result) };
                },

                testGetState: async () => {
                    const result = await window.invokeWebMCPTool('builder_get_state', {
                        include: ['all']
                    });
                    if (result.tiles !== undefined) {
                        return { pass: true, msg: `State: ${result.tiles.length} tiles, shader: ${result.current_shader ? 'loaded' : 'none'}` };
                    }
                    return { pass: false, msg: JSON.stringify(result) };
                }
            };

            const testNum = {
                testPlaceTile: 1,
                testLoadShader: 2,
                testEvolveShader: 3,
                testAssembleCartridge: 4,
                testPreview: 5,
                testGetState: 6
            }[testName];

            try {
                const { pass, msg } = await tests[testName]();
                setResult(testNum, pass ? 'pass' : 'fail', msg);
            } catch (e) {
                setResult(testNum, 'fail', `Error: ${e.message}`);
            }
        }

        document.getElementById('run-all').addEventListener('click', async () => {
            // Wait for WebMCP to be ready (with timeout)
            if (!window.webmcpReady) {
                document.getElementById('status').textContent = 'Waiting for WebMCP...';
                let waited = 0;
                while (!window.webmcpReady && waited < 5000) {
                    await new Promise(r => setTimeout(r, 100));
                    waited += 100;
                }
                if (!window.webmcpReady) {
                    document.getElementById('status').textContent = 'Error: WebMCP not ready (timeout)';
                    return;
                }
            }

            passed = 0;
            failed = 0;
            updateSummary();
            const testNames = ['testPlaceTile', 'testLoadShader', 'testEvolveShader',
                             'testAssembleCartridge', 'testPreview', 'testGetState'];
            for (const name of testNames) {
                await runTest(name);
            }
        });
    </script>
</body>
</html>
