<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holographic Interference Demo - Geometry OS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #0a0a14;
            color: #00ffcc;
            font-family: 'Courier New', monospace;
            padding: 20px;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ffcc;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }
        .demo-box {
            background: #111122;
            border: 1px solid #00ffcc;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
        .demo-box h3 {
            margin-bottom: 10px;
            color: #00ff88;
        }
        canvas {
            border: 1px solid #333;
            display: block;
            margin: 0 auto;
            background: #000;
        }
        .controls {
            margin-top: 20px;
            text-align: center;
        }
        .controls label {
            display: inline-block;
            margin: 0 15px;
        }
        .controls input[type="range"] {
            width: 150px;
            vertical-align: middle;
        }
        button {
            background: #00ffcc;
            color: #000;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
            border-radius: 4px;
        }
        button:hover {
            background: #00ff88;
        }
        .stats {
            margin-top: 15px;
            padding: 10px;
            background: #1a1a2e;
            border-radius: 4px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>ðŸ‘» Holographic Interference Effect Demo</h1>

    <div class="controls">
        <label>
            Intensity: <input type="range" id="intensity" min="0" max="100" value="10">
            <span id="intensityVal">10%</span>
        </label>
        <label>
            Ghost Alpha: <input type="range" id="alpha" min="0" max="100" value="30">
            <span id="alphaVal">30%</span>
        </label>
        <label>
            Pattern:
            <select id="pattern">
                <option value="random">Random</option>
                <option value="hilbert">Hilbert Curve</option>
                <option value="clustered">Clustered</option>
                <option value="scanlines">Scanlines</option>
                <option value="glitch">Full Glitch</option>
            </select>
        </label>
        <br><br>
        <button onclick="applyEffect()">Apply Effect</button>
        <button onclick="resetImage()">Reset</button>
        <button onclick="animateToggle()">Toggle Animation</button>
    </div>

    <div class="container">
        <div class="demo-box">
            <h3>Original Holographic Image</h3>
            <canvas id="original" width="256" height="256"></canvas>
            <div class="stats" id="originalStats">Encoded data intact</div>
        </div>

        <div class="demo-box">
            <h3>With Interference Effect</h3>
            <canvas id="interference" width="256" height="256"></canvas>
            <div class="stats" id="interferenceStats">Pixels removed: 0</div>
        </div>

        <div class="demo-box">
            <h3>Decoded Verification</h3>
            <canvas id="decoded" width="256" height="256"></canvas>
            <div class="stats" id="decodedStats">Decoding accuracy: --</div>
        </div>
    </div>

    <script type="module">
        import { HolographicAgentEncoder } from './HolographicAgentEncoder.js';
        import { HolographicInterference } from './HolographicInterference.js';

        // Initialize
        const encoder = new HolographicAgentEncoder();
        const interference = new HolographicInterference({
            removalPercent: 0.10,
            ghostAlpha: 0.3
        });

        const originalCanvas = document.getElementById('original');
        const interferenceCanvas = document.getElementById('interference');
        const decodedCanvas = document.getElementById('decoded');

        const originalCtx = originalCanvas.getContext('2d');
        const interferenceCtx = interferenceCanvas.getContext('2d');
        const decodedCtx = decodedCanvas.getContext('2d');

        let originalImageData = null;
        let animated = false;
        let animationId = null;

        // Create test holographic image
        function createTestImage() {
            const width = 256;
            const height = 256;
            const imageData = originalCtx.createImageData(width, height);

            // Fill with encoded test pattern
            const glyphSize = 16;
            const glyphsX = width / glyphSize;
            const glyphsY = height / glyphSize;

            // Encode test values into each glyph
            for (let gy = 0; gy < glyphsY; gy++) {
                for (let gx = 0; gx < glyphsX; gx++) {
                    // Create a unique test value
                    const testValue = (gx * 1000 + gy * 100 + gx * gy) >>> 0;

                    // Encode into glyph
                    const glyphData = encoder.encode32Bit(testValue);

                    // Copy to main image
                    const startX = gx * glyphSize;
                    const startY = gy * glyphSize;

                    for (let y = 0; y < glyphSize; y++) {
                        for (let x = 0; x < glyphSize; x++) {
                            const srcIdx = (y * glyphSize + x) * 4;
                            const dstIdx = ((startY + y) * width + (startX + x)) * 4;
                            imageData.data[dstIdx] = glyphData.data[srcIdx];
                            imageData.data[dstIdx + 1] = glyphData.data[srcIdx + 1];
                            imageData.data[dstIdx + 2] = glyphData.data[srcIdx + 2];
                            imageData.data[dstIdx + 3] = 255;
                        }
                    }
                }
            }

            return imageData;
        }

        // Initialize
        function init() {
            originalImageData = createTestImage();
            originalCtx.putImageData(originalImageData, 0, 0);
            interferenceCtx.putImageData(originalImageData, 0, 0);
            decodedCtx.putImageData(originalImageData, 0, 0);

            document.getElementById('originalStats').textContent =
                `Encoded glyphs: ${(256/16) * (256/16)}`;

            verifyDecoding(originalImageData);
        }

        // Apply interference effect
        window.applyEffect = function() {
            const intensity = parseInt(document.getElementById('intensity').value) / 100;
            const alpha = parseInt(document.getElementById('alpha').value) / 100;
            const pattern = document.getElementById('pattern').value;

            // Copy original
            const imageData = new ImageData(
                new Uint8ClampedArray(originalImageData.data),
                originalImageData.width,
                originalImageData.height
            );

            let processed;
            const pixelsToRemove = Math.floor(imageData.data.length / 4 * intensity);

            switch (pattern) {
                case 'hilbert':
                    processed = interference.applyHilbertInterference(imageData, {
                        removalPercent: intensity,
                        ghostAlpha: alpha,
                        segmentLength: 16
                    });
                    break;
                case 'clustered':
                    processed = interference.applyClustered(imageData, {
                        removalPercent: intensity,
                        ghostAlpha: alpha,
                        clusterSize: 4
                    });
                    break;
                case 'scanlines':
                    processed = interference.applyScanlines(imageData, {
                        removalPercent: intensity,
                        ghostAlpha: alpha
                    });
                    break;
                case 'glitch':
                    processed = interference.createHolographicGlitch(imageData, {
                        intensity: intensity
                    });
                    break;
                default:
                    processed = interference.apply(imageData, {
                        removalPercent: intensity,
                        ghostAlpha: alpha
                    });
            }

            interferenceCtx.putImageData(processed, 0, 0);

            document.getElementById('interferenceStats').textContent =
                `Pixels affected: ~${pixelsToRemove.toLocaleString()} (${Math.round(intensity * 100)}%)`;

            // Verify decoding still works
            verifyDecoding(processed);
        };

        // Verify decoding accuracy
        function verifyDecoding(imageData) {
            const glyphSize = 16;
            const width = imageData.width;
            const height = imageData.height;
            const glyphsX = width / glyphSize;
            const glyphsY = height / glyphSize;

            let correct = 0;
            let total = glyphsX * glyphsY;

            for (let gy = 0; gy < glyphsY; gy++) {
                for (let gx = 0; gx < glyphsX; gx++) {
                    // Extract glyph
                    const glyphData = new ImageData(glyphSize, glyphSize);
                    const startX = gx * glyphSize;
                    const startY = gy * glyphSize;

                    for (let y = 0; y < glyphSize; y++) {
                        for (let x = 0; x < glyphSize; x++) {
                            const srcIdx = ((startY + y) * width + (startX + x)) * 4;
                            const dstIdx = (y * glyphSize + x) * 4;
                            glyphData.data[dstIdx] = imageData.data[srcIdx];
                            glyphData.data[dstIdx + 1] = imageData.data[srcIdx + 1];
                            glyphData.data[dstIdx + 2] = imageData.data[srcIdx + 2];
                            glyphData.data[dstIdx + 3] = 255;
                        }
                    }

                    // Decode
                    const decoded = encoder.decode32Bit(glyphData);
                    const expected = (gx * 1000 + gy * 100 + gx * gy) >>> 0;

                    if (decoded === expected) {
                        correct++;
                    }
                }
            }

            const accuracy = (correct / total * 100).toFixed(1);
            document.getElementById('decodedStats').textContent =
                `Decoding accuracy: ${accuracy}% (${correct}/${total})`;

            // Update decoded canvas with visual
            decodedCtx.putImageData(imageData, 0, 0);

            // Draw accuracy indicator
            decodedCtx.fillStyle = accuracy > 95 ? '#00ff00' : accuracy > 50 ? '#ffff00' : '#ff0000';
            decodedCtx.font = '14px monospace';
            decodedCtx.fillText(`${accuracy}%`, 10, 20);
        }

        // Reset to original
        window.resetImage = function() {
            interferenceCtx.putImageData(originalImageData, 0, 0);
            decodedCtx.putImageData(originalImageData, 0, 0);
            document.getElementById('interferenceStats').textContent = 'Reset to original';
            verifyDecoding(originalImageData);
        };

        // Toggle animation
        window.animateToggle = function() {
            animated = !animated;

            if (animated) {
                animate();
            } else {
                cancelAnimationFrame(animationId);
                resetImage();
            }
        };

        function animate() {
            if (!animated) return;

            const intensity = parseInt(document.getElementById('intensity').value) / 100;
            const alpha = parseInt(document.getElementById('alpha').value) / 100;

            // Copy original
            const imageData = new ImageData(
                new Uint8ClampedArray(originalImageData.data),
                originalImageData.width,
                originalImageData.height
            );

            // Apply with random seed based on time
            const processed = interference.apply(imageData, {
                removalPercent: intensity,
                ghostAlpha: alpha,
                seed: Date.now()
            });

            interferenceCtx.putImageData(processed, 0, 0);
            verifyDecoding(processed);

            animationId = requestAnimationFrame(animate);
        }

        // Update UI
        document.getElementById('intensity').addEventListener('input', (e) => {
            document.getElementById('intensityVal').textContent = e.target.value + '%';
        });

        document.getElementById('alpha').addEventListener('input', (e) => {
            document.getElementById('alphaVal').textContent = e.target.value + '%';
        });

        // Start
        init();
    </script>
</body>
</html>
