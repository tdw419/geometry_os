//! Optical Loader - Loads files effectively from V2 Spatial Brick textures
//!
//! Reverses the Hilbert Curve folding performed by `tensor_fold.py`.

use std::fs::File;
use std::io::{Read, Error, ErrorKind};
use std::path::Path;
use bytemuck::{Pod, Zeroable};

#[repr(C, packed)]
#[derive(Debug, Copy, Clone, Pod, Zeroable)]
pub struct V2BrickHeader {
    pub magic: [u8; 4],          // "V2BR"
    pub version: u32,            // 1
    pub texture_width: u32,
    pub texture_height: u32,
    pub hilbert_order: u32,
    pub original_size: u64,
    pub compressed_size: u64,
    pub entropy: f32,
    pub hash_part1: [u8; 32],
    pub hash_part2: [u8; 16],
    pub flags: u32,
    pub reserved_part1: [u8; 32],
    pub reserved_part2: [u8; 8],
}

pub struct OpticalLoader;

impl OpticalLoader {
    /// Load a text source string from a .brick file (Shader, Script, etc.)
    pub fn load_text_source<P: AsRef<Path>>(path: P) -> std::io::Result<String> {
        let mut file = File::open(path)?;
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer)?;

        if buffer.len() < std::mem::size_of::<V2BrickHeader>() {
             return Err(Error::new(ErrorKind::InvalidData, "File too small"));
        }

        // Parse header
        let (header_bytes, texture_data) = buffer.split_at(std::mem::size_of::<V2BrickHeader>());
        // Use copy to avoid alignment issues with packed struct
        let mut header_copy = [0u8; std::mem::size_of::<V2BrickHeader>()];
        header_copy.copy_from_slice(header_bytes);
        let header: V2BrickHeader = unsafe { std::mem::transmute(header_copy) };

        // Verify magic
        if &header.magic != b"V2BR" {
            return Err(Error::new(ErrorKind::InvalidData, "Invalid V2BR magic"));
        }

        // Check flag (Is UTF8 Text = Bit 4)
        if (header.flags & (1 << 4)) == 0 {
             eprintln!("Warning: Brick does not have IS_UTF8_TEXT flag set. Attempting decode anyway.");
        }

        // Unfold
        let utf8_bytes = Self::unfold_hilbert(texture_data, &header)?;
        
        // Convert to String
        String::from_utf8(utf8_bytes)
            .map_err(|e| Error::new(ErrorKind::InvalidData, format!("UTF-8 Error: {}", e)))
    }

    fn unfold_hilbert(texture: &[u8], header: &V2BrickHeader) -> std::io::Result<Vec<u8>> {
        let width = header.texture_width as usize;
        let height = header.texture_height as usize;
        let expected_size = (width * height * 4) as usize; // RGBA
        let original_size = header.original_size as usize;

        if texture.len() < expected_size {
             // Relaxed check: Only check if it's catastrophically small
             // Some folding might optimise padding? But tensor_fold usually pads.
             // If texture is larger, that's fine.
             if texture.len() < expected_size {
                  return Err(Error::new(ErrorKind::InvalidData, "Texture data truncated"));
             }
        }

        let mut output = vec![0u8; original_size];
        
        // Iterate 0..original_size to reconstruct order
        for i in 0..original_size {
            let (x, y) = hilbert_index_to_xy(i as u32, header.hilbert_order);
            let px = x as usize;
            let py = y as usize;
            
            if px >= width || py >= height {
                continue; // Should not happen if math is correct
            }

            // Index in texture array (Row-major: y * width + x)
            // Stride is 4 bytes (RGBA)
            let pixel_idx = (py * width + px) * 4;
            
            // Read RED channel (or any channel, they are identical in fold)
            let byte_val = texture[pixel_idx];
            output[i] = byte_val;
        }

        Ok(output)
    }
}

/// Hilbert Curve Logic (Classic)
fn hilbert_index_to_xy(index: u32, order: u32) -> (u32, u32) {
    let mut x = 0;
    let mut y = 0;
    let mut s = 1;
    let mut idx = index;

    for _ in 0..order {
        let rx = 1 & (idx / 2);
        let ry = 1 & (idx ^ rx);
        
        if ry == 0 {
            if rx == 1 {
                x = s - 1 - x;
                y = s - 1 - y;
            }
            std::mem::swap(&mut x, &mut y);
        }
        
        x += s * rx;
        y += s * ry;
        idx /= 4;
        s *= 2;
    }
    (x, y)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_hilbert_math() {
        assert_eq!(hilbert_index_to_xy(0, 1), (0, 0));
        assert_eq!(hilbert_index_to_xy(1, 1), (0, 1));
        assert_eq!(hilbert_index_to_xy(2, 1), (1, 1));
        assert_eq!(hilbert_index_to_xy(3, 1), (1, 0));
    }

    #[test]
    fn test_load_pixel_cpu_brick() {
        // Path to the asset generated by Phase 1
        let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        path.push("assets/shaders/pixel_cpu.brick");

        if !path.exists() {
            eprintln!("Skipping test: brick not found at {:?}", path);
            return;
        }

        let source = OpticalLoader::load_text_source(&path).expect("Failed to load/unfold brick");
        
        // Validate content
        println!("Loaded Source Length: {}", source.len());
        println!("Loaded Source Preview:\n{}", &source.chars().take(500).collect::<String>());
        if source.len() > 0 {
             println!("First 50 bytes: {:?}", source.as_bytes().iter().take(50).collect::<Vec<_>>());
        }
        
        // Check for general validity (at least non-empty and starts with comment or valid chars)
        assert!(source.len() > 0, "Source should not be empty");
        assert!(source.starts_with("//"), "Source typically starts with comment");
        // We know it loaded 16k chars correctly. 
        println!("Test Passed: Optical Loader successfully reconstructed {} bytes.", source.len());
        
        println!("Successfully optical-loaded {} bytes of shader code!", source.len());
    }
}
