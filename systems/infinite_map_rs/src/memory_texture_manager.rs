// src/memory_texture_manager.rs
// Memory Texture Manager - Phase 33 Step 3
// Manages V2 brick textures and live memory updates for Glass RAM visualization
//
// This module handles loading, caching, and rendering of V2 Spatial Bricks
// generated by the Foundry Pipeline, as well as live memory texture updates
// from MemoryTextureMapper. It provides a unified interface for
// displaying memory regions as 3D artifacts in the compositor.

use std::collections::HashMap;
use std::path::Path;
use std::sync::Arc;
use wgpu::{self, Device, Queue, Texture, TextureView, BindGroup, Sampler};
use std::time::{Duration, Instant};

use crate::memory_tensor::{V2Brick, V2BrickHeader};
use crate::memory_texture::MemoryRegion;

/// Memory texture entry containing GPU resources
#[derive(Debug)]
pub struct MemoryTexture {
    /// V2 brick header (if loaded from brick file)
    pub header: Option<V2BrickHeader>,
    /// GPU texture
    pub texture: Texture,
    /// Texture view for rendering
    pub texture_view: TextureView,
    /// Bind group for rendering
    pub bind_group: BindGroup,
    /// Window ID this texture is assigned to
    pub window_id: Option<usize>,
    /// Last update timestamp
    pub last_updated: std::time::Instant,
    /// Whether this is a live memory texture
    pub is_live: bool,
    /// Live memory region (if applicable)
    pub memory_region: Option<MemoryRegion>,
    /// Live texture update interval
    live_update_interval: Duration,
    /// Last live update timestamp
    last_live_update: Instant,
    /// Optional Hilbert LUT for memory visualization (Linear offset -> Texture index)
    pub hilbert_lut: Option<Vec<usize>>,
}

/// Memory texture manager for V2 brick rendering
///
/// Manages loading, caching, and rendering of V2 Spatial Bricks.
/// Similar to VmTextureManager but for memory visualization.
pub struct MemoryTextureManager {
    /// GPU device
    device: Arc<Device>,
    /// GPU queue
    queue: Arc<Queue>,
    /// Bind group layout for memory textures
    bind_group_layout: Arc<wgpu::BindGroupLayout>,
    /// Shared sampler
    sampler: Arc<Sampler>,
    /// Map of memory textures by brick path
    textures: HashMap<String, MemoryTexture>,
    /// Map of memory textures by window ID
    textures_by_window: HashMap<usize, String>,
    /// Maximum texture cache size
    max_cache_size: usize,
}

impl MemoryTextureManager {
    /// Create a new memory texture manager
    ///
    /// # Arguments
    /// * `device` - WGPU device
    /// * `queue` - WGPU queue
    /// * `bind_group_layout` - Bind group layout for textures
    /// * `sampler` - Shared sampler
    pub fn new(
        device: Arc<Device>,
        queue: Arc<Queue>,
        bind_group_layout: Arc<wgpu::BindGroupLayout>,
        sampler: Arc<Sampler>,
    ) -> Self {
        Self {
            device,
            queue,
            bind_group_layout,
            sampler,
            textures: HashMap::new(),
            textures_by_window: HashMap::new(),
            max_cache_size: 16, // Cache up to 16 bricks
        }
    }

    /// Load a V2 brick file and create GPU texture
    ///
    /// # Arguments
    /// * `path` - Path to .brick file
    ///
    /// # Returns
    /// * `Ok(())` - Successfully loaded
    /// * `Err(String)` - Error message
    pub fn load_brick<P: AsRef<Path>>(&mut self, path: P) -> Result<Option<String>, String> {
        let path = path.as_ref();
        let path_str = path.to_string_lossy().to_string();

        // Check if already loaded
        if self.textures.contains_key(&path_str) {
            return Ok(None); // Already loaded, source code was likely handled
        }

        // Load V2 brick
        let brick = V2Brick::load(path)?;
        let source_code = brick.source_code.clone();

        // Create GPU texture
        let texture = self.device.create_texture(&wgpu::TextureDescriptor {
            label: Some(&format!("Memory Texture: {}", path_str)),
            size: wgpu::Extent3d {
                width: brick.header.texture_width,
                height: brick.header.texture_height,
                depth_or_array_layers: 1,
            },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::Rgba8UnormSrgb,
            usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
            view_formats: &[],
        });

        let texture_view = texture.create_view(&wgpu::TextureViewDescriptor::default());

        // Upload texture data
        self.queue.write_texture(
            wgpu::ImageCopyTexture {
                texture: &texture,
                mip_level: 0,
                origin: wgpu::Origin3d::ZERO,
                aspect: wgpu::TextureAspect::All,
            },
            &brick.texture_data,
            wgpu::ImageDataLayout {
                offset: 0,
                bytes_per_row: Some(brick.header.texture_width * 4),
                rows_per_image: None,
            },
            wgpu::Extent3d {
                width: brick.header.texture_width,
                height: brick.header.texture_height,
                depth_or_array_layers: 1,
            },
        );

        // Create bind group
        let bind_group = self.device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some(&format!("Memory Bind Group: {}", path_str)),
            layout: &self.bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&texture_view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&self.sampler),
                },
            ],
        });

        // Store texture
        let memory_texture = MemoryTexture {
            header: Some(brick.header),
            texture,
            texture_view,
            bind_group,
            window_id: None,
            last_updated: std::time::Instant::now(),
            is_live: false,
            memory_region: None,
            live_update_interval: Duration::from_millis(100),
            last_live_update: Instant::now(),
            hilbert_lut: None,
        };

        self.textures.insert(path_str, memory_texture);

        // Enforce cache size limit
        self.enforce_cache_limit();

        let w = brick.header.texture_width;
        let h = brick.header.texture_height;
        let entropy = brick.header.entropy;
        log::info!("ðŸ§  Loaded V2 brick: {} ({}x{}, entropy: {:.2})",
                  path.display(),
                  w,
                  h,
                  entropy);

        Ok(source_code)
    }

    /// Assign a memory texture to a window
    ///
    /// # Arguments
    /// * `path` - Path to .brick file
    /// * `window_id` - Window ID to assign to
    pub fn assign_to_window<P: AsRef<Path>>(&mut self, path: P, window_id: usize) {
        let path_str = path.as_ref().to_string_lossy().to_string();

        // Remove old assignment for this window
        if let Some(old_path) = self.textures_by_window.remove(&window_id) {
            if let Some(texture) = self.textures.get_mut(&old_path) {
                texture.window_id = None;
            }
        }

        // Assign new texture
        if let Some(texture) = self.textures.get_mut(&path_str) {
            texture.window_id = Some(window_id);
            self.textures_by_window.insert(window_id, path_str);
        }
    }

    /// Get memory texture for a window
    ///
    /// # Arguments
    /// * `window_id` - Window ID
    ///
    /// # Returns
    /// Option containing reference to memory texture
    pub fn get_texture(&self, window_id: usize) -> Option<&MemoryTexture> {
        if let Some(path) = self.textures_by_window.get(&window_id) {
            self.textures.get(path)
        } else {
            None
        }
    }

    /// Get memory texture by path
    ///
    /// # Arguments
    /// * `path` - Path to .brick file
    ///
    /// # Returns
    /// Option containing reference to memory texture
    pub fn get_texture_by_path<P: AsRef<Path>>(&self, path: P) -> Option<&MemoryTexture> {
        let path_str = path.as_ref().to_string_lossy().to_string();
        self.textures.get(&path_str)
    }

    /// Remove a memory texture
    ///
    /// # Arguments
    /// * `path` - Path to .brick file
    pub fn remove_texture<P: AsRef<Path>>(&mut self, path: P) {
        let path_str = path.as_ref().to_string_lossy().to_string();

        if let Some(texture) = self.textures.remove(&path_str) {
            // Remove from window mapping
            if let Some(window_id) = texture.window_id {
                self.textures_by_window.remove(&window_id);
            }
        }
    }

    /// Clear all memory textures
    pub fn clear(&mut self) {
        self.textures.clear();
        self.textures_by_window.clear();
    }

    /// Get total VRAM usage of all managed textures in bytes
    pub fn get_total_vram_usage(&self) -> u64 {
        self.textures.values().map(|t| {
            let size = t.texture.size();
            (size.width * size.height * size.depth_or_array_layers * 4) as u64
        }).sum()
    }

    /// Get statistics about loaded textures
    pub fn stats(&self) -> MemoryTextureStats {
        MemoryTextureStats {
            total_textures: self.textures.len(),
            assigned_textures: self.textures_by_window.len(),
            cache_size: self.textures.len(),
            max_cache_size: self.max_cache_size,
        }
    }

    /// Enforce cache size limit
    fn enforce_cache_limit(&mut self) {
        while self.textures.len() > self.max_cache_size {
            // Find least recently used texture
            let mut lru_path = None;
            let mut lru_time = std::time::Instant::now();

            for (path, texture) in &self.textures {
                if texture.window_id.is_none() && texture.last_updated < lru_time {
                    lru_time = texture.last_updated;
                    lru_path = Some(path.clone());
                }
            }

            if let Some(path) = lru_path {
                self.remove_texture(&path);
                log::debug!("Evicted memory texture from cache: {}", path);
            } else {
                // All textures are assigned, can't evict
                break;
            }
        }
    }

    /// Load bricks from a directory
    ///
    /// # Arguments
    /// * `dir_path` - Path to directory containing .brick files
    ///
    /// # Returns
    /// * `Ok(count)` - Number of bricks loaded
    /// * `Err(String)` - Error message
    pub fn load_directory<P: AsRef<Path>>(&mut self, dir_path: P) -> Result<usize, String> {
        let dir_path = dir_path.as_ref();
        let mut count = 0;

        if !dir_path.exists() {
            return Err(format!("Directory does not exist: {}", dir_path.display()));
        }

        let entries = std::fs::read_dir(dir_path)
            .map_err(|e| format!("Failed to read directory {}: {}", dir_path.display(), e))?;

        for entry in entries {
            let entry = entry
                .map_err(|e| format!("Failed to read entry: {}", e))?;
            let path = entry.path();

            if path.extension().and_then(|s| s.to_str()) == Some("brick") {
                match self.load_brick(&path) {
                    Ok(_) => count += 1,
                    Err(e) => log::warn!("Failed to load brick {}: {}", path.display(), e),
                }
            }
        }

        Ok(count)
    }

    /// Create a live memory texture from a memory region
    ///
    /// # Arguments
    /// * `name` - Texture name
    /// * `region` - Memory region to visualize
    /// * `width` - Texture width
    /// * `height` - Texture height
    /// * `update_interval` - Update interval for live texture
    ///
    /// # Returns
    /// Texture name if successful
    pub fn create_live_texture(
        &mut self,
        name: String,
        region: MemoryRegion,
        width: u32,
        height: u32,
        update_interval: Duration,
    ) -> Result<String, String> {
        // Check if texture already exists
        if self.textures.contains_key(&name) {
            return Err(format!("Texture '{}' already exists", name));
        }

        // Create GPU texture
        let texture = self.device.create_texture(&wgpu::TextureDescriptor {
            label: Some(&format!("Live Memory Texture: {}", name)),
            size: wgpu::Extent3d {
                width,
                height,
                depth_or_array_layers: 1,
            },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::Rgba8UnormSrgb,
            usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
            view_formats: &[],
        });

        let texture_view = texture.create_view(&wgpu::TextureViewDescriptor::default());

        // Create bind group
        let bind_group = self.device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some(&format!("Live Memory Bind Group: {}", name)),
            layout: &self.bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&texture_view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&self.sampler),
                },
            ],
        });

        // Store texture
        let memory_texture = MemoryTexture {
            header: None,
            texture,
            texture_view,
            bind_group,
            window_id: None,
            last_updated: std::time::Instant::now(),
            is_live: true,
            memory_region: Some(region.clone()),
            live_update_interval: update_interval,
            last_live_update: Instant::now(),
            hilbert_lut: None,
        };

        self.textures.insert(name.clone(), memory_texture);

        log::info!("ðŸ§  Created live memory texture: {} ({}x{}, region: {})",
                  name, width, height, region.name);

        Ok(name)
    }

    /// Update live memory textures
    ///
    /// This method should be called regularly to update live memory textures
    /// based on their update intervals.
    pub fn update_live_textures(&mut self) {
        let now = Instant::now();
        let queue = self.queue.clone();

        for (name, texture) in self.textures.iter_mut() {
            if texture.is_live {
                // Check if it's time to update
                if now.duration_since(texture.last_live_update) >= texture.live_update_interval {
                    if let Some(ref region) = texture.memory_region {
                        // Update texture with live memory data
                        Self::update_live_texture_internal(&queue, name, region, &texture.texture);
                        texture.last_live_update = now;
                    }
                }
            }
        }
    }

    /// Create a texture for QEMU VM visualization
    pub fn create_qemu_texture(&mut self, name: &str, width: u32, height: u32) -> Result<(), String> {
        if self.textures.contains_key(name) {
            return Err(format!("Texture '{}' already exists", name));
        }

        let texture = self.device.create_texture(&wgpu::TextureDescriptor {
            label: Some(&format!("QEMU Texture: {}", name)),
            size: wgpu::Extent3d {
                width,
                height,
                depth_or_array_layers: 1,
            },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::Rgba8UnormSrgb,
            usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
            view_formats: &[],
        });

        let texture_view = texture.create_view(&wgpu::TextureViewDescriptor::default());

        let bind_group = self.device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some(&format!("QEMU Bind Group: {}", name)),
            layout: &self.bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&texture_view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&self.sampler),
                },
            ],
        });

        // Generate Hilbert LUT for visual coherence
        log::info!("Generating Hilbert LUT for {}x{} texture...", width, height);
        let mut hilbert_lut = Vec::with_capacity((width * height) as usize);
        let n = width.max(height); // Assume power of 2
        
        // Use fast_hilbert to generate mapping
        // We map linear address 'i' to (x, y), then back to texture linear index (y * width + x)
        // This effectively "scatters" the linear RAM into a Hilbert 2D arrangement
        for i in 0..(width * height) {
             let point: (u32, u32) = fast_hilbert::h2xy(i.into());
             let x = point.0 as u32;
             let y = point.1 as u32;
             
             if x < width && y < height {
                 hilbert_lut.push((y * width + x) as usize);
             } else {
                 hilbert_lut.push(0); // Safetly fallback
             }
        }

        let memory_texture = MemoryTexture {
            header: None,
            texture,
            texture_view,
            bind_group,
            window_id: None,
            last_updated: Instant::now(),
            is_live: true, 
            memory_region: None,
            live_update_interval: Duration::from_millis(16), 
            last_live_update: Instant::now(),
            hilbert_lut: Some(hilbert_lut),
        };

        self.textures.insert(name.to_string(), memory_texture);
        log::info!("âœ… Created QEMU texture: {} ({}x{}) with Hilbert Mapping", name, width, height);

        Ok(())
    }

    /// Update a QEMU texture from the shared memory bridge
    pub fn update_qemu_texture(&mut self, name: &str, bridge: &crate::qemu::SharedMemoryBridge) {
        if let Some(texture) = self.textures.get_mut(name) {
            // Rate limit updates
            let now = Instant::now();
            if now.duration_since(texture.last_live_update) < texture.live_update_interval {
                return;
            }

            let mem_slice = bridge.as_slice();
            let size = texture.texture.size();
            let width = size.width as usize;
            let height = size.height as usize;
            let total_pixels = width * height;
            
            let mut data = vec![0u8; total_pixels * 4];
            let len = mem_slice.len().min(total_pixels);
            
            // Apply Hilbert Mapping if LUT is present, otherwise Linear
            if let Some(ref lut) = texture.hilbert_lut {
                for i in 0..len {
                    let val = mem_slice[i];
                    // lut[i] gives us the texture index where this byte belongs spatially
                    if i < lut.len() {
                        let tex_idx = lut[i];
                        let pixel_offset = tex_idx * 4;
                        // Grayscale mapping
                        data[pixel_offset] = val;     // R
                        data[pixel_offset+1] = val;   // G
                        data[pixel_offset+2] = val;   // B
                        data[pixel_offset+3] = 255;   // A
                    }
                }
            } else {
                // Fallback Linear Mapping
                for i in 0..len {
                    let val = mem_slice[i];
                    let idx = i * 4;
                    data[idx] = val;
                    data[idx+1] = val;
                    data[idx+2] = val;
                    data[idx+3] = 255;
                }
            }
            
            // Write to texture
             self.queue.write_texture(
                wgpu::ImageCopyTexture {
                    texture: &texture.texture,
                    mip_level: 0,
                    origin: wgpu::Origin3d::ZERO,
                    aspect: wgpu::TextureAspect::All,
                },
                &data,
                wgpu::ImageDataLayout {
                    offset: 0,
                    bytes_per_row: Some((width * 4) as u32),
                    rows_per_image: None,
                },
                texture.texture.size(),
            );
            
            texture.last_live_update = now;
        }
    }

    /// Internal method to update a live texture
    fn update_live_texture_internal(queue: &Queue, _name: &str, region: &MemoryRegion, texture: &wgpu::Texture) {
        let region_size = region.end_addr - region.start_addr;
        let page_size = 4096;
        let num_pages = region_size / page_size;
        let max_pixels = (4096 * 4096) as usize; // Max texture size
        let pages_to_read = num_pages.min(max_pixels);

        // Limit max pages to read to avoid huge buffers
        let limit_pages = 10000;
        let pages_to_read = pages_to_read.min(limit_pages);

        let mut texture_data = vec![0u8; pages_to_read * 4];

        // Read memory pages
        for i in 0..pages_to_read {
            let page_addr = region.start_addr + i * page_size;
            // Read small chunk from each page
            if let Ok(page_data) = Self::read_memory(page_addr, 256) {
                let color = Self::page_to_color(&page_data);
                let pixel_idx = i * 4;
                if pixel_idx + 4 <= texture_data.len() {
                    texture_data[pixel_idx] = color[0];
                    texture_data[pixel_idx + 1] = color[1];
                    texture_data[pixel_idx + 2] = color[2];
                    texture_data[pixel_idx + 3] = 255;
                }
            }
        }

        // Upload to GPU
        let data_layout = wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4096 * 4),
            rows_per_image: None,
        };

        let image_copy_texture = wgpu::ImageCopyTexture {
            texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        };

        let rows = (texture_data.len() as u32) / (4096 * 4);
        let extent_height = if rows == 0 { 1 } else { rows };

        let extent = wgpu::Extent3d {
            width: 4096,
            height: extent_height,
            depth_or_array_layers: 1,
        };

        if texture_data.len() > 0 {
            queue.write_texture(image_copy_texture, &texture_data, data_layout, extent);
        }
    }

    /// Read memory from /proc/self/mem
    fn read_memory(addr: usize, size: usize) -> std::io::Result<Vec<u8>> {
        use std::io::{Read, Seek, SeekFrom};
        let mut mem_file = std::fs::File::open("/proc/self/mem")?;
        mem_file.seek(SeekFrom::Start(addr as u64))?;
        let mut buffer = vec![0u8; size];
        mem_file.read_exact(&mut buffer)?;
        Ok(buffer)
    }

    /// Convert page data to color
    fn page_to_color(page_data: &[u8]) -> [u8; 4] {
        let non_zero_count = page_data.iter().filter(|&&b| b != 0).count();
        let ratio = non_zero_count as f32 / page_data.len() as f32;
        let brightness = (ratio * 255.0) as u8;
        // Green tint for memory with entropy-based variation
        let entropy_factor = (ratio * 0.5) as u8;
        [0, brightness, entropy_factor, 255]
    }
}

/// Statistics about memory textures
#[derive(Debug, Clone)]
pub struct MemoryTextureStats {
    /// Total number of loaded textures
    pub total_textures: usize,
    /// Number of textures assigned to windows
    pub assigned_textures: usize,
    /// Current cache size
    pub cache_size: usize,
    /// Maximum cache size
    pub max_cache_size: usize,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_memory_texture_stats() {
        let stats = MemoryTextureStats {
            total_textures: 10,
            assigned_textures: 5,
            cache_size: 10,
            max_cache_size: 16,
        };

        assert_eq!(stats.total_textures, 10);
        assert_eq!(stats.assigned_textures, 5);
        assert_eq!(stats.cache_size, 10);
        assert_eq!(stats.max_cache_size, 16);
    }
}
