"""
WordPress Publisher for GOSR Radio Broadcasts.

Publishes radio broadcasts to WordPress via REST API.
"""

import logging
import requests
from dataclasses import dataclass
from typing import Optional, Dict, Any

logger = logging.getLogger(__name__)


@dataclass
class WordPressConfig:
    """Configuration for WordPress REST API."""
    url: str = "http://localhost:8080"
    endpoint: str = "/wp-json/geometry-os/v1/radio-broadcast"
    timeout: float = 10.0
    enabled: bool = True

    @property
    def full_url(self) -> str:
        return f"{self.url.rstrip('/')}{self.endpoint}"


class WordPressPublisher:
    """
    Publishes GOSR Radio broadcasts to WordPress.

    Usage:
        publisher = WordPressPublisher()
        publisher.publish(
            station_id="87.6",
            segment_type="weather",
            content="The entropy flows like jazz...",
            entropy=0.5,
            telemetry={"fps": 60},
            llm_generated=True
        )
    """

    def __init__(self, config: Optional[WordPressConfig] = None):
        self.config = config or WordPressConfig()
        self._last_publish_time = 0.0
        self._publish_count = 0

    def is_available(self) -> bool:
        """Check if WordPress is reachable."""
        if not self.config.enabled:
            return False

        try:
            # Quick health check
            response = requests.get(
                f"{self.config.url}/wp-json/",
                timeout=2.0
            )
            return response.status_code == 200
        except Exception as e:
            logger.debug(f"WordPress not available: {e}")
            return False

    def publish(
        self,
        station_id: str,
        segment_type: str,
        content: str,
        entropy: float = 0.5,
        telemetry: Optional[Dict[str, Any]] = None,
        llm_generated: bool = False
    ) -> bool:
        """
        Publish a broadcast to WordPress.

        Args:
            station_id: Radio station ID (e.g., "87.6")
            segment_type: Type of segment (news, weather, philosophy, etc.)
            content: The broadcast content
            entropy: Entropy level (0.0-1.0)
            telemetry: Optional telemetry data
            llm_generated: Whether content was generated by LLM

        Returns:
            True if published successfully, False otherwise
        """
        if not self.config.enabled:
            logger.debug("WordPress publishing disabled")
            return False

        payload = {
            "station_id": station_id,
            "segment_type": segment_type,
            "content": content,
            "entropy": entropy,
            "telemetry": telemetry or {},
            "llm_generated": llm_generated
        }

        try:
            response = requests.post(
                self.config.full_url,
                json=payload,
                timeout=self.config.timeout,
                headers={"Content-Type": "application/json"}
            )

            if response.status_code == 200 or response.status_code == 201:
                result = response.json()
                if result.get("success"):
                    self._publish_count += 1
                    logger.info(
                        f"Published broadcast to WordPress: "
                        f"station={station_id}, post_id={result.get('post_id')}"
                    )
                    return True
                else:
                    logger.warning(f"WordPress publish failed: {result.get('error')}")
            else:
                logger.warning(
                    f"WordPress API error: {response.status_code} - {response.text[:100]}"
                )

        except requests.exceptions.ConnectionError:
            logger.debug("WordPress connection refused")
        except requests.exceptions.Timeout:
            logger.debug("WordPress request timed out")
        except Exception as e:
            logger.debug(f"WordPress publish error: {e}")

        return False

    @property
    def publish_count(self) -> int:
        """Number of successful publishes."""
        return self._publish_count
