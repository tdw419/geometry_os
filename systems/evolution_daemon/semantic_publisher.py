"""
Semantic Publisher Bridge - Phase 20-25 + WordPress Integration

Bridges the Generative Evolution system with the WordPress Semantic District
for persistent journaling, evolution documentation, and human-readable mirrors.

Protocol: SEMANTIC PUBLISHING (WORDPRESS DISTRICT)
- Auto-Blogging: Document breakthroughs and evolution events
- Living Documentation: Update architectural specs
- Visual Sync: Pulse to Visual Bridge (port 8768)
"""

import json
import time
import logging
import asyncio
from dataclasses import dataclass, asdict
from typing import Optional, Dict, Any, List
from pathlib import Path
from datetime import datetime

# Import WordPress publisher
import sys
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "wordpress_zone"))
from publish_to_wp import publish_to_wordpress

# Import VisualBridgeClient for proper singleton connection
try:
    from systems.visual_shell.api.visual_bridge import VisualBridgeClient
    VISUAL_BRIDGE_CLIENT_AVAILABLE = True
except ImportError:
    VISUAL_BRIDGE_CLIENT_AVAILABLE = False
    VisualBridgeClient = None

logger = logging.getLogger(__name__)


@dataclass
class EvolutionEvent:
    """A semantic evolution event for WordPress publishing."""
    event_type: str  # evolution, breakthrough, diagnostic, architectural
    agent_id: str
    component: str
    operation: str
    details: Dict[str, Any]
    timestamp: float
    confidence: float

    def to_html_content(self) -> str:
        """Convert event to semantic HTML for WordPress."""
        timestamp_str = datetime.fromtimestamp(self.timestamp).strftime("%Y-%m-%d %H:%M:%S")

        html = f"""
        <div class="evolution-event" data-type="{self.event_type}">
            <h3>ğŸ”„ {self.event_type.upper()}: {self.component}</h3>
            <p><b>Agent:</b> {self.agent_id}</p>
            <p><b>Operation:</b> <code>{self.operation}</code></p>
            <p><b>Confidence:</b> {self.confidence:.2%}</p>
            <p><b>Timestamp:</b> {timestamp_str}</p>

            <h4>ğŸ“Š Metrics</h4>
            <ul>
        """

        for key, value in self.details.items():
            if isinstance(value, float):
                html += f"<li><b>{key}:</b> {value:.4f}</li>\n"
            else:
                html += f"<li><b>{key}:</b> {value}</li>\n"

        html += """
            </ul>
            <hr>
            <p><em>Generated by Geometry OS Semantic Publisher</em></p>
        </div>
        """
        return html


class SemanticPublisher:
    """
    Bridge between Generative Evolution and WordPress Semantic District.

    Enables:
    - Persistent journaling of evolution events
    - Living documentation updates
    - Visual sync via Visual Bridge (port 8768)

    Constraints:
    - Localhost only (ai-publisher.php accepts 127.0.0.1)
    - Rate limiting: max 1 publish per 30 seconds
    - Semantic HTML coding for human readability
    """

    def __init__(
        self,
        enabled: bool = True,
        bridge_url: str = "ws://localhost:8768",
        rate_limit_seconds: float = 30.0
    ):
        self.enabled = enabled
        self.bridge_url = bridge_url
        self.rate_limit_seconds = rate_limit_seconds
        self.last_publish_time = 0.0
        self.event_queue: List[EvolutionEvent] = []

        # Use VisualBridgeClient for proper singleton connection
        if VISUAL_BRIDGE_CLIENT_AVAILABLE:
            self._client = VisualBridgeClient(ws_url=bridge_url, agent_id="semantic_publisher")
        else:
            self._client = None
            logger.warning("VisualBridgeClient not available, falling back to direct websocket")

        self.running = False

        # District positioning (Spatial Tectonics)
        self.district_id = "evolution_daemon"
        self.spatial_pos = {"x": 1600, "y": 800}  # Near center, evolution zone

    def is_rate_limited(self) -> bool:
        """Check if we're within rate limits."""
        return (time.time() - self.last_publish_time) < self.rate_limit_seconds

    def queue_event(self, event: EvolutionEvent) -> None:
        """Queue an event for publishing."""
        self.event_queue.append(event)
        logger.info(f"Queued evolution event: {event.event_type} - {event.component}")

    async def connect_bridge(self) -> bool:
        """Connect to Visual Bridge for real-time sync."""
        if not self.enabled:
            return False

        if self._client:
            try:
                connected = await self._client.connect()
                if connected:
                    self.running = True

                    # Register district
                    await self._client.send("district_upgrade", {
                        "district_id": self.district_id,
                        "upgrade_type": "SEMANTIC_PUBLISHER_INIT",
                        "status": "ONLINE",
                        "position": self.spatial_pos
                    })

                    logger.info(f"Connected to Visual Bridge via VisualBridgeClient: {self.bridge_url}")
                    return True
                else:
                    logger.warning("VisualBridgeClient connection failed")
                    return False
            except Exception as e:
                logger.warning(f"Visual Bridge connection failed: {e}")
                return False
        else:
            # Fallback to direct websocket if VisualBridgeClient not available
            import websockets
            try:
                self._ws = await websockets.connect(self.bridge_url)
                self.running = True

                # Register district
                await self._ws.send(json.dumps({
                    "type": "district_upgrade",
                    "district_id": self.district_id,
                    "upgrade_type": "SEMANTIC_PUBLISHER_INIT",
                    "status": "ONLINE",
                    "position": self.spatial_pos
                }))

                logger.info(f"Connected to Visual Bridge (fallback): {self.bridge_url}")
                return True

            except Exception as e:
                logger.warning(f"Visual Bridge connection failed: {e}")
                return False

    async def send_pulse(self, event: EvolutionEvent) -> None:
        """Send telemetry pulse to Visual Bridge."""
        if not self.running:
            return

        pulse = {
            "district_id": self.district_id,
            "event_type": event.event_type,
            "component": event.component,
            "operation": event.operation,
            "confidence": event.confidence,
            "timestamp": event.timestamp,
            "position": self.spatial_pos
        }

        try:
            if self._client:
                await self._client.send("evolution_event", pulse)
            elif hasattr(self, '_ws') and self._ws:
                pulse["type"] = "evolution_event"
                await self._ws.send(json.dumps(pulse))
        except Exception as e:
            logger.warning(f"Pulse send failed: {e}")

    def publish_event(self, event: EvolutionEvent) -> Optional[Dict]:
        """
        Publish an evolution event to WordPress.

        Respects rate limiting and formats content as semantic HTML.
        """
        if not self.enabled:
            logger.debug("Semantic publishing disabled")
            return None

        if self.is_rate_limited():
            logger.debug(f"Rate limited, queueing event: {event.event_type}")
            self.queue_event(event)
            return None

        # Generate title
        title = f"[{event.event_type.upper()}] {event.component}: {event.operation}"

        # Generate HTML content
        content = event.to_html_content()

        # Publish to WordPress
        try:
            result = publish_to_wordpress(
                title=title,
                content=content,
                post_type="post"
            )

            if result:
                self.last_publish_time = time.time()
                logger.info(f"Published to WordPress: {result.get('url')}")

                # Send visual pulse (safely handle async)
                try:
                    loop = asyncio.get_running_loop()
                    loop.create_task(self.send_pulse(event))
                except RuntimeError:
                    # No running event loop, skip pulse
                    pass

                return result

        except Exception as e:
            logger.error(f"WordPress publish failed: {e}")

        return None

    def publish_architectural_update(
        self,
        component: str,
        changes: str,
        rationale: str
    ) -> Optional[Dict]:
        """
        Publish architectural documentation update.

        Used by Architect Agent when modifying system architecture.
        """
        event = EvolutionEvent(
            event_type="architectural",
            agent_id="architect",
            component=component,
            operation="documentation_update",
            details={
                "changes": changes,
                "rationale": rationale
            },
            timestamp=time.time(),
            confidence=1.0
        )

        return self.publish_event(event)

    def publish_breakthrough(
        self,
        component: str,
        metric_name: str,
        before: float,
        after: float,
        agent_id: str = "evolution_daemon"
    ) -> Optional[Dict]:
        """
        Publish a breakthrough event (significant metric improvement).
        """
        improvement = ((after - before) / before * 100) if before > 0 else 0

        event = EvolutionEvent(
            event_type="breakthrough",
            agent_id=agent_id,
            component=component,
            operation="metric_improvement",
            details={
                "metric": metric_name,
                "before": before,
                "after": after,
                "improvement_pct": improvement
            },
            timestamp=time.time(),
            confidence=min(0.99, 0.5 + abs(improvement) / 100)
        )

        return self.publish_event(event)

    def publish_diagnostic(
        self,
        component: str,
        status: str,
        message: str,
        agent_id: str = "diagnostic"
    ) -> Optional[Dict]:
        """
        Publish a diagnostic or security alert.
        """
        event = EvolutionEvent(
            event_type="diagnostic",
            agent_id=agent_id,
            component=component,
            operation="health_check",
            details={
                "status": status,
                "message": message
            },
            timestamp=time.time(),
            confidence=1.0
        )

        return self.publish_event(event)

    def flush_queue(self) -> int:
        """Flush queued events (for batch publishing)."""
        published = 0
        while self.event_queue and not self.is_rate_limited():
            event = self.event_queue.pop(0)
            if self.publish_event(event):
                published += 1
        return published


# Integration helper for TerminalAreaAgent
class EvolutionJournaler:
    """
    Helper class for TerminalAreaAgent to journal evolution events.

    Usage in terminal_agent.py:
        from evolution_daemon.semantic_publisher import EvolutionJournaler

        class TerminalAreaAgent:
            def __init__(self, ...):
                self.journaler = EvolutionJournaler()

            def propose_evolution(self, texture):
                proposal = ...
                if proposal:
                    self.journaler.log_proposal(proposal)
                return proposal
    """

    def __init__(self, enabled: bool = True):
        self.publisher = SemanticPublisher(enabled=enabled)
        self.event_count = 0

    def log_proposal(self, proposal) -> None:
        """Log an evolution proposal."""
        event = EvolutionEvent(
            event_type="evolution",
            agent_id=proposal.agent_id,
            component="terminal_region",
            operation=proposal.operation,
            details={
                "region": proposal.region,
                "rationale": proposal.rationale,
                **proposal.metadata
            },
            timestamp=time.time(),
            confidence=proposal.confidence
        )
        self.publisher.publish_event(event)
        self.event_count += 1

    def log_analysis(self, agent_id: str, analysis: Dict) -> None:
        """Log a texture analysis event."""
        event = EvolutionEvent(
            event_type="analysis",
            agent_id=agent_id,
            component="texture_analyzer",
            operation="analyze",
            details=analysis,
            timestamp=time.time(),
            confidence=0.9
        )
        self.publisher.publish_event(event)
        self.event_count += 1

    def log_breakthrough(self, component: str, metric: str, before: float, after: float) -> None:
        """Log a breakthrough improvement."""
        self.publisher.publish_breakthrough(component, metric, before, after)


if __name__ == "__main__":
    # Demo/test
    print("ğŸ§  Semantic Publisher Bridge Test")
    print("=" * 50)

    publisher = SemanticPublisher(enabled=True)

    # Test breakthrough event
    event = EvolutionEvent(
        event_type="breakthrough",
        agent_id="terminal_agent_1",
        component="entropy_optimization",
        operation="sharpen",
        details={
            "entropy_before": 5.2,
            "entropy_after": 3.8,
            "improvement": "27%"
        },
        timestamp=time.time(),
        confidence=0.87
    )

    print(f"\nğŸ“¤ Publishing event: {event.event_type}")
    print(f"   Component: {event.component}")
    print(f"   Operation: {event.operation}")

    result = publisher.publish_event(event)

    if result:
        print(f"\nâœ… Published successfully!")
        print(f"   URL: {result.get('url')}")
        print(f"   ID: {result.get('post_id')}")
    else:
        print("\nâš ï¸ Publishing skipped (rate limited or disabled)")
